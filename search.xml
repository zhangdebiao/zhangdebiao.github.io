<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ISCC2018线下赛总结]]></title>
    <url>%2F2018%2F06%2F26%2FISCC2018%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[环境介绍先拿自己靶机，攻下高地，进入公共区域攻防这次比赛打得非常差，赛后又重新自己复现了一下，emmm大概是这个样子的给了一个环境，是Tomcat，开了8080端口 比赛信息是192.168.43.70/whatisyourname/，这里用到了fastjson反序列化漏洞，熟悉Java的同学应该能看出来(但我是真的看不出来（╯－＿－）╯╧╧ ) fastjson反序列化漏洞参考：https://blog.csdn.net/yaofeino1/article/details/76377080https://github.com/iBearcat/Fastjson-Payloadhttps://github.com/shengqi158/fastjson-remote-code-execute-poc 环境源码下载通过github下载含有漏洞环境的web源代码下载地址直接将war包放到tomcat的webapp目录下，运行tomcat就行： 漏洞复现：通过浏览器访问环境URL，利用burpsuite对数据包进行拦截，修改数据包发送方式并且插入POST数据{“name”:”feifei”,age:12} ，查看效果：然后根据参考文献找到Test.java文件构造poc(反弹shell)，编译一下生成.class文件base64 encode一下替换name字段，post过去可以看到命令执行成功nc连接上执行命令然后就是执行主办方给的getflag命令就可以打了，当时不知道什么原因环境命令执行有时能成功有时不成功≡￣﹏￣≡nc也死活连不上说到底还是自己好菜，对基础的东西理解还是不扎实，还是要多总结多刷题以赛代练，希望自己能进步的快一点 &lt;(￣ c￣)y▂ξ]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三届安恒杯线下赛总结]]></title>
    <url>%2F2018%2F06%2F26%2F%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AE%89%E6%81%92%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这次比赛只有一道web环境，用的是ECShop V2.7.3&emsp;&emsp;模式是AD攻防，规则很简单（虽然半天才搞明白 ￣﹏￣），让对方的极其请求http://10.0.1.2，并带上自己的token，即可获取flag poc1post方式文件url：http://10.50.%s.2/mobile/index.php参数：url=http://10.0.1.2?token=RCNWBJXQ poc2post方式文件url：http://10.50.33.2/mobile/index.php?m=default&amp;c=auction参数：1=phpinfo() 提示线索1:mobile/themes/default/auction_list.dwt这是一个预留后门，比较叼D盾扫不出来提示线索2:mobile/api/uc.php 任意文件读取(poc 1)根据给出的poc1，我们快速去定位问题文件位置我们从mobile入口文件入手即： mobile/index.php查看内容跟踪文件 看到内容 跟踪apps/目录可以发现3个文件夹 我们首先看到默认文件夹 此时又得到5个文件夹 从第一个common文件夹开始可以看到insert.php中的一个函数 看到关键代码 其中 明显是一个任意文件读取利用脚本： 一句话木马文件(poc 2)防守方法删除预留后门auction_list.dwt文件即可当时官方给出提示：auction_list.dwt文件!upload successful由于此文件用于渲染，直接将小马删除即可 任意写文件防守方法改掉writesth函数名即可定位到mobile/api/uc.php在action数组中发现了一些奇怪的东西最后一个writesth十分瞩目，一看就应该是主办方留下的功能，我们全局搜索这个writesth函数不难发现以下关键代码：即：文件名可控文件内容可控即可写入Webshell我们测试运行即可发现我们当前目录下写入sky.php，内容为但是由于当时的环境里，只有data目录有可写全写，而我们默认路径为所以直接写可能无效，应该选择上跳，例如 ../data/sky.php ECShop v2.7.3后台直接getshell防守方法改掉后台密码即可（默认admin admin888） 弱口令本次比赛还有一个漏洞就是ctf用户弱口令cat /etc/shadow得到ctf账户密码123456就因为这个漏洞被dalao全场从头打到尾…]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash长度拓展攻击]]></title>
    <url>%2F2018%2F05%2F08%2Fhash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[Hash Length Extension Attack&emsp;&emsp;总体来说就是我们知道一个加盐的hash值，即使我们不知道盐的具体内容，但只要知道长度就可以随便伪造种带盐的hash（相当于我们控制了明密文） MD5加密原理先介绍一下md5加密的原理 个人理解: md5的过程可以分成填充和压缩的过程 md5 padding(填充)&emsp;&emsp;message padding&emsp;&emsp;length%64=56(8位标识原始长度)填充的时候，将会使用16进制数据：&emsp;~1个\x80&emsp;~N个\0x00 md5 compress(压缩)&emsp;&emsp;message padding length—–&gt;hash&emsp;&emsp;length=N*64(bit) —–&gt;length%64(bit) md5 padding例如我们把admin来hash一下:admin 先hex编码-&gt;61646d696e再填充80不满64bit，填充到第56位（50个00）——为了保证信息的长度为N*64+56(字节)最后数据表示位2800000000000000（8个字节）最终结果为: 61646d6968000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000 什么是Magic number (确定值)代码中的0x67452301L, 0xefcdab89L, 0x98badcfeL, 0x10325476L这4个初始化的number就被称为Magic number或者是md5 iv (md5向量) md5 compress我们发现，无论输入多长的信息，计算出来的问就按hash长度都是固定的(md5有32字节)，这就是因为hash算法是一种压缩算法。Hash设计的时候不要求还原，所以就尽可能的扩大信息对每一位hash值的印象。在计算中，也是通过对每组长度为64bit信息分组进行迭代运算实现的。每一次迭代，都会利用一个初始值与本组中的原始信息做一个复杂的数学运算，而将生成的结果带入到下次的复杂运算中作为初始值我们还是计算admin的md5值。因为不满64bit,所以padding之后也只有64个bit，也就需要计算一轮compress压缩算法。压缩算法完成后产生的心magic number为：A=0x292f2321LB=0xa7a5577aLC=0xe4a8943LD=0xc31f804aL而md5的结果:我们发现其实就是这一轮结果的简单拼接（小端存储数据倒叙） hash长度拓展攻击其实只要知道三点后就能进行攻击： MD5(salt+message)的值 message内容 salt+message长度这样就可以在不知道salt的具体内容下，计算出任意的md5(salt+message+padding+append)值因为salt+message+padding内容是经过填充的，一定是N*64，所以这个部分刚好能完成N轮复杂运算。而他的结果，也就是md5(salt+message+padding)刚好是用来做下一轮运算，也就是m’+padding运算的初始向量。 攻击过程逆向算法很简单 def compute_magic_number(self, md5str): self.A = struct.unpack(&quot;I&quot;, md5str[0:8].decode(&apos;hex&apos;))[0] self.B = struct.unpack(&quot;I&quot;, md5str[8:16].decode(&apos;hex&apos;))[0] self.C = struct.unpack(&quot;I&quot;, md5str[16:24].decode(&apos;hex&apos;))[0] self.D = struct.unpack(&quot;I&quot;, md5str[24:32].decode(&apos;hex&apos;))[0] 由它逆出A=0x292f2321L,B=0xa7a5577aL,C=0xe4a8943L,D=0xc31f804aL根据这4个Magci number，再和扩展的字符串m’(此时的m’要进行padding，padding的长度是len(salt+message+padding+m’))进行md5 compress，最后的结果即md5(salt+message+padding+m’)这样就完成了长度拓展攻击 例题测试实验吧-让我进去抓包改source，Repeater过去发现源码 $flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;; $secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security $username = $_POST[&quot;username&quot;]; $password = $_POST[&quot;password&quot;]; if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } } setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here } } 按照源码要求，cookie中要存在变量getmein，而且，要 $COOKIE[“getmein”] === md5($secret . urldecode($username . $password))sample-hash是secret+adminadmin的MD5这里secret相当于盐，我们并不知道，但是我们知道它的长度是15，算上后面admin就是20。数据是admin签名（哈希值）是571580b26c65f306376d4f64e53cb5c7生成的hash是新的签名，设置到cookies的getmein里面把\x换成%后post提交，得到flag]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝鲸笔记系统writeup]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%93%9D%E9%B2%B8%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9Fwriteup%2F</url>
    <content type="text"><![CDATA[蓝鲸笔记系统给出一个login界面，url看上去似乎有问题http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=login感觉像是有文件包含随便尝试一下http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=index果然是文件包含。先随便注册一个账号进去看看，发现 hint:./dbinit.sql 发现了flag字段，flag应该就是在数据库里面了 肯定是文件包含无疑了，相办法读源码 利用php伪协议读源码：php://filter/read=convert.base64-encode/resource=不让读，真尴尬 然后仔细看了看url，猜测这个front是文件夹名，login是文件名http://202.98.28.108:10013/7sghfe673jd3/front/index.php还是拒绝访问… 猜测后台脚本是这样写的:include($action.’/‘.$mode.’.php’)require”$action.’/‘.$mode.’.php’” 成功读出来了！！！login不让读，但是审计index.php的源码时发现common.php，顺便把源码也down下来 代码审计先看一下index.php，并没有发现什么东西在common.php中发现一些定义的函数 御剑扫一下，发现/admin/login.php , /admin/index.php，把源码都down下来在/admin/login.php中发现 /admin/login.php,调用了set_login()函数 /front/common.php中有set_login()函数的定义 来到http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login 跟踪一下这几个函数，这里设置了cookies和session。可以看出来最后set_cookie的值是$uname|$endata$uname是admin。则cookie是 admin|md5(SECURITY_KEY+admin) SECURITY_KEY 是个随机数，每一位是从wh两个字母中随机出来的6位随机数 看一下后台登陆验证 两个函数在common.php中 这里验证了userid和level，如果cookie验证失败，则返回false，level如果是0，也返回false。 但是如果我们没有登陆，直接来到/admin/index.php页面，而且绕过cookie的验证，那么userid和level的默认初始值都是null。在php中，null!==False Truenull!=FalseFalse$null!==false是返回true的。所以只要我们能伪造cookie，就可以绕过验证。 爆破cookie脚本import requests import hashlib import random import string false_tag = &quot;not login!&quot; url = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=index&quot; url_csrf = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login&quot; def rand_str(length): return &apos;&apos;.join(random.choice(string.ascii_letters + string.digits) for _ in range(length)) def md5_encode(data): hash = hashlib.md5() hash.update((data + &quot;admin&quot;).encode()) return hash.hexdigest() key = [] for x1 in [&quot;w&quot;,&quot;h&quot;]: for x2 in [&quot;w&quot;,&quot;h&quot;]: for x3 in [&quot;w&quot;,&quot;h&quot;]: for x4 in [&quot;w&quot;,&quot;h&quot;]: for x5 in [&quot;w&quot;,&quot;h&quot;]: for x6 in [&quot;w&quot;,&quot;h&quot;]: key.append(x1+x2+x3+x4+x5+x6) print key s = requests.Session() s.headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&apos;, &apos;cookie&apos;: &apos;&apos; } for x in key: s.headers[&quot;cookie&quot;] = &quot;uid=admin%7C&quot;+md5_encode(x)#+&quot;;&quot;+&quot;PHPSESSID={}&quot;.format(rand_str(26)) s.headers[&quot;PHPSESSID&quot;] = rand_str(26) print s.headers[&quot;cookie&quot;] result = s.get(url) #print result.content if false_tag in result.content: print &quot;NO&quot;,x else: print &quot;YES&quot; print s.headers print result.content break 发现setpagenumu页面，down下来源码 二次注入发现post的page是用户可以输入但是类型限制了纯数字，应该是没有办法注入 回去审计/admin/index.php 发现数据库里查询的是$page_size,跟踪get_page_size(), get_page_size()函数返回num，也就是index里面的$page_size感觉应该能注入，回去看数据库文件 发现数据库里定义的page是varchar类型标准的脚本代码与数据库类型不匹配利用is_numeric()函数的漏洞(认为0x…是整数)，构造一个二次注入 数据库文件中可以看到一共有四个列 构造注入语句2 union select 1,flag,flag,4 from flags转成十六进制注入即可拿到flag0x3220756e696f6e2073656c65637420312c666c61672c666c61672c342066726f6d20666c616773]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>二次注入</tag>
        <tag>php函数漏洞</tag>
        <tag>php伪协议</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理系统writeup]]></title>
    <url>%2F2018%2F04%2F08%2Fday1%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件上传之代码审计前几天做了一道有趣的web题，涉及到文件上传，代码审计，二次注入。 首先是一个文件管理系统，上传文件，重命名文件，删除文件的功能。也给出了网站源码。先审计代码，看一下upload.php文件上传函数，先看服务器怎么检查文件的，可以看到$pat_part[“extension”]不允许php上传其中文件名 也被addslashes函数过滤，转义了一些字符，因此这里应该不存在注入 文件名存在数据库两个字段中，一个是filename（文件名），一个是extension（后缀名） 可以看出来文件名走过的流程是：$file[‘name’]—&gt;pathinfo()—&gt;$path_part[‘filename’]—&gt;addslashes()—&gt;insert 再看一下rename.php首先查询文件名，如果存在，执行sql语句根据$req[‘filename’]从数据库里查询到已存在的一行，并调用update语句进行修改 但在这里{oldname=[‘filename’]}将从数据库里查出的$result[‘filename’]再一次入库，结果造成一个二次注入 如果我们可以插入让extension的值为空，再把文件名在改名为.php就可以解析了 那么思路很明确，我们上传一个有恶意字段的jpg文件，然后rename进数据库，让后缀名变为空，然后再上传一个木马文件，由于extension为空，所以再次修改的时候不会加上.jpg的扩展名。 解题步骤： 上传文件名为’,extension=’’,filename=’aa.jpg.jpg 这样filename的值为’,extension=’’,filename=’aa.jpg 我们重命名把’,extension=’’,filename=’aa.jpg改为aa.jpg 这时我们再次上传一个写有木马的文件，文件名为aa.jpg 此时不会提示file is exists 因为extension!=jpg 将aa.jpg改为aa.php即可]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>代码审计</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSA总结]]></title>
    <url>%2F2018%2F04%2F06%2Frsa%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先留个坑，回头写…]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>crypto</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传常规漏洞总结]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%84%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[从文件上传到getshell一般找到文件上传页面，常规getshell思路:先检查服务器验证上传文件的逻辑，再想办法绕过 前台js验证——禁用js，burpsuit抓包绕过即可 后台检查MIME——抓包改MIME 后台文件内容检测——(一般是用GetImageSize函数) 制作图片马上传 .hatccess上传(apache)——创建一个.hatccseea文件设置命名有”php.gif”的文件当作php文件解析执行：&lt;FilesMatch “php.gif”&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 上传的jpg文件都会以php格式解析：AddType application/x-httpd-php .jpg 后台检查文件后缀名—— 0x00截断上传 (php版本小于5.3.4，php的magic_quotes_gpc为OFF)1.php .png(空格改为00) IIS6.0解析漏洞文件 xxx.asp;.jpg (服务器默认不解析;号后面的内容) 文件夹 xxx.asp/xxx.jpg (服务器默认会把.asp，.asp目录下的文件都解析成asp文件) apache解析漏洞www.xxx.com/logo.jpg.php.xxx(遇到不识别的后缀名向前解析) iis7.0和nginx解析漏洞www.xxx.com/logo.jpg/*.php(开启fix_pathinfo) 文件包含漏洞和利用 如果php脚本中使用了include,include_once,reqiure,requier_once这四个函数，并且函数的参数是用户可以控制的，就能造成文件包含漏洞 通常的include函数中，就算是可以控制参数但是后缀名也大多被限制，例如include($file.’.txt’)这样就只能包含txt文件。这时我们可以结合%00截断包含任意文件。index.php%00 文件包含漏洞也可以结合php伪协议，例如php://,phar://等等(php://input甚至可以写入木马)。例如文件包含进来但是无法显示时，可以用伪协议读文件的源码(php://filter/read=convert.base64-encode/resourse=包含文件)]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>web</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次攻防训练赛小记]]></title>
    <url>%2F2018%2F04%2F01%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%BB%E9%98%B2%E8%AE%AD%E7%BB%83%E8%B5%9B%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;昨天按照实验室的要求，我们参加了个人的第一场ctf攻防形式的训练赛。形式是线上赛，由师傅搭好的环境，总体来说收获还是很大的，见识到了很多有(yin)趣(xian)的套路。总结一下 &emsp;&emsp;先说一下规则，一个五个队伍，每队两人。因为是训练，只有三道Web题，拿到其他队的flag加十分，被攻击队伍扣除相应分数。重启服务器扣除300分。五分钟一回合，宕机一回合扣除 (未宕机队伍的数量)*3 ，分数平均加到相应的队伍。（过程中发现一个骚操作就是当其他队伍宕机了，你还可以用之前上的shell拿flag，这样相当于多加了一部分分数） 第一道题是semcms1.1版本，上网查到相应漏洞，首先注入找到后台密码，后台有个任意文件上传，上一张图片马直接getshell，连菜刀顺利拿到flag。但是大佬们更快一步，已经吊打我们而且把洞修好了… 第三题是一个微窗cms，有一个命令执行的洞。稍微有一点点麻烦，这个好像没法上shell，直接构造命令执行语句也能读出flag 第二题最骚，页面发现一个神奇md5，解密后发现是ranzhi，搜了一些poc都用不了，最后也没做出来。最后师傅们分享write up后发现website源码里有一个预留后门，直接菜刀拿shell！！！(hao qi ya)正规解法是mysql查询到登录密码，登陆进去有一个上shell的地方。本菜代码审计能力太差，也没看懂 这次比赛下来身为小白总结了几点：&emsp;&emsp;对于一个攻防比赛，最开始并不是攻击，也不是防御。二话不说ssh连上自己website把源码备份一遍。这样以来，如果以后不慎自己服务器宕机了，还有复原的机会。 1234攻击方面： 拿到一个Web，黑盒找漏洞就比较简单，上网搜对应的资料。 白盒的话就是代码审计，打包下载到本地，利用代码审计工具Seay快速审计。 还有就是看看对数据库的操作有没有限制，这次就是出题人对mysql并没有任何限制，也就是说很多东西我们直接可以从数据库里找。还有就是看一下有没有出题人留得后门。 12345防御方面：首先猜测防御规则， 不要再防守的时候吧自己服务器给干掉了。 通用防御：上waf，直接吧不想要的请求比如post，get全部给禁掉等等； 设置目录权限，例如上传目录权限给死。 最后一个也是最耗时间的，就是代码审计，找到漏洞存在的位置，修改代码。 &emsp;&emsp;比赛结束后的交流也见识到了一些骚套路，比如什么不死马，利用虚拟机做蜜罐专偷其他队伍shell什么的，zhang见识了，具体的操作有空再研究。奋斗ing…]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[本着分享即学习的原则，本菜最近新搭建了博客。（⊙.⊙） 一方面是记录一下平时学习中遇到一些问题和想法;另一方面算是激励自己学习的一个动力。(ง •̀_•́)ง (*•̀ㅂ•́)و 如有错误还请各位师傅批评指正。(´･◡･`)]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[hei,john]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
