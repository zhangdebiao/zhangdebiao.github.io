<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django学习笔记_4]]></title>
    <url>%2F2018%2F07%2F29%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4%2F</url>
    <content type="text"><![CDATA[Templates 模板 模板处理 快捷函数 定义模板模板语言包括 变量 标签 过滤器 { % 代码块 %} 注释 变量在模板中调用对象的方法标签过滤器注释 模板继承 说明 三层继承模型 HTML转义 会被自动转义的字符 关闭转义 字符串字面值 CSRF 验证码 验证码视图 配置url 显示验证码 验证 第三方 可以在网上搜索“验证码”，找到一些第三方验证码提供网站，阅读文档，使用到项目中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记_3]]></title>
    <url>%2F2018%2F07%2F28%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%2F</url>
    <content type="text"><![CDATA[Models.py ORM对象-关系-映射根据对象的类型生成表结构将对象，列表的操作，转换为sql语句将sql查询到的结果转换为对象，列表 Django中的模型包含存储数据的字段和约束，对应着数据库中唯一的表 使用mysql数据库pip install mysql-python 在mysql中创建数据库create database test2 charest=utf8; 打开settings.py文件，修改DATABASES项可以看到我们现在用的是sqlite3这个数据库(自己生成一个db.sqlite3数据库文件)settings.py中改个配置就可以用我们的mysql数据库 开发流程 使用已有数据库生成模型类python manage.py inspectdb &gt; booktest/models.py 创建添加应用python manage.py startapp booktest创建应用之后需要把应用booktest添加到settings.py的INSTALLED_APPS 定义模型 定义属性 字段类型 字段选项 关系 示例 在models.py中定义表结构 生成迁移之后python manage.py makemigrations 执行迁移之后python manage.py migrate 类的属性 管理器（可自定义）模型类—&gt;管理器—&gt;数据库（管理器是模型类的一个属性，用于将对象和数据表映射） 模型类的创建方法&emsp;&emsp;在自定义的模型类中写init方法时会报错，因为model.Model中已经有了init方法，那我们怎么快捷创建每个模型类呢？解决方法： (1) 创建类方法。 我们在模型类中，自定义一个创建模型类的方法我们在python manage.py shell中，创建一个abc对象：报错是因为时区问题，不影响 (2) 在自定义的管理器中，创建对象方法 （不在类中做这件事） 模型查询 查询集 限制查询集 查询集的缓存 字段查询 比较运算符 聚合函数 F对象 Q对象]]></content>
      <categories>
        <category>Django学习笔记</category>
        <category>3_Django模型</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记_2]]></title>
    <url>%2F2018%2F07%2F28%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%2F</url>
    <content type="text"><![CDATA[Views.py 视图 URL匹配的过程url也可以写在应用(booktest)中: URLconf 其他的URLconfs URL的反向解析 错误视图Django原生自带几个默认视图用于处理HTTP错误 404(page not found)视图 500(server error)视图 400(bad request)视图 HttpRequest对象 服务器收到http协议的请求后，会根据报文创建HttpRequest对象 视图函数的第一个参数是HttpRequest对象 在django.http模块中定义了HttpRequest对象的API属性方法 1、get()作用：根据键获取值只能获取一个值www.baidu.com/abc?a=1&amp;b=2&amp;c=3 2、getlist()将键的值以列表的形式返回可以获取多个值www.baidu.com/abc?a=1&amp;a=2&amp;c=3 QueryDict对象GET属性POST属性 HttpResponse对象 属性 方法 子类HttpResponseRedirectHttpResponseRedirect()可简写为redirect() 子类JsonResponse 状态保持 启用session 使用session 用户登录示例在views.py中创建视图 配置url 创建模板index.html 创建模板login.html 会话过期时间 存储session 使用Redis缓存session 登录认证逻辑利用django封装好的authenticate()函数，认证登录Django防止越权，直接访问127.0.0.1:8000/manage/不允许访问 from django.contrib.auth.decorators import login_required @login_required 如果想限制某个试图函数必须登录才能访问，则在函数前面加上@login_required即可(记得清除浏览器缓存)]]></content>
      <categories>
        <category>Django学习笔记</category>
        <category>2_Django视图</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记_1]]></title>
    <url>%2F2018%2F07%2F28%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[环境安装Django安装：pip install django==1.10.3安装前段框架Bootstrap3，利用其结合Django开发Web页面： pip install django-bootstrap3使用PyMysql连接mysql数据库： pip install PyMySQL Django框架介绍&emsp;&emsp;Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MVT模式。它们各自的职责如下： 层次 职责 模型（Model），即数据存取层 处理与数据相关的所有事务： 如何存取、如何验证有效性、包含哪些行为以及数据之间的关系等。 模板(Template)，即业务逻辑层 处理与表现相关的决定： 如何在页面或其他类型文档中进行显示。 视图（View），即表现层 存取模型及调取恰当模板的相关逻辑。模型与模板的桥梁。 &emsp;&emsp;从以上表述可以看出Django 视图不处理用户输入，而仅仅决定要展现哪些数据给用户，而Django 模板 仅仅决定如何展现Django视图指定的数据。或者说, Django将MVC中的视图进一步分解为 Django视图 和 Django模板两个部分，分别决定 “展现哪些数据” 和 “如何展现”，使得Django的模板可以根据需要随时替换，而不仅仅限制于内置的模板。 &emsp;&emsp;至于MVC控制器部分，由Django框架的URLconf来实现。URLconf机制是使用正则表达式匹配URL，然后调用合适的Python函数。URLconf对于URL的规则没有任何限制，你完全可以设计成任意的URL风格，不管是传统的，RESTful的，或者是另类的。框架把控制层给封装了，无非与数据交互这层都是数据库表的读,写,删除,更新的操作。在写程序的时候，只要调用相应的方法就行了，感觉很方便。程序员把控制层东西交给Django自动完成了。 只需要编写非常少的代码完成很多的事情。所以，它比MVC框架考虑的问题要深一步，因为我们程序员大都在写控制层的程序。现在这个工作交给了框架，仅需写很少的调用代码，大大提高了工作效率。 web框架 什么是ORM？ Django框架&emsp;&emsp;目录分开，就必须有机制将他们在内里进行耦合。在Django中，urls、orm、static、settings等起着重要的作用。一个典型的业务流程是如下图所示：&emsp;&emsp;Django是一个基于MVC构造的框架。但是在Django中，控制器接受用户输入的部分由框架自行处理，所以 Django 里更关注的是模型（Model）、模板(Template)和视图（Views），称为 MTV模式。 Django优点 强大的数据库功能 用 python 的类继承，几行代码就可以拥有一个丰富、动态的数据库操作接口（API），如果需要，你也能执行 SQL 语句ORM（Object-Relational-Mapping“对象-关系-映射”），它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库。 自带强大的后台功能 几行代码就让网站拥有一个强大的后台，轻松管理内容。 优雅的网址 在urls.py中用正则匹配网址，传递到对应的函数。(需要注意的是:正则是一种独立的语法，并不是哪个语言所拥有的。) 具有模板系统 强大，易扩展的模板系统，设计简易，代码和样式分开设计，更易管理。 缓存系统&emsp;&emsp;Django和memcached、redis或者其他的缓存系统联用，表现更出色，提高了页面的加载速度。&emsp;&emsp;templates 文件夹views.py 中的函数渲染 templates 中的 Html 模板，得到动态内容的网页，当然可以用缓存来提高速度。 国际化 完全支持多语言应用，允许你定义翻译的字符，轻松翻译成不同国家的语言。 Django基本操作创建项目(test1)django-admin startproject test1 创建应用(booktest)python manage.py startapp booktest 创建更改的文件 （生成迁移）python manage.py makemigrations 将生成的py文件应用到数据库 （执行迁移）python manage.py migrate 创建一个管理员用户（按提示输入用户名，邮箱，密码）python manage.py createsuperuser 运行（可以指定ip地址和端口号）#python manage.py runserver 127.0.0.1:8001]]></content>
      <categories>
        <category>Django学习笔记</category>
        <category>1_Django概述</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC2018线下赛总结]]></title>
    <url>%2F2018%2F06%2F26%2FISCC2018%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[环境介绍先拿自己靶机，攻下高地，进入公共区域攻防这次比赛打得非常差，赛后又重新自己复现了一下，emmm大概是这个样子的给了一个环境，是Tomcat，开了8080端口 比赛信息是192.168.43.70/whatisyourname/，这里用到了fastjson反序列化漏洞，熟悉Java的同学应该能看出来(但我是真的看不出来（╯－＿－）╯╧╧ ) fastjson反序列化漏洞参考：https://blog.csdn.net/yaofeino1/article/details/76377080https://github.com/iBearcat/Fastjson-Payloadhttps://github.com/shengqi158/fastjson-remote-code-execute-poc 环境源码下载通过github下载含有漏洞环境的web源代码下载地址直接将war包放到tomcat的webapp目录下，运行tomcat就行： 漏洞复现：通过浏览器访问环境URL，利用burpsuite对数据包进行拦截，修改数据包发送方式并且插入POST数据{“name”:”feifei”,age:12} ，查看效果：然后根据参考文献找到Test.java文件构造poc(反弹shell)，编译一下生成.class文件base64 encode一下替换name字段，post过去可以看到命令执行成功nc连接上执行命令然后就是执行主办方给的getflag命令就可以打了，当时不知道什么原因环境命令执行有时能成功有时不成功≡￣﹏￣≡nc也死活连不上说到底还是自己好菜，对基础的东西理解还是不扎实，还是要多总结多刷题以赛代练，希望自己能进步的快一点 &lt;(￣ c￣)y▂ξ]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三届安恒杯线下赛总结]]></title>
    <url>%2F2018%2F06%2F26%2F%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AE%89%E6%81%92%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93-1%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这次比赛只有一道web环境，用的是ECShop V2.7.3&emsp;&emsp;模式是AD攻防，规则很简单（虽然半天才搞明白 ￣﹏￣），让对方的极其请求http://10.0.1.2，并带上自己的token，即可获取flag poc1post方式文件url：http://10.50.%s.2/mobile/index.php参数：url=http://10.0.1.2?token=RCNWBJXQ poc2post方式文件url：http://10.50.33.2/mobile/index.php?m=default&amp;c=auction参数：1=phpinfo() 提示线索1:mobile/themes/default/auction_list.dwt这是一个预留后门，比较叼D盾扫不出来提示线索2:mobile/api/uc.php 任意文件读取(poc 1)根据给出的poc1，我们快速去定位问题文件位置我们从mobile入口文件入手即： mobile/index.php查看内容跟踪文件 看到内容 跟踪apps/目录可以发现3个文件夹 我们首先看到默认文件夹 此时又得到5个文件夹 从第一个common文件夹开始可以看到insert.php中的一个函数 看到关键代码 其中 明显是一个任意文件读取利用脚本： 一句话木马文件(poc 2)防守方法删除预留后门auction_list.dwt文件即可当时官方给出提示：auction_list.dwt文件!upload successful由于此文件用于渲染，直接将小马删除即可 任意写文件防守方法改掉writesth函数名即可定位到mobile/api/uc.php在action数组中发现了一些奇怪的东西最后一个writesth十分瞩目，一看就应该是主办方留下的功能，我们全局搜索这个writesth函数不难发现以下关键代码：即：文件名可控文件内容可控即可写入Webshell我们测试运行即可发现我们当前目录下写入sky.php，内容为但是由于当时的环境里，只有data目录有可写全写，而我们默认路径为所以直接写可能无效，应该选择上跳，例如 ../data/sky.php ECShop v2.7.3后台直接getshell防守方法改掉后台密码即可（默认admin admin888） 弱口令本次比赛还有一个漏洞就是ctf用户弱口令cat /etc/shadow得到ctf账户密码123456就因为这个漏洞被dalao全场从头打到尾…]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>攻防</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hash长度拓展攻击]]></title>
    <url>%2F2018%2F05%2F08%2Fhash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[Hash Length Extension Attack&emsp;&emsp;总体来说就是我们知道一个加盐的hash值，即使我们不知道盐的具体内容，但只要知道长度就可以随便伪造种带盐的hash（相当于我们控制了明密文） MD5加密原理先介绍一下md5加密的原理 个人理解: md5的过程可以分成填充和压缩的过程 md5 padding(填充)&emsp;&emsp;message padding&emsp;&emsp;length%64=56(8位标识原始长度)填充的时候，将会使用16进制数据：&emsp;~1个\x80&emsp;~N个\0x00 md5 compress(压缩)&emsp;&emsp;message padding length—–&gt;hash&emsp;&emsp;length=N*64(bit) —–&gt;length%64(bit) md5 padding例如我们把admin来hash一下:admin 先hex编码-&gt;61646d696e再填充80不满64bit，填充到第56位（50个00）——为了保证信息的长度为N*64+56(字节)最后数据表示位2800000000000000（8个字节）最终结果为: 61646d6968000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000 什么是Magic number (确定值)代码中的0x67452301L, 0xefcdab89L, 0x98badcfeL, 0x10325476L这4个初始化的number就被称为Magic number或者是md5 iv (md5向量) md5 compress我们发现，无论输入多长的信息，计算出来的问就按hash长度都是固定的(md5有32字节)，这就是因为hash算法是一种压缩算法。Hash设计的时候不要求还原，所以就尽可能的扩大信息对每一位hash值的印象。在计算中，也是通过对每组长度为64bit信息分组进行迭代运算实现的。每一次迭代，都会利用一个初始值与本组中的原始信息做一个复杂的数学运算，而将生成的结果带入到下次的复杂运算中作为初始值我们还是计算admin的md5值。因为不满64bit,所以padding之后也只有64个bit，也就需要计算一轮compress压缩算法。压缩算法完成后产生的心magic number为：A=0x292f2321LB=0xa7a5577aLC=0xe4a8943LD=0xc31f804aL而md5的结果:我们发现其实就是这一轮结果的简单拼接（小端存储数据倒叙） hash长度拓展攻击其实只要知道三点后就能进行攻击： MD5(salt+message)的值 message内容 salt+message长度这样就可以在不知道salt的具体内容下，计算出任意的md5(salt+message+padding+append)值因为salt+message+padding内容是经过填充的，一定是N*64，所以这个部分刚好能完成N轮复杂运算。而他的结果，也就是md5(salt+message+padding)刚好是用来做下一轮运算，也就是m’+padding运算的初始向量。 攻击过程逆向算法很简单 def compute_magic_number(self, md5str): self.A = struct.unpack(&quot;I&quot;, md5str[0:8].decode(&apos;hex&apos;))[0] self.B = struct.unpack(&quot;I&quot;, md5str[8:16].decode(&apos;hex&apos;))[0] self.C = struct.unpack(&quot;I&quot;, md5str[16:24].decode(&apos;hex&apos;))[0] self.D = struct.unpack(&quot;I&quot;, md5str[24:32].decode(&apos;hex&apos;))[0] 由它逆出A=0x292f2321L,B=0xa7a5577aL,C=0xe4a8943L,D=0xc31f804aL根据这4个Magci number，再和扩展的字符串m’(此时的m’要进行padding，padding的长度是len(salt+message+padding+m’))进行md5 compress，最后的结果即md5(salt+message+padding+m’)这样就完成了长度拓展攻击 例题测试实验吧-让我进去抓包改source，Repeater过去发现源码 $flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;; $secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security $username = $_POST[&quot;username&quot;]; $password = $_POST[&quot;password&quot;]; if (!empty($_COOKIE[&quot;getmein&quot;])) { if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) { if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) { echo &quot;Congratulations! You are a registered user.\n&quot;; die (&quot;The flag is &quot;. $flag); } else { die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;); } } else { die (&quot;You are not an admin! LEAVE.&quot;); } } setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[&quot;source&quot;])) { setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[&quot;source&quot;] != 0) { echo &quot;&quot;; // This source code is outputted here } } 按照源码要求，cookie中要存在变量getmein，而且，要 $COOKIE[“getmein”] === md5($secret . urldecode($username . $password))sample-hash是secret+adminadmin的MD5这里secret相当于盐，我们并不知道，但是我们知道它的长度是15，算上后面admin就是20。数据是admin签名（哈希值）是571580b26c65f306376d4f64e53cb5c7生成的hash是新的签名，设置到cookies的getmein里面把\x换成%后post提交，得到flag]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝鲸笔记系统writeup]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%93%9D%E9%B2%B8%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9Fwriteup%2F</url>
    <content type="text"><![CDATA[蓝鲸笔记系统给出一个login界面，url看上去似乎有问题http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=login感觉像是有文件包含随便尝试一下http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=index果然是文件包含。先随便注册一个账号进去看看，发现 hint:./dbinit.sql 发现了flag字段，flag应该就是在数据库里面了 肯定是文件包含无疑了，相办法读源码 利用php伪协议读源码：php://filter/read=convert.base64-encode/resource=不让读，真尴尬 然后仔细看了看url，猜测这个front是文件夹名，login是文件名http://202.98.28.108:10013/7sghfe673jd3/front/index.php还是拒绝访问… 猜测后台脚本是这样写的:include($action.’/‘.$mode.’.php’)require”$action.’/‘.$mode.’.php’” 成功读出来了！！！login不让读，但是审计index.php的源码时发现common.php，顺便把源码也down下来 代码审计先看一下index.php，并没有发现什么东西在common.php中发现一些定义的函数 御剑扫一下，发现/admin/login.php , /admin/index.php，把源码都down下来在/admin/login.php中发现 /admin/login.php,调用了set_login()函数 /front/common.php中有set_login()函数的定义 来到http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login 跟踪一下这几个函数，这里设置了cookies和session。可以看出来最后set_cookie的值是$uname|$endata$uname是admin。则cookie是 admin|md5(SECURITY_KEY+admin) SECURITY_KEY 是个随机数，每一位是从wh两个字母中随机出来的6位随机数 看一下后台登陆验证 两个函数在common.php中 这里验证了userid和level，如果cookie验证失败，则返回false，level如果是0，也返回false。 但是如果我们没有登陆，直接来到/admin/index.php页面，而且绕过cookie的验证，那么userid和level的默认初始值都是null。在php中，null!==False Truenull!=FalseFalse$null!==false是返回true的。所以只要我们能伪造cookie，就可以绕过验证。 爆破cookie脚本import requests import hashlib import random import string false_tag = &quot;not login!&quot; url = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=index&quot; url_csrf = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login&quot; def rand_str(length): return &apos;&apos;.join(random.choice(string.ascii_letters + string.digits) for _ in range(length)) def md5_encode(data): hash = hashlib.md5() hash.update((data + &quot;admin&quot;).encode()) return hash.hexdigest() key = [] for x1 in [&quot;w&quot;,&quot;h&quot;]: for x2 in [&quot;w&quot;,&quot;h&quot;]: for x3 in [&quot;w&quot;,&quot;h&quot;]: for x4 in [&quot;w&quot;,&quot;h&quot;]: for x5 in [&quot;w&quot;,&quot;h&quot;]: for x6 in [&quot;w&quot;,&quot;h&quot;]: key.append(x1+x2+x3+x4+x5+x6) print key s = requests.Session() s.headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&apos;, &apos;cookie&apos;: &apos;&apos; } for x in key: s.headers[&quot;cookie&quot;] = &quot;uid=admin%7C&quot;+md5_encode(x)#+&quot;;&quot;+&quot;PHPSESSID={}&quot;.format(rand_str(26)) s.headers[&quot;PHPSESSID&quot;] = rand_str(26) print s.headers[&quot;cookie&quot;] result = s.get(url) #print result.content if false_tag in result.content: print &quot;NO&quot;,x else: print &quot;YES&quot; print s.headers print result.content break 发现setpagenumu页面，down下来源码 二次注入发现post的page是用户可以输入但是类型限制了纯数字，应该是没有办法注入 回去审计/admin/index.php 发现数据库里查询的是$page_size,跟踪get_page_size(), get_page_size()函数返回num，也就是index里面的$page_size感觉应该能注入，回去看数据库文件 发现数据库里定义的page是varchar类型标准的脚本代码与数据库类型不匹配利用is_numeric()函数的漏洞(认为0x…是整数)，构造一个二次注入 数据库文件中可以看到一共有四个列 构造注入语句2 union select 1,flag,flag,4 from flags转成十六进制注入即可拿到flag0x3220756e696f6e2073656c65637420312c666c61672c666c61672c342066726f6d20666c616773]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>二次注入</tag>
        <tag>php函数漏洞</tag>
        <tag>php伪协议</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件管理系统writeup]]></title>
    <url>%2F2018%2F04%2F08%2Fday1%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件上传之代码审计前几天做了一道有趣的web题，涉及到文件上传，代码审计，二次注入。 首先是一个文件管理系统，上传文件，重命名文件，删除文件的功能。也给出了网站源码。先审计代码，看一下upload.php文件上传函数，先看服务器怎么检查文件的，可以看到$pat_part[“extension”]不允许php上传其中文件名 也被addslashes函数过滤，转义了一些字符，因此这里应该不存在注入 文件名存在数据库两个字段中，一个是filename（文件名），一个是extension（后缀名） 可以看出来文件名走过的流程是：$file[‘name’]—&gt;pathinfo()—&gt;$path_part[‘filename’]—&gt;addslashes()—&gt;insert 再看一下rename.php首先查询文件名，如果存在，执行sql语句根据$req[‘filename’]从数据库里查询到已存在的一行，并调用update语句进行修改 但在这里{oldname=[‘filename’]}将从数据库里查出的$result[‘filename’]再一次入库，结果造成一个二次注入 如果我们可以插入让extension的值为空，再把文件名在改名为.php就可以解析了 那么思路很明确，我们上传一个有恶意字段的jpg文件，然后rename进数据库，让后缀名变为空，然后再上传一个木马文件，由于extension为空，所以再次修改的时候不会加上.jpg的扩展名。 解题步骤： 上传文件名为’,extension=’’,filename=’aa.jpg.jpg 这样filename的值为’,extension=’’,filename=’aa.jpg 我们重命名把’,extension=’’,filename=’aa.jpg改为aa.jpg 这时我们再次上传一个写有木马的文件，文件名为aa.jpg 此时不会提示file is exists 因为extension!=jpg 将aa.jpg改为aa.php即可]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>代码审计</tag>
        <tag>二次注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F04%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSA总结]]></title>
    <url>%2F2018%2F04%2F06%2Frsa%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[先留个坑，回头写…]]></content>
      <categories>
        <category>crypto</category>
      </categories>
      <tags>
        <tag>crypto</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传常规漏洞总结]]></title>
    <url>%2F2018%2F04%2F01%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%84%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[从文件上传到getshell一般找到文件上传页面，常规getshell思路:先检查服务器验证上传文件的逻辑，再想办法绕过 前台js验证——禁用js，burpsuit抓包绕过即可 后台检查MIME——抓包改MIME 后台文件内容检测——(一般是用GetImageSize函数) 制作图片马上传 .hatccess上传(apache)——创建一个.hatccseea文件设置命名有”php.gif”的文件当作php文件解析执行：&lt;FilesMatch “php.gif”&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 上传的jpg文件都会以php格式解析：AddType application/x-httpd-php .jpg 后台检查文件后缀名—— 0x00截断上传 (php版本小于5.3.4，php的magic_quotes_gpc为OFF)1.php .png(空格改为00) IIS6.0解析漏洞文件 xxx.asp;.jpg (服务器默认不解析;号后面的内容) 文件夹 xxx.asp/xxx.jpg (服务器默认会把.asp，.asp目录下的文件都解析成asp文件) apache解析漏洞www.xxx.com/logo.jpg.php.xxx(遇到不识别的后缀名向前解析) iis7.0和nginx解析漏洞www.xxx.com/logo.jpg/*.php(开启fix_pathinfo) 文件包含漏洞和利用 如果php脚本中使用了include,include_once,reqiure,requier_once这四个函数，并且函数的参数是用户可以控制的，就能造成文件包含漏洞 通常的include函数中，就算是可以控制参数但是后缀名也大多被限制，例如include($file.’.txt’)这样就只能包含txt文件。这时我们可以结合%00截断包含任意文件。index.php%00 文件包含漏洞也可以结合php伪协议，例如php://,phar://等等(php://input甚至可以写入木马)。例如文件包含进来但是无法显示时，可以用伪协议读文件的源码(php://filter/read=convert.base64-encode/resourse=包含文件)]]></content>
      <categories>
        <category>文件上传</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>web</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次攻防训练赛小记]]></title>
    <url>%2F2018%2F04%2F01%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%BB%E9%98%B2%E8%AE%AD%E7%BB%83%E8%B5%9B%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;昨天按照实验室的要求，我们参加了个人的第一场ctf攻防形式的训练赛。形式是线上赛，由师傅搭好的环境，总体来说收获还是很大的，见识到了很多有(yin)趣(xian)的套路。总结一下 &emsp;&emsp;先说一下规则，一个五个队伍，每队两人。因为是训练，只有三道Web题，拿到其他队的flag加十分，被攻击队伍扣除相应分数。重启服务器扣除300分。五分钟一回合，宕机一回合扣除 (未宕机队伍的数量)*3 ，分数平均加到相应的队伍。（过程中发现一个骚操作就是当其他队伍宕机了，你还可以用之前上的shell拿flag，这样相当于多加了一部分分数） 第一道题是semcms1.1版本，上网查到相应漏洞，首先注入找到后台密码，后台有个任意文件上传，上一张图片马直接getshell，连菜刀顺利拿到flag。但是大佬们更快一步，已经吊打我们而且把洞修好了… 第三题是一个微窗cms，有一个命令执行的洞。稍微有一点点麻烦，这个好像没法上shell，直接构造命令执行语句也能读出flag 第二题最骚，页面发现一个神奇md5，解密后发现是ranzhi，搜了一些poc都用不了，最后也没做出来。最后师傅们分享write up后发现website源码里有一个预留后门，直接菜刀拿shell！！！(hao qi ya)正规解法是mysql查询到登录密码，登陆进去有一个上shell的地方。本菜代码审计能力太差，也没看懂 这次比赛下来身为小白总结了几点：&emsp;&emsp;对于一个攻防比赛，最开始并不是攻击，也不是防御。二话不说ssh连上自己website把源码备份一遍。这样以来，如果以后不慎自己服务器宕机了，还有复原的机会。 1234攻击方面： 拿到一个Web，黑盒找漏洞就比较简单，上网搜对应的资料。 白盒的话就是代码审计，打包下载到本地，利用代码审计工具Seay快速审计。 还有就是看看对数据库的操作有没有限制，这次就是出题人对mysql并没有任何限制，也就是说很多东西我们直接可以从数据库里找。还有就是看一下有没有出题人留得后门。 12345防御方面：首先猜测防御规则， 不要再防守的时候吧自己服务器给干掉了。 通用防御：上waf，直接吧不想要的请求比如post，get全部给禁掉等等； 设置目录权限，例如上传目录权限给死。 最后一个也是最耗时间的，就是代码审计，找到漏洞存在的位置，修改代码。 &emsp;&emsp;比赛结束后的交流也见识到了一些骚套路，比如什么不死马，利用虚拟机做蜜罐专偷其他队伍shell什么的，zhang见识了，具体的操作有空再研究。奋斗ing…]]></content>
      <categories>
        <category>CTF</category>
        <category>AWD</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[本着分享即学习的原则，本菜最近新搭建了博客。（⊙.⊙） 一方面是记录一下平时学习中遇到一些问题和想法;另一方面算是激励自己学习的一个动力。(ง •̀_•́)ง (*•̀ㅂ•́)و 如有错误还请各位师傅批评指正。(´･◡･`)]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"><![CDATA[hei,john]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
